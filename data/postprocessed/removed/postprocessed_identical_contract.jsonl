{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The bug is that the time range constraints (`valid_from`, `valid_to`) are not checked in the `merkle_minter` or `validate` functions. This omission allows transactions to be executed outside of their intended valid time range, potentially leading to unauthorized or unintended contract executions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that misuses the time range constraints (`valid_from`, `valid_to`), allowing invalid execution timing."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "In the `IncrementAccount` case of the `validate` function, the line `output_data == InlineDatum(Account(credential, current_amount + 1))` does not check for overflow when incrementing `current_amount`. This can lead to a numeric overflow if `current_amount` is at its maximum value, causing it to wrap around to a negative or zero value.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The bug is in the `BurnAccount` case of the `merkle_minter` function. The code expects the amount to be exactly `-1` when burning a token. However, it does not handle cases where the amount might be less than `-1`, which could occur due to unexpected numeric inputs or errors in transaction construction. This could lead to incorrect validation of burn transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "In the `IncrementAccount` case of the `validate` function, the code uses `option.map` to transform the result of `list.find`. However, it does not handle the case where `list.find` returns `None`, which means that if `list.find` does not find a matching input, the `expect Some(own_input)` will incorrectly succeed with a `None` value, potentially leading to unintended acceptance of invalid data.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that incorrectly handles optional fields, causing unintended acceptance of invalid data."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The code omits validation of the token name when minting tokens, allowing unrestricted minting of tokens without checking if the token name is valid or authorized.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The bug allows any redeemer value to be used in the `withdraw` function, as the `_redeemer` parameter is not checked or validated against any specific conditions or logic. This could lead to unintended redeemer values being accepted for withdrawal operations.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows redeemer values not intended for that branch of logic."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The bug is that the transaction deadline is not checked at all in the `withdraw` function, which could allow transactions to be processed even if they are past their intended deadline. This could lead to unauthorized withdrawals if the transaction is executed after the expected time window.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The code does not include any mechanism to ensure the uniqueness of transaction IDs, which allows the same transaction to be replayed multiple times. This can lead to replay attacks where an attacker can reuse a valid transaction to withdraw or spend funds multiple times.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The bug is in the `withdraw` function where the `expect ref_datum: MultiSignDatum = raw_datum` line does not properly validate the datum hash against the expected hash. This allows a mismatch between the datum and its hash, potentially enabling misuse of datums.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/transaction.{\n  DatumHash, Input, NoDatum, Output, OutputReference, ScriptContext, Spend,\n  TransactionId,\n} as tx\nuse aiken/transaction/credential.{Signature, VerificationKey}\nuse aiken/transaction/value.{Value}\nuse iagon/helpers\nuse iagon/test_utils as t_utils\nuse iagon/types.{POSIXTime, PubKeyHash}\n\ntype RewardCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Provider PubKey \n  provider_key: PubKeyHash,\n  // Value being Rewarded to Provider\n  value: Value,\n}\n\ntype Redeemer =\n  (ByteArray, Signature)\n\n/// Reward Validator is parameterized by \n/// 1. operator_vkey     (Verification Key of operator which generates certificate)\n/// 2. owner_pubkey_hash (Owner who will fund value to Reward contract)\n///\n///\n/// Storage Providers at Iagon will receive reward based on their performance, speed & \n/// amount of Storage allocated. All of this information is available offchain.\n/// When any provider wants to withdraw some reward from contract he will first request certificate\n/// from operator signing server.\n/// Then he will use that certificate signed by operator to claim reward from contract\n///\n/// Owner of reward contract can also claim without having to sign by operator. \n/// This is needed because\n/// 1. We might put wrong value in operator_vkey and funds are locked forever. \n/// 2. By many Claims from provider we might endup with dust utxos. \n///    Therefore we might want to adjust Reward Utxos as we need them\n/// \nvalidator(operator_vkey: VerificationKey, owner_pubkey_hash: PubKeyHash) {\n  fn reward(_datum, redeemer: Option<Redeemer>, ctx: ScriptContext) {\n    when redeemer is {\n      // Provider is trying to claim Reward\n      Some((msg, sig)) ->\n        validate_reward_for_provider(operator_vkey, msg, sig, ctx)\n\n      // Owner is trying to reclaim reward from contract\n      None -> helpers.must_be_signed_by(ctx.transaction, owner_pubkey_hash)\n    }\n  }\n}\n\nfn find_output_reward_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> RewardCertificate {\n  expect Some(data) = tx.find_datum(outputs, datums, dtm_hash)\n  expect reward_cert: RewardCertificate = data\n  reward_cert\n}\n\nfn validate_reward_for_provider(\n  operator_vkey: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n  ctx: ScriptContext,\n) -> Bool {\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // There must be one input to cover total reward. \n  // TODO: Maybe we can allow multiple input from same contract address\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n\n  // There must be atleast one output to same contract address. \n  // any leftover value left after giving to provider will go back to contract\n  expect [own_output] = helpers.list_continuing_outputs(ctx, own_input)\n\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  let cert = find_output_reward_datum([own_output], ctx.transaction.datums, msg)\n\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n\n  // Value which is only being rewarded to provider\n  let total_value_claimed =\n    own_output.value\n      |> value.negate()\n      |> value.merge(own_input.output.value)\n\n  // Value left after rewarding to provider\n  let is_valid_output_value = total_value_claimed == cert.value\n\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in) && helpers.must_be_signed_by(\n    ctx.transaction,\n    cert.provider_key,\n  ) && is_valid_output_value\n}\n\ntest cannot_claim_more_value_than_defined_in_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // trying to claim 5 ADA from Reward \n  // though certificate only allowing 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(15000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(5000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_reward_if_certificate_is_expired() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(25) // tx after cert is expired\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_if_not_signed_by_provider() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest provider_can_claim_with_correct_value_and_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == True\n}\n\n// Parsing datum test\n\ntest reward_certificate_datum_test() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let reward_cert =\n    RewardCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: tx.TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      value: value.from_lovelace(1000000),\n      provider_key: pub_key,\n    }\n  let dtm = cbor.serialise(reward_cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3a140a1401a000f4240ff\"\n}\n\ntest reward_redeemer_datum_test() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let redeemer = cbor.serialise(Some((msg, sig)))\n  let none_redeemer = cbor.serialise(None)\n\n  bytearray.to_hex(redeemer) == @\"d8799f9f436d736743736967ffff\" && bytearray.to_hex(\n    none_redeemer,\n  ) == @\"d87a80\"\n}", "bug_explanation": "The bug is in the `validate_reward_for_provider` function where the check for `is_valid_output_value` uses `==` instead of `!=`. This means that the function will incorrectly validate the output value as valid when it should not, allowing incorrect reward claims.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/reward.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/transaction.{\n  DatumHash, Input, NoDatum, Output, OutputReference, ScriptContext, Spend,\n  TransactionId,\n} as tx\nuse aiken/transaction/credential.{Signature, VerificationKey}\nuse aiken/transaction/value.{Value}\nuse iagon/helpers\nuse iagon/test_utils as t_utils\nuse iagon/types.{POSIXTime, PubKeyHash}\n\ntype RewardCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Provider PubKey \n  provider_key: PubKeyHash,\n  // Value being Rewarded to Provider\n  value: Value,\n}\n\ntype Redeemer =\n  (ByteArray, Signature)\n\n/// Reward Validator is parameterized by \n/// 1. operator_vkey     (Verification Key of operator which generates certificate)\n/// 2. owner_pubkey_hash (Owner who will fund value to Reward contract)\n///\n///\n/// Storage Providers at Iagon will receive reward based on their performance, speed & \n/// amount of Storage allocated. All of this information is available offchain.\n/// When any provider wants to withdraw some reward from contract he will first request certificate\n/// from operator signing server.\n/// Then he will use that certificate signed by operator to claim reward from contract\n///\n/// Owner of reward contract can also claim without having to sign by operator. \n/// This is needed because\n/// 1. We might put wrong value in operator_vkey and funds are locked forever. \n/// 2. By many Claims from provider we might endup with dust utxos. \n///    Therefore we might want to adjust Reward Utxos as we need them\n/// \nvalidator(operator_vkey: VerificationKey, owner_pubkey_hash: PubKeyHash) {\n  fn reward(_datum, redeemer: Option<Redeemer>, ctx: ScriptContext) {\n    when redeemer is {\n      // Provider is trying to claim Reward\n      Some((msg, sig)) ->\n        validate_reward_for_provider(operator_vkey, msg, sig, ctx)\n\n      // Owner is trying to reclaim reward from contract\n      None -> helpers.must_be_signed_by(ctx.transaction, owner_pubkey_hash)\n    }\n  }\n}\n\nfn find_output_reward_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> RewardCertificate {\n  expect Some(data) = tx.find_datum(outputs, datums, dtm_hash)\n  expect reward_cert: RewardCertificate = data\n  reward_cert\n}\n\nfn validate_reward_for_provider(\n  operator_vkey: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n  ctx: ScriptContext,\n) -> Bool {\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // There must be one input to cover total reward. \n  // TODO: Maybe we can allow multiple input from same contract address\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n\n  // There must be atleast one output to same contract address. \n  // any leftover value left after giving to provider will go back to contract\n  expect [own_output] = helpers.list_continuing_outputs(ctx, own_input)\n\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  let cert = find_output_reward_datum([own_output], ctx.transaction.datums, msg)\n\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n\n  // Value which is only being rewarded to provider\n  let total_value_claimed =\n    own_output.value\n      |> value.negate()\n      |> value.merge(own_input.output.value)\n\n  // Value left after rewarding to provider\n  let is_valid_output_value = total_value_claimed == cert.value\n\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in) && helpers.must_be_signed_by(\n    ctx.transaction,\n    cert.provider_key,\n  ) && is_valid_output_value\n}\n\ntest cannot_claim_more_value_than_defined_in_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // trying to claim 5 ADA from Reward \n  // though certificate only allowing 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(15000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(5000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_reward_if_certificate_is_expired() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(25) // tx after cert is expired\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_if_not_signed_by_provider() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest provider_can_claim_with_correct_value_and_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == True\n}\n\n// Parsing datum test\n\ntest reward_certificate_datum_test() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let reward_cert =\n    RewardCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: tx.TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      value: value.from_lovelace(1000000),\n      provider_key: pub_key,\n    }\n  let dtm = cbor.serialise(reward_cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3a140a1401a000f4240ff\"\n}\n\ntest reward_redeemer_datum_test() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let redeemer = cbor.serialise(Some((msg, sig)))\n  let none_redeemer = cbor.serialise(None)\n\n  bytearray.to_hex(redeemer) == @\"d8799f9f436d736743736967ffff\" && bytearray.to_hex(\n    none_redeemer,\n  ) == @\"d87a80\"\n}", "bug_explanation": "In the `validate_reward_for_provider` function, the line `expect [own_output] = helpers.list_continuing_outputs(ctx, own_input)` assumes that there is exactly one continuing output. If there are multiple outputs, this will cause an off-by-one error when accessing the list, as it will only consider the first output and ignore the rest. This can lead to incorrect validation if the expected output is not the first one in the list.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/reward.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/transaction.{\n  DatumHash, Input, NoDatum, Output, OutputReference, ScriptContext, Spend,\n  TransactionId,\n} as tx\nuse aiken/transaction/credential.{Signature, VerificationKey}\nuse aiken/transaction/value.{Value}\nuse iagon/helpers\nuse iagon/test_utils as t_utils\nuse iagon/types.{POSIXTime, PubKeyHash}\n\ntype RewardCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Provider PubKey \n  provider_key: PubKeyHash,\n  // Value being Rewarded to Provider\n  value: Value,\n}\n\ntype Redeemer =\n  (ByteArray, Signature)\n\n/// Reward Validator is parameterized by \n/// 1. operator_vkey     (Verification Key of operator which generates certificate)\n/// 2. owner_pubkey_hash (Owner who will fund value to Reward contract)\n///\n///\n/// Storage Providers at Iagon will receive reward based on their performance, speed & \n/// amount of Storage allocated. All of this information is available offchain.\n/// When any provider wants to withdraw some reward from contract he will first request certificate\n/// from operator signing server.\n/// Then he will use that certificate signed by operator to claim reward from contract\n///\n/// Owner of reward contract can also claim without having to sign by operator. \n/// This is needed because\n/// 1. We might put wrong value in operator_vkey and funds are locked forever. \n/// 2. By many Claims from provider we might endup with dust utxos. \n///    Therefore we might want to adjust Reward Utxos as we need them\n/// \nvalidator(operator_vkey: VerificationKey, owner_pubkey_hash: PubKeyHash) {\n  fn reward(_datum, redeemer: Option<Redeemer>, ctx: ScriptContext) {\n    when redeemer is {\n      // Provider is trying to claim Reward\n      Some((msg, sig)) ->\n        validate_reward_for_provider(operator_vkey, msg, sig, ctx)\n\n      // Owner is trying to reclaim reward from contract\n      None -> helpers.must_be_signed_by(ctx.transaction, owner_pubkey_hash)\n    }\n  }\n}\n\nfn find_output_reward_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> RewardCertificate {\n  expect Some(data) = tx.find_datum(outputs, datums, dtm_hash)\n  expect reward_cert: RewardCertificate = data\n  reward_cert\n}\n\nfn validate_reward_for_provider(\n  operator_vkey: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n  ctx: ScriptContext,\n) -> Bool {\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // There must be one input to cover total reward. \n  // TODO: Maybe we can allow multiple input from same contract address\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n\n  // There must be atleast one output to same contract address. \n  // any leftover value left after giving to provider will go back to contract\n  expect [own_output] = helpers.list_continuing_outputs(ctx, own_input)\n\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  let cert = find_output_reward_datum([own_output], ctx.transaction.datums, msg)\n\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n\n  // Value which is only being rewarded to provider\n  let total_value_claimed =\n    own_output.value\n      |> value.negate()\n      |> value.merge(own_input.output.value)\n\n  // Value left after rewarding to provider\n  let is_valid_output_value = total_value_claimed == cert.value\n\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in) && helpers.must_be_signed_by(\n    ctx.transaction,\n    cert.provider_key,\n  ) && is_valid_output_value\n}\n\ntest cannot_claim_more_value_than_defined_in_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // trying to claim 5 ADA from Reward \n  // though certificate only allowing 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(15000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(5000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_reward_if_certificate_is_expired() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(25) // tx after cert is expired\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_if_not_signed_by_provider() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest provider_can_claim_with_correct_value_and_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == True\n}\n\n// Parsing datum test\n\ntest reward_certificate_datum_test() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let reward_cert =\n    RewardCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: tx.TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      value: value.from_lovelace(1000000),\n      provider_key: pub_key,\n    }\n  let dtm = cbor.serialise(reward_cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3a140a1401a000f4240ff\"\n}\n\ntest reward_redeemer_datum_test() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let redeemer = cbor.serialise(Some((msg, sig)))\n  let none_redeemer = cbor.serialise(None)\n\n  bytearray.to_hex(redeemer) == @\"d8799f9f436d736743736967ffff\" && bytearray.to_hex(\n    none_redeemer,\n  ) == @\"d87a80\"\n}", "bug_explanation": "The bug is introduced in the `validate_reward_for_provider` function where the calculation of `total_value_claimed` does not check for potential overflow or underflow when merging values. This can lead to incorrect calculations if the values are manipulated to exceed the maximum or minimum bounds of the data type, potentially allowing unauthorized claims or incorrect reward distributions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/reward.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/transaction.{\n  DatumHash, Input, NoDatum, Output, OutputReference, ScriptContext, Spend,\n  TransactionId,\n} as tx\nuse aiken/transaction/credential.{Signature, VerificationKey}\nuse aiken/transaction/value.{Value}\nuse iagon/helpers\nuse iagon/test_utils as t_utils\nuse iagon/types.{POSIXTime, PubKeyHash}\n\ntype RewardCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Provider PubKey \n  provider_key: PubKeyHash,\n  // Value being Rewarded to Provider\n  value: Value,\n}\n\ntype Redeemer =\n  (ByteArray, Signature)\n\n/// Reward Validator is parameterized by \n/// 1. operator_vkey     (Verification Key of operator which generates certificate)\n/// 2. owner_pubkey_hash (Owner who will fund value to Reward contract)\n///\n///\n/// Storage Providers at Iagon will receive reward based on their performance, speed & \n/// amount of Storage allocated. All of this information is available offchain.\n/// When any provider wants to withdraw some reward from contract he will first request certificate\n/// from operator signing server.\n/// Then he will use that certificate signed by operator to claim reward from contract\n///\n/// Owner of reward contract can also claim without having to sign by operator. \n/// This is needed because\n/// 1. We might put wrong value in operator_vkey and funds are locked forever. \n/// 2. By many Claims from provider we might endup with dust utxos. \n///    Therefore we might want to adjust Reward Utxos as we need them\n/// \nvalidator(operator_vkey: VerificationKey, owner_pubkey_hash: PubKeyHash) {\n  fn reward(_datum, redeemer: Option<Redeemer>, ctx: ScriptContext) {\n    when redeemer is {\n      // Provider is trying to claim Reward\n      Some((msg, sig)) ->\n        validate_reward_for_provider(operator_vkey, msg, sig, ctx)\n\n      // Owner is trying to reclaim reward from contract\n      None -> helpers.must_be_signed_by(ctx.transaction, owner_pubkey_hash)\n    }\n  }\n}\n\nfn find_output_reward_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> RewardCertificate {\n  expect Some(data) = tx.find_datum(outputs, datums, dtm_hash)\n  expect reward_cert: RewardCertificate = data\n  reward_cert\n}\n\nfn validate_reward_for_provider(\n  operator_vkey: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n  ctx: ScriptContext,\n) -> Bool {\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // There must be one input to cover total reward. \n  // TODO: Maybe we can allow multiple input from same contract address\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n\n  // There must be atleast one output to same contract address. \n  // any leftover value left after giving to provider will go back to contract\n  expect [own_output] = helpers.list_continuing_outputs(ctx, own_input)\n\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  let cert = find_output_reward_datum([own_output], ctx.transaction.datums, msg)\n\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n\n  // Value which is only being rewarded to provider\n  let total_value_claimed =\n    own_output.value\n      |> value.negate()\n      |> value.merge(own_input.output.value)\n\n  // Value left after rewarding to provider\n  let is_valid_output_value = total_value_claimed == cert.value\n\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in) && helpers.must_be_signed_by(\n    ctx.transaction,\n    cert.provider_key,\n  ) && is_valid_output_value\n}\n\ntest cannot_claim_more_value_than_defined_in_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // trying to claim 5 ADA from Reward \n  // though certificate only allowing 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(15000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(5000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_reward_if_certificate_is_expired() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(25) // tx after cert is expired\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_if_not_signed_by_provider() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest provider_can_claim_with_correct_value_and_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == True\n}\n\n// Parsing datum test\n\ntest reward_certificate_datum_test() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let reward_cert =\n    RewardCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: tx.TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      value: value.from_lovelace(1000000),\n      provider_key: pub_key,\n    }\n  let dtm = cbor.serialise(reward_cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3a140a1401a000f4240ff\"\n}\n\ntest reward_redeemer_datum_test() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let redeemer = cbor.serialise(Some((msg, sig)))\n  let none_redeemer = cbor.serialise(None)\n\n  bytearray.to_hex(redeemer) == @\"d8799f9f436d736743736967ffff\" && bytearray.to_hex(\n    none_redeemer,\n  ) == @\"d87a80\"\n}", "bug_explanation": "The bug is in the `validate_reward_for_provider` function, where the code expects exactly one continuing output to the same contract address with `expect [own_output] = helpers.list_continuing_outputs(ctx, own_input)`. This line assumes there is exactly one output, but it should allow for multiple outputs to the same address. This incorrect validation can lead to unexpected behavior if there are multiple valid outputs, as it will fail the transaction validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/reward.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "//// 1. Supply/Deposit - Lender deposits tokens - receives LP tokens\n//// 2. Withdraw - Lender burns LP tokens - receives deposit tokens\n//// 3. Borrow - Borrower deposits collateral - receives borrower NFT + loan\n//// 4. Repay - Borrower deposits Loan + NFT - receives collateral\n//// 5. Liquidate - Someone deposits Loan tokens, receives a piece of collateral\n\nuse aada/types.{Wrapped, WrappedRedeemer}\nuse aada/types/collateral\nuse aada/types/order\nuse aada/types/pool\nuse aada/utils\nuse aiken/dict\nuse aiken/list\nuse aiken/math\nuse aiken/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, ScriptContext,\n  Spend, Transaction,\n}\nuse aiken/transaction/credential.{VerificationKeyCredential}\nuse aiken/transaction/value.{from_minted_value, quantity_of}\n\nfn order_wrapper(\n  lambda: fn(b, pool.Action) -> Bool,\n  datum: order.Datum<a>,\n  redeemer: order.Redeemer<b>,\n  ctx: ScriptContext,\n) {\n  let ScriptContext {\n    transaction: Transaction {\n      inputs,\n      redeemers,\n      extra_signatories,\n      withdrawals,\n      ..\n    },\n    purpose,\n  } = ctx\n  expect Spend(this_oref) = purpose\n  when redeemer is {\n    order.Cancel ->\n      utils.authorized_by_credential(\n        extra_signatories,\n        withdrawals,\n        datum.control_credential,\n      )\n    order.Process { pool_oref, additional_data } -> {\n      expect Some(Input { output: Output { value: pool_output_value, .. }, .. }) =\n        list.find(inputs, fn(inp) -> Bool { inp.output_reference == pool_oref })\n      expect Some(raw_pool_redeemer): Option<Data> =\n        dict.get(redeemers, Spend(pool_oref))\n      expect Wrapped(pool.Redeemer { action, order, .. }): WrappedRedeemer<\n        pool.Redeemer,\n      > = raw_pool_redeemer\n      let pool_nft_found =\n        quantity_of(\n          pool_output_value,\n          datum.pool_nft_cs.policy_id,\n          datum.pool_nft_cs.asset_name,\n        ) == 1\n      let pool_tagged_this = order == Some(this_oref)\n      and {\n        pool_nft_found?,\n        pool_tagged_this?,\n        lambda(additional_data, action)?,\n      }\n    }\n  }\n}\n\nvalidator {\n  fn deposit_order_contract(\n    datum: order.Datum<order.DepositRequest>,\n    redeemer: order.Redeemer<Void>,\n    ctx: ScriptContext,\n  ) -> Bool {\n    fn(_: Void, pool_action: pool.Action) -> Bool {\n      when pool_action is {\n        pool.Continuing(pool.LpAdjust { value_delta, .. }) -> {\n          let order.DepositRequest {\n            deposit_amount,\n            partial_output: order.PartialOutput {\n              address,\n              value,\n              datum: order_datum,\n            },\n            lp_asset,\n          } = datum.order\n          // All minted assets go to depositor since only one interaction with the pool on the TX\n          let lp_assets_minted =\n            quantity_of(\n              from_minted_value(ctx.transaction.mint),\n              lp_asset.policy_id,\n              lp_asset.asset_name,\n            )\n\n          let real_output = {\n            expect Spend(this_oref) = ctx.purpose\n\n            let expected_datum =\n              when order_datum is {\n                NoDatum -> InlineDatum(this_oref)\n                _ -> order_datum\n              }\n            Output {\n              address,\n              value: value.add(\n                value,\n                lp_asset.policy_id,\n                lp_asset.asset_name,\n                lp_assets_minted,\n              ),\n              datum: expected_datum,\n              reference_script: None,\n            }\n          }\n\n          let user_received_value =\n            ctx.transaction.outputs\n              |> list.any(fn(out) { out == real_output })\n          and {\n            user_received_value?,\n            (value_delta == deposit_amount)?,\n          }\n        }\n        _ -> False\n      }\n    }\n      |> order_wrapper(datum, redeemer, ctx)\n  }\n}\n\nvalidator {\n  fn withdraw_order_contract(\n    datum: order.Datum<order.WithdrawRequest>,\n    redeemer: order.Redeemer<Void>,\n    ctx: ScriptContext,\n  ) -> Bool {\n    fn(_: Void, pool_action: pool.Action) -> Bool {\n      when pool_action is {\n        pool.Continuing(pool.LpAdjust { value_delta, .. }) -> {\n          let order.WithdrawRequest {\n            lp_tokens_burn,\n            partial_output: order.PartialOutput { address, value, datum },\n            receive_asset,\n            lp_asset,\n          } = datum.order\n\n          let burnt_asset =\n            quantity_of(\n              from_minted_value(ctx.transaction.mint),\n              lp_asset.policy_id,\n              lp_asset.asset_name,\n            ) == -lp_tokens_burn\n\n          let real_output =\n            when address.payment_credential is {\n              VerificationKeyCredential(_) -> {\n                expect Spend(this_oref) = ctx.purpose\n                let expected_datum: OutputReference = this_oref\n                let expected_datum: Datum = InlineDatum(expected_datum)\n\n                Output {\n                  address,\n                  value: value.add(\n                    value,\n                    receive_asset.policy_id,\n                    receive_asset.asset_name,\n                    -value_delta,\n                  ),\n                  datum: expected_datum,\n                  reference_script: None,\n                }\n              }\n              _ ->\n                Output {\n                  address,\n                  value: value.add(\n                    value,\n                    receive_asset.policy_id,\n                    receive_asset.asset_name,\n                    -value_delta,\n                  ),\n                  datum,\n                  reference_script: None,\n                }\n            }\n          let user_received_value =\n            ctx.transaction.outputs\n              |> list.any(fn(out) { out == real_output })\n          and {\n            user_received_value?,\n            burnt_asset?,\n          }\n        }\n        _ -> False\n      }\n    }\n      |> order_wrapper(datum, redeemer, ctx)\n  }\n}\n\nvalidator {\n  fn borrow_order_contract(\n    datum: order.Datum<order.BorrowRequest>,\n    redeemer: order.Redeemer<order.ProcessBorrow>,\n    ctx: ScriptContext,\n  ) -> Bool {\n    expect Spend(this_oref) = ctx.purpose\n    fn(borrow_redeemer, pool_action: pool.Action) -> Bool {\n      when pool_action is {\n        pool.Continuing(pool.Borrow {\n          interest_rate,\n          collateral_amount,\n          loan_amount: loan_amount_sent_to_pool,\n          ..\n        }) -> {\n          expect Some(this_input) =\n            list.find(\n              ctx.transaction.inputs,\n              fn(inp) { inp.output_reference == this_oref },\n            )\n          let order.BorrowRequest {\n            borrower_nft_policy,\n            expected_output,\n            partial_output: order.PartialOutput {\n              address,\n              value: partial_output_value,\n              datum,\n            },\n            max_interest_rate,\n            min_deposit_time,\n            min_collateral_amount,\n            collateral_address,\n          } = datum.order\n          let order.ProcessBorrow(borrower_token_name, additional_ada) =\n            borrow_redeemer\n          // Lender must receive the LPs\n          let user_received_value =\n            list.any(\n              ctx.transaction.outputs,\n              fn(out) { out == expected_output },\n            )\n          // because the nft policy only mints one at a time, we know this is unique.\n          let borrower_token_minted =\n            quantity_of(\n              from_minted_value(ctx.transaction.mint),\n              borrower_nft_policy,\n              borrower_token_name,\n            ) == 1\n          let expected_recipient_output =\n            Output {\n              address,\n              value: value.add(\n                value.add(\n                  partial_output_value,\n                  borrower_nft_policy,\n                  borrower_token_name,\n                  1,\n                ),\n                \"\",\n                \"\",\n                math.abs(additional_ada),\n              ),\n              datum,\n              reference_script: None,\n            }\n          let recipient_got_borrow_nft =\n            list.any(\n              ctx.transaction.outputs,\n              fn(out) { out == expected_recipient_output },\n            )\n          let collateral_output_match =\n            (\n              list.filter(\n                ctx.transaction.outputs,\n                fn(out) {\n                  let Output { address: addr, datum: the_datum, .. } = out\n                  when the_datum is {\n                    InlineDatum(col_datum) ->\n                      if addr == collateral_address {\n                        expect collateral_datum: collateral.CollateralDatum =\n                          col_datum\n                        let tag_matches =\n                          collateral_datum.tag == Some(this_oref)\n                        let valid_loan_start_time =\n                          collateral_datum.deposit_time >= min_deposit_time\n                        let valid_loan_amount =\n                          if collateral_datum.loan_cs.policy_id == \"\" {\n                            loan_amount_sent_to_pool >= quantity_of(\n                              this_input.output.value,\n                              collateral_datum.loan_cs.policy_id,\n                              collateral_datum.loan_cs.asset_name,\n                            ) - math.abs(additional_ada)\n                          } else {\n                            loan_amount_sent_to_pool >= quantity_of(\n                              this_input.output.value,\n                              collateral_datum.loan_cs.policy_id,\n                              collateral_datum.loan_cs.asset_name,\n                            )\n                          }\n                        and {\n                          valid_loan_amount?,\n                          tag_matches?,\n                          valid_loan_start_time?,\n                        }\n                      } else {\n                        False\n                      }\n                    _ -> False\n                  }\n                },\n              )\n                |> list.length\n            ) == 1\n          let valid_interest_rate = interest_rate <= max_interest_rate\n          let valid_pool_collateral_amount =\n            collateral_amount >= min_collateral_amount\n          and {\n            valid_interest_rate?,\n            valid_pool_collateral_amount?,\n            borrower_token_minted?,\n            recipient_got_borrow_nft?,\n            user_received_value?,\n            collateral_output_match?,\n          }\n        }\n        _ -> False\n      }\n    }\n      |> order_wrapper(datum, redeemer, ctx)\n  }\n}\n\nvalidator {\n  fn repay_order_contract(\n    datum: order.Datum<order.RepayRequest>,\n    redeemer: order.Redeemer<Void>,\n    ctx: ScriptContext,\n  ) -> Bool {\n    fn(_: Void, pool_action: pool.Action) -> Bool {\n      when pool_action is {\n        pool.Continuing(pool.CloseLoan { .. }) -> {\n          let order.RepayRequest { expected_output, order, burn_asset } =\n            datum.order\n          let received_expected_output =\n            list.any(\n              ctx.transaction.outputs,\n              fn(out) { out == expected_output },\n            )\n          let consumed_order =\n            list.any(\n              ctx.transaction.inputs,\n              fn(input) { input.output_reference == order },\n            )\n          let burnt_enough =\n            quantity_of(\n              from_minted_value(ctx.transaction.mint),\n              burn_asset.policy_id,\n              burn_asset.asset_name,\n            ) == -1\n          and {\n            received_expected_output?,\n            consumed_order?,\n            burnt_enough?,\n          }\n        }\n        _ -> False\n      }\n    }\n      |> order_wrapper(datum, redeemer, ctx)\n  }\n}\n\n// this is unused, only used to access the type in blueprints\nvalidator {\n  fn outputRefType(_redeemer: OutputReference, _ctx: ScriptContext) -> Bool {\n    False\n  }\n}", "bug_explanation": "In the `borrow_order_contract` function, the `valid_loan_amount` check incorrectly uses `math.abs(additional_ada)` in a subtraction operation, which can lead to incorrect handling of negative values for `additional_ada`. This can cause the loan amount validation to fail or pass incorrectly when `additional_ada` is negative, potentially allowing invalid loan conditions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/order_contract.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, payment_asset, payment_asset__ada, payment_id,\n  payment_name, pos_user_pkh, pos_user_stake_key, position_script_hash,\n  pred_nft_id, pred_nft_name, prediction_nft_asset, share_policy_id,\n  true_position_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  payment_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.lovelace_of(\n                output.value,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let out_pos_lovelace = assets.lovelace_of(pos_output.value)\n        let required_lovelace =\n          pred_datum.admin_fee + pred_datum.envelope_amount + pos_datum.pos_batcher_fee\n        let amount =\n          when params.payment_asset.policy_id == assets.ada_policy_id is {\n            True -> ( out_pos_lovelace - required_lovelace ) / decimals\n            False ->\n              assets.quantity_of(\n                pos_output.value,\n                params.payment_asset.policy_id,\n                params.payment_asset.asset_name,\n              ) / decimals\n          }\n        expect amount > 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidetrue_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The bug is introduced by omitting the validation of the token name during the minting process. This allows for unrestricted token minting because the contract does not check if the token name being minted matches the expected true or false position names, potentially enabling unauthorized minting of tokens with arbitrary names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, payment_asset, payment_asset__ada, payment_id,\n  payment_name, pos_user_pkh, pos_user_stake_key, position_script_hash,\n  pred_nft_id, pred_nft_name, prediction_nft_asset, share_policy_id,\n  true_position_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  payment_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.lovelace_of(\n                output.value,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let out_pos_lovelace = assets.lovelace_of(pos_output.value)\n        let required_lovelace =\n          pred_datum.admin_fee + pred_datum.envelope_amount + pos_datum.pos_batcher_fee\n        let amount =\n          when params.payment_asset.policy_id == assets.ada_policy_id is {\n            True -> ( out_pos_lovelace - required_lovelace ) / decimals\n            False ->\n              assets.quantity_of(\n                pos_output.value,\n                params.payment_asset.policy_id,\n                params.payment_asset.asset_name,\n              ) / decimals\n          }\n        expect amount > 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidetrue_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "In the `Reward` case of the `mint` function, the check `assets.quantity_of(pred_input.output.value, params.prediction_nft.policy_id, params.prediction_nft.asset_name) == 1` uses equality (`==`) where inequality (`!=`) was intended. This means the function will incorrectly proceed if the quantity is not exactly 1, potentially allowing invalid transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, payment_asset, payment_asset__ada, payment_id,\n  payment_name, pos_user_pkh, pos_user_stake_key, position_script_hash,\n  pred_nft_id, pred_nft_name, prediction_nft_asset, share_policy_id,\n  true_position_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  payment_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.lovelace_of(\n                output.value,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let out_pos_lovelace = assets.lovelace_of(pos_output.value)\n        let required_lovelace =\n          pred_datum.admin_fee + pred_datum.envelope_amount + pos_datum.pos_batcher_fee\n        let amount =\n          when params.payment_asset.policy_id == assets.ada_policy_id is {\n            True -> ( out_pos_lovelace - required_lovelace ) / decimals\n            False ->\n              assets.quantity_of(\n                pos_output.value,\n                params.payment_asset.policy_id,\n                params.payment_asset.asset_name,\n              ) / decimals\n          }\n        expect amount > 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidetrue_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The code does not verify that the transaction includes the correct signer (pubkey) for authorization. This omission allows any transaction to be processed without ensuring that the correct party has signed it, potentially enabling unauthorized actions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, payment_asset, payment_asset__ada, payment_id,\n  payment_name, pos_user_pkh, pos_user_stake_key, position_script_hash,\n  pred_nft_id, pred_nft_name, prediction_nft_asset, share_policy_id,\n  true_position_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  payment_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.lovelace_of(\n                output.value,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let out_pos_lovelace = assets.lovelace_of(pos_output.value)\n        let required_lovelace =\n          pred_datum.admin_fee + pred_datum.envelope_amount + pos_datum.pos_batcher_fee\n        let amount =\n          when params.payment_asset.policy_id == assets.ada_policy_id is {\n            True -> ( out_pos_lovelace - required_lovelace ) / decimals\n            False ->\n              assets.quantity_of(\n                pos_output.value,\n                params.payment_asset.policy_id,\n                params.payment_asset.asset_name,\n              ) / decimals\n          }\n        expect amount > 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidetrue_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The bug is introduced by omitting the check for `extra_signatories` in the `Transaction` structure. This omission allows transactions to be processed without verifying that the required signatures are present, potentially enabling unauthorized access to the minting process.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing unauthorized access by omitting critical signature checks."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, payment_asset, payment_asset__ada, payment_id,\n  payment_name, pos_user_pkh, pos_user_stake_key, position_script_hash,\n  pred_nft_id, pred_nft_name, prediction_nft_asset, share_policy_id,\n  true_position_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  payment_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.lovelace_of(\n                output.value,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let out_pos_lovelace = assets.lovelace_of(pos_output.value)\n        let required_lovelace =\n          pred_datum.admin_fee + pred_datum.envelope_amount + pos_datum.pos_batcher_fee\n        let amount =\n          when params.payment_asset.policy_id == assets.ada_policy_id is {\n            True -> ( out_pos_lovelace - required_lovelace ) / decimals\n            False ->\n              assets.quantity_of(\n                pos_output.value,\n                params.payment_asset.policy_id,\n                params.payment_asset.asset_name,\n              ) / decimals\n          }\n        expect amount > 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidetrue_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The code does not check for the uniqueness of the transaction ID (`id`) in the `Transaction` structure. This omission allows an attacker to reuse a transaction with the same ID, leading to replay attacks where the same transaction can be executed multiple times.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, payment_asset, payment_asset__ada, payment_id,\n  payment_name, pos_user_pkh, pos_user_stake_key, position_script_hash,\n  pred_nft_id, pred_nft_name, prediction_nft_asset, share_policy_id,\n  true_position_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  payment_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.lovelace_of(\n                output.value,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let out_pos_lovelace = assets.lovelace_of(pos_output.value)\n        let required_lovelace =\n          pred_datum.admin_fee + pred_datum.envelope_amount + pos_datum.pos_batcher_fee\n        let amount =\n          when params.payment_asset.policy_id == assets.ada_policy_id is {\n            True -> ( out_pos_lovelace - required_lovelace ) / decimals\n            False ->\n              assets.quantity_of(\n                pos_output.value,\n                params.payment_asset.policy_id,\n                params.payment_asset.asset_name,\n              ) / decimals\n          }\n        expect amount > 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(payment_id, payment_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams { payment_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidetrue_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse_ada_payment() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      cur_total_fee: 0,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_user_stake_key: Some(pos_user_stake_key),\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.merge(assets.from_lovelace(2_500_000))\n        |> assets.merge(assets.from_lovelace(10 * decimals)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params =\n    ShareParams {\n      payment_asset: payment_asset__ada,\n      prediction_nft: prediction_nft_asset,\n    }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The bug is in the `Reward` case of the `mint` function. The code checks if the quantity of the prediction NFT in the input is 1, but it does not enforce that the datum associated with the input is of type `PredictionDatum`. This allows an input with a different datum type to pass the check, potentially leading to misuse of datums.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The bug allows unrestricted token minting by omitting token name validation. This means that the contract does not check if the token name is valid or authorized, potentially allowing anyone to mint tokens without proper validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "In the `validate_order` function, within the `CancelOrder` case, the check `out_payment_credential == owner_payment_credential` is used to verify if the payment credential of an input matches the owner's payment credential. This should have been an inequality check (`!=`) to ensure that the input does not belong to the owner, but it is incorrectly checking for equality, allowing unauthorized inputs to pass the validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The code does not check if `pool_input_index` is within the bounds of the `inputs` list. This can lead to a numeric overflow or underflow if `pool_input_index` is negative or greater than the number of inputs, potentially causing unexpected behavior or security vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The bug is in the `validate_order_spending_in_batching` function where the `pool_input_index` is used directly without checking if it is a valid index. If `pool_input_index` is negative or out of bounds, it could cause unexpected behavior or errors when accessing the list of inputs.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The bug is that the transaction deadline is not checked anywhere in the code. This means that transactions can be processed even if they are submitted after their intended deadline, potentially allowing orders to be applied or canceled outside of their valid time window.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a valid transaction multiple times, as there is no mechanism to ensure that each transaction is unique and cannot be replayed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\n/// The order validator is a basic order destined for execution against a pool\n///\n/// Other orders can be implemented as well, by using the same datum format, and\n/// updating the scoopers to know how to index and include these orders\n/// This would likely be done via a DAO vote.\n///\n/// The validator is parameterized by a specific stake script, more on that below.\n///\n/// Has two possible execution paths:\n/// - Cancel: the \"owner\" signs the transaction, allowing the UTXO be spent; we impose\n///   no additional constraints, so this could also be used to update an order by\n///   spending it back into the same script.\n///   Note: we use sundae.multisig, which allows multisig orders, or even orders that can\n///   be \"cancelled\" by a script!\n///\n/// - Scoop: the order is processed as a batch against a pool.\n///   Instead of re-checking the conditions in every single script, we instead use a clever trick\n///   We look for the stake_script_hash in the list of withdrawals!\n///   This means that the stake script must run, and it can always run, because withdrawals of 0 tokens are allowed!\n///   That stake_script then checks that a pool NFT is present on the UTXO, where most of the subtle and important logic is implemented.\nvalidator order(stake_script_hash: ScriptHash) {\n  // For the purposes of spending the order, we don't care what the datum is, so avoid deserializing it\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        // We only expect the datum here, to avoid any related costs in the other branch, which doesn't need it\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        // Defer to sundae.multisig\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              // TODO: we could make this more efficient by CBOR encoding the `Script` into the `stake_script_hash` parameter\n              // or perhaps even the whole withdrawal list to compare it all at once!\n              // and just doing a direct equaltiy comparison. Since this runs for each order, this could represent significant savings!\n              Script(script) -> acc || script == stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code omits validation of the token name when processing the `Scoop` redeemer, allowing any token to be minted without restriction as long as the stake script hash matches.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\n/// The order validator is a basic order destined for execution against a pool\n///\n/// Other orders can be implemented as well, by using the same datum format, and\n/// updating the scoopers to know how to index and include these orders\n/// This would likely be done via a DAO vote.\n///\n/// The validator is parameterized by a specific stake script, more on that below.\n///\n/// Has two possible execution paths:\n/// - Cancel: the \"owner\" signs the transaction, allowing the UTXO be spent; we impose\n///   no additional constraints, so this could also be used to update an order by\n///   spending it back into the same script.\n///   Note: we use sundae.multisig, which allows multisig orders, or even orders that can\n///   be \"cancelled\" by a script!\n///\n/// - Scoop: the order is processed as a batch against a pool.\n///   Instead of re-checking the conditions in every single script, we instead use a clever trick\n///   We look for the stake_script_hash in the list of withdrawals!\n///   This means that the stake script must run, and it can always run, because withdrawals of 0 tokens are allowed!\n///   That stake_script then checks that a pool NFT is present on the UTXO, where most of the subtle and important logic is implemented.\nvalidator order(stake_script_hash: ScriptHash) {\n  // For the purposes of spending the order, we don't care what the datum is, so avoid deserializing it\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        // We only expect the datum here, to avoid any related costs in the other branch, which doesn't need it\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        // Defer to sundae.multisig\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              // TODO: we could make this more efficient by CBOR encoding the `Script` into the `stake_script_hash` parameter\n              // or perhaps even the whole withdrawal list to compare it all at once!\n              // and just doing a direct equaltiy comparison. Since this runs for each order, this could represent significant savings!\n              Script(script) -> acc || script == stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is that the `Scoop` branch does not validate the number of inputs in the transaction. This could allow transactions with an incorrect number of inputs to be processed, potentially leading to unexpected behavior or security vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\n/// The order validator is a basic order destined for execution against a pool\n///\n/// Other orders can be implemented as well, by using the same datum format, and\n/// updating the scoopers to know how to index and include these orders\n/// This would likely be done via a DAO vote.\n///\n/// The validator is parameterized by a specific stake script, more on that below.\n///\n/// Has two possible execution paths:\n/// - Cancel: the \"owner\" signs the transaction, allowing the UTXO be spent; we impose\n///   no additional constraints, so this could also be used to update an order by\n///   spending it back into the same script.\n///   Note: we use sundae.multisig, which allows multisig orders, or even orders that can\n///   be \"cancelled\" by a script!\n///\n/// - Scoop: the order is processed as a batch against a pool.\n///   Instead of re-checking the conditions in every single script, we instead use a clever trick\n///   We look for the stake_script_hash in the list of withdrawals!\n///   This means that the stake script must run, and it can always run, because withdrawals of 0 tokens are allowed!\n///   That stake_script then checks that a pool NFT is present on the UTXO, where most of the subtle and important logic is implemented.\nvalidator order(stake_script_hash: ScriptHash) {\n  // For the purposes of spending the order, we don't care what the datum is, so avoid deserializing it\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        // We only expect the datum here, to avoid any related costs in the other branch, which doesn't need it\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        // Defer to sundae.multisig\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              // TODO: we could make this more efficient by CBOR encoding the `Script` into the `stake_script_hash` parameter\n              // or perhaps even the whole withdrawal list to compare it all at once!\n              // and just doing a direct equaltiy comparison. Since this runs for each order, this could represent significant savings!\n              Script(script) -> acc || script == stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a valid transaction multiple times, as there is no mechanism to ensure that each transaction is unique and cannot be replayed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\n/// The order validator is a basic order destined for execution against a pool\n///\n/// Other orders can be implemented as well, by using the same datum format, and\n/// updating the scoopers to know how to index and include these orders\n/// This would likely be done via a DAO vote.\n///\n/// The validator is parameterized by a specific stake script, more on that below.\n///\n/// Has two possible execution paths:\n/// - Cancel: the \"owner\" signs the transaction, allowing the UTXO be spent; we impose\n///   no additional constraints, so this could also be used to update an order by\n///   spending it back into the same script.\n///   Note: we use sundae.multisig, which allows multisig orders, or even orders that can\n///   be \"cancelled\" by a script!\n///\n/// - Scoop: the order is processed as a batch against a pool.\n///   Instead of re-checking the conditions in every single script, we instead use a clever trick\n///   We look for the stake_script_hash in the list of withdrawals!\n///   This means that the stake script must run, and it can always run, because withdrawals of 0 tokens are allowed!\n///   That stake_script then checks that a pool NFT is present on the UTXO, where most of the subtle and important logic is implemented.\nvalidator order(stake_script_hash: ScriptHash) {\n  // For the purposes of spending the order, we don't care what the datum is, so avoid deserializing it\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        // We only expect the datum here, to avoid any related costs in the other branch, which doesn't need it\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        // Defer to sundae.multisig\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              // TODO: we could make this more efficient by CBOR encoding the `Script` into the `stake_script_hash` parameter\n              // or perhaps even the whole withdrawal list to compare it all at once!\n              // and just doing a direct equaltiy comparison. Since this runs for each order, this could represent significant savings!\n              Script(script) -> acc || script == stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is in the `Scoop` branch where the `pairs.foldl` function is used to check if the `stake_script_hash` is present in the `transaction.withdrawals`. The comparison `script == stake_script_hash` should ensure that the script matches the expected hash. However, if the `script` variable is not correctly validated or if the comparison logic is flawed, it could allow unauthorized scripts to be considered valid, leading to misuse of datums.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aada/finance\nuse aada/nft.{CollateralNFTRedeemerLists, MintNFTElem}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aiken/dict\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, Publish, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/certificate.{CredentialDelegation}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{\n  PolicyId, flatten, from_asset, from_minted_value, merge, quantity_of, tokens,\n  without_lovelace,\n}\n\nvalidator(delegator_nft_policy: PolicyId, pool_config_script_hash: PolicyId) {\n  fn spend(datum: pool.Datum, redeemer: pool.Redeemer, ctx: ScriptContext) {\n    let pool.Datum { params, balance, lent_out, total_lp_tokens } = datum\n    let ScriptContext {\n      transaction: Transaction {\n        inputs,\n        mint,\n        redeemers,\n        reference_inputs,\n        outputs,\n        ..\n      },\n      purpose,\n    } = ctx\n    let mint = from_minted_value(mint)\n    expect Spend(output_ref) = purpose\n    expect Some(Input {\n      output: Output { address: this_address, value: pool_input_value, .. },\n      ..\n    }) =\n      list.find(inputs, fn(inp) -> Bool { inp.output_reference == output_ref })\n    expect ScriptCredential(this_script_hash) = this_address.payment_credential\n    let pool_nft_policy: PolicyId = this_script_hash\n\n    // Validates that pool receives right amount and correct datum is assigned\n    // Validate if pool token is in transaction\n    let pool.Redeemer { action, config_ref, .. } = redeemer\n    expect Some(config_input) =\n      list.find(\n        reference_inputs,\n        fn(inp) -> Bool { inp.output_reference == config_ref },\n      )\n    // Make sure pool config NFT is in the transaction\n    let config_has_nft =\n      quantity_of(\n        config_input.output.value,\n        pool_config_script_hash,\n        params.pool_config_assetname,\n      ) == 1\n\n    expect InlineDatum(raw_config_input_datum) = config_input.output.datum\n    expect pool.Config {\n      pool_fee,\n      min_transition,\n      min_loan,\n      min_fee,\n      interest_params,\n      ..\n    }: pool.Config = raw_config_input_datum\n\n    // Validated pool deposit/withdraw transition\n    let validate_transition =\n      fn(pool_output: pool.OutputIndex, f_delta: fn(Int, Int, Int) -> Bool) -> Bool {\n        expect Some(pool_output) = outputs |> list.at(pool_output)\n        expect InlineDatum(contract_datum) = pool_output.datum\n        expect pool.Datum {\n          params: output_params,\n          balance: output_balance,\n          lent_out: output_lent_out,\n          total_lp_tokens: output_total_lp_tokens,\n        }: pool.Datum = contract_datum\n        let output_is_positive = output_lent_out >= 0 && output_balance >= 0\n        let expected_change_value =\n          from_asset(\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n            output_balance - balance,\n          )\n        let expected_value_with_input =\n          merge(pool_input_value, expected_change_value)\n\n        let dust_attack_check =\n          without_lovelace(expected_value_with_input) == without_lovelace(\n            pool_output.value,\n          )\n\n        let valid_pool_output_address = pool_output.address == this_address\n\n        // Pool receives value it expects\n        let value_change_check =\n          quantity_of(\n            expected_value_with_input,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          ) == quantity_of(\n            pool_output.value,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          )\n        // Pol NFT is present in both input and output\n        let pool_input_nft_check =\n          quantity_of(pool_input_value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let pool_output_nft_check =\n          quantity_of(pool_output.value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let valid_pool_token_tx = pool_output_nft_check && pool_input_nft_check\n\n        let params_check = output_params == params\n        let f_delta_check =\n          f_delta(\n            output_balance - balance,\n            output_lent_out - lent_out,\n            output_total_lp_tokens - total_lp_tokens,\n          )\n        and {\n          valid_pool_token_tx?,\n          value_change_check?,\n          f_delta_check?,\n          params_check?,\n          output_is_positive?,\n          dust_attack_check?,\n          valid_pool_output_address?,\n        }\n      }\n    when action is {\n      pool.Destroy -> {\n        // Can only destroy if all LP tokens are burned\n        let lp_token_delta =\n          quantity_of(\n            mint,\n            params.lp_token.policy_id,\n            params.lp_token.asset_name,\n          )\n        let no_remaining_liquidity_tokens =\n          lp_token_delta + total_lp_tokens == 0\n\n        // Only one pool mint transaction when destroying\n        expect Some(mint_redeemer) =\n          redeemers\n            |> dict.get(Mint(pool_nft_policy))\n\n        expect mint_redeemer: pool.PoolNFTAction = mint_redeemer\n        expect pool.BurnPoolNFT(burn_tn) = mint_redeemer\n        let burned_token_name_match = burn_tn == params.pool_nft_name\n        let burnt_delegator_nft =\n          quantity_of(mint, delegator_nft_policy, params.pool_config_assetname) == -1\n        and {\n          no_remaining_liquidity_tokens?,\n          burnt_delegator_nft?,\n          config_has_nft?,\n          burned_token_name_match?,\n        }\n      }\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.LpAdjust { value_delta, continuing_output } -> {\n            let lp_token_delta =\n              quantity_of(\n                mint,\n                params.lp_token.policy_id,\n                params.lp_token.asset_name,\n              )\n\n            expect Some(owned_proportion) =\n              lp_token_delta * ( balance + lent_out )\n                |> rational.new(total_lp_tokens)\n\n            let sign_check = or {\n                // Withdraw scenario\n                and {\n                  value_delta < 0,\n                  lp_token_delta < 0,\n                  value_delta * -1 >= min_transition,\n                  lp_token_delta * -1 < total_lp_tokens,\n                },\n                // ensure not withdrawing more than existing supply\n                // Deposit scenario\n                and {\n                  value_delta > 0,\n                  lp_token_delta > 0,\n                  value_delta >= min_transition,\n                },\n              }\n\n            let notzero =\n              rational.compare(owned_proportion, rational.from_int(0)) != Equal\n\n            // When withdrawing owned_proportion means max you can withdraw.\n            // When depositing owned_proportion means min you can deposit.\n\n            let check_delta_amount =\n              if value_delta < 0 {\n                value_delta * -1 <= rational.truncate(owned_proportion) * -1\n              } else {\n                value_delta >= rational.truncate(owned_proportion)\n              }\n\n            let value_delta_check = and {\n                sign_check,\n                notzero,\n              }\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + value_delta,\n                  lent_delta == 0,\n                  tokens_delta == lp_token_delta,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n\n            and {\n              check_delta_amount?,\n              valid_transition?,\n              value_delta_check?,\n              config_has_nft?,\n            }\n          }\n          pool.Borrow { loan_amount, interest_rate, continuing_output, .. } -> {\n            let loan_is_positive = loan_amount > 0\n            let passes_min_threshold = loan_amount >= min_loan\n            let interest_rate_is_positive = interest_rate > 0\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) {\n                pool_fee - loan_amount == balance_delta && loan_amount == lent_delta && tokens_delta == 0\n              }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            let valid_interest_rates =\n              interest_rate >= finance.get_interest_rates(\n                interest_params,\n                loan_amount,\n                lent_out,\n                balance,\n              )\n\n            expect ScriptCredential(collateral_policy) =\n              params.collateral_address.payment_credential\n            expect Some(collateral_mint_redeemer) =\n              redeemers |> dict.get(Mint(collateral_policy))\n            expect collateral_mint_redeemer: CollateralNFTRedeemerLists =\n              collateral_mint_redeemer\n\n            let valid_collateral_exists =\n              collateral_mint_redeemer.mints\n                |> list.any(\n                     fn(el) {\n                       let MintNFTElem(pool_utxo, _) = el\n                       pool_utxo == output_ref\n                     },\n                   )\n            and {\n              loan_is_positive?,\n              interest_rate_is_positive?,\n              passes_min_threshold?,\n              valid_collateral_exists?,\n              valid_transition?,\n              valid_interest_rates?,\n              config_has_nft?,\n            }\n          }\n          pool.CloseLoan { loan_amount, repay_amount, continuing_output } -> {\n            let loan_amt_check = loan_amount > 0\n            let repay_amt_check = repay_amount > loan_amount\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + repay_amount,\n                  lent_delta == -loan_amount,\n                  tokens_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n          pool.PayFee { fee, continuing_output } -> {\n            let valid_minimum_amount = fee > min_fee\n            let transition_validator =\n              fn(balance_delta, lent_value_delta, tokens_mint_delta) { and {\n                  balance_delta == fee,\n                  lent_value_delta == 0,\n                  tokens_mint_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              valid_minimum_amount?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n        }\n    }\n  }\n\n  fn mint(redeemer: pool.PoolNFTAction, ctx: ScriptContext) -> Bool {\n    let ScriptContext {\n      transaction: Transaction { outputs, mint, redeemers, .. },\n      purpose,\n    } = ctx\n\n    expect Mint(own_script) = purpose\n    let pool_control_credential = ScriptCredential(own_script)\n    let mint = from_minted_value(mint)\n\n    when redeemer is {\n      pool.MintPoolNFT(pool_mint_details) -> {\n        let pool_mint_details: pool.PoolCreateDetails = pool_mint_details\n        let pool_output =\n          outputs\n            |> list.at(pool_mint_details.output_index)\n        expect Some(Output {\n          address: Address(out_credential, Some(out_stake_credential)),\n          value,\n          ..\n        }) = pool_output\n        expect Inline(stake_cred) = out_stake_credential\n        expect ScriptCredential(stake_hash) = stake_cred\n\n        expect Some(stake_validator_redeemer) =\n          dict.get(\n            redeemers,\n            Publish(\n              CredentialDelegation(\n                out_stake_credential,\n                pool_mint_details.initial_pool_delegation,\n              ),\n            ),\n          )\n        expect withdraw_validator_redeemer: pool_stake.StakeRedeemer =\n          stake_validator_redeemer\n\n        expect pool_stake.CreatePool(_withdraw_validator_oref) =\n          withdraw_validator_redeemer\n        let correct_credential = out_credential == pool_control_credential\n        // Pool NFT name is stake_hash\n        let correct_quantity_output =\n          quantity_of(value, own_script, stake_hash) == 1\n\n        expect [(_stake_hash, 1)] = tokens(mint, own_script) |> dict.to_list\n\n        let no_dust_attack =\n          when flatten(value) is {\n            [(_, _, _)] -> True\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        and {\n          correct_credential,\n          correct_quantity_output,\n          no_dust_attack,\n        }\n      }\n\n      // Pool NFT is locked in Pool Validator. You can't easily burn it.\n      // Should expect only one policy mint and it's -1\n      pool.BurnPoolNFT(burn_tn) -> {\n        expect [(burnt_nft_name, -1)] =\n          dict.to_list(value.tokens(mint, own_script))\n        burn_tn == burnt_nft_name\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the time range constraints (`valid_from`, `valid_to`) are not checked anywhere in the contract, allowing transactions to be executed at any time, even outside the intended valid time range. This can lead to unauthorized or unintended actions being performed on the contract.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool.ak", "language": "ak", "bug_prompt": "Introduce a bug that misuses the time range constraints (`valid_from`, `valid_to`), allowing invalid execution timing."}
{"contract": "use aada/finance\nuse aada/nft.{CollateralNFTRedeemerLists, MintNFTElem}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aiken/dict\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, Publish, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/certificate.{CredentialDelegation}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{\n  PolicyId, flatten, from_asset, from_minted_value, merge, quantity_of, tokens,\n  without_lovelace,\n}\n\nvalidator(delegator_nft_policy: PolicyId, pool_config_script_hash: PolicyId) {\n  fn spend(datum: pool.Datum, redeemer: pool.Redeemer, ctx: ScriptContext) {\n    let pool.Datum { params, balance, lent_out, total_lp_tokens } = datum\n    let ScriptContext {\n      transaction: Transaction {\n        inputs,\n        mint,\n        redeemers,\n        reference_inputs,\n        outputs,\n        ..\n      },\n      purpose,\n    } = ctx\n    let mint = from_minted_value(mint)\n    expect Spend(output_ref) = purpose\n    expect Some(Input {\n      output: Output { address: this_address, value: pool_input_value, .. },\n      ..\n    }) =\n      list.find(inputs, fn(inp) -> Bool { inp.output_reference == output_ref })\n    expect ScriptCredential(this_script_hash) = this_address.payment_credential\n    let pool_nft_policy: PolicyId = this_script_hash\n\n    // Validates that pool receives right amount and correct datum is assigned\n    // Validate if pool token is in transaction\n    let pool.Redeemer { action, config_ref, .. } = redeemer\n    expect Some(config_input) =\n      list.find(\n        reference_inputs,\n        fn(inp) -> Bool { inp.output_reference == config_ref },\n      )\n    // Make sure pool config NFT is in the transaction\n    let config_has_nft =\n      quantity_of(\n        config_input.output.value,\n        pool_config_script_hash,\n        params.pool_config_assetname,\n      ) == 1\n\n    expect InlineDatum(raw_config_input_datum) = config_input.output.datum\n    expect pool.Config {\n      pool_fee,\n      min_transition,\n      min_loan,\n      min_fee,\n      interest_params,\n      ..\n    }: pool.Config = raw_config_input_datum\n\n    // Validated pool deposit/withdraw transition\n    let validate_transition =\n      fn(pool_output: pool.OutputIndex, f_delta: fn(Int, Int, Int) -> Bool) -> Bool {\n        expect Some(pool_output) = outputs |> list.at(pool_output)\n        expect InlineDatum(contract_datum) = pool_output.datum\n        expect pool.Datum {\n          params: output_params,\n          balance: output_balance,\n          lent_out: output_lent_out,\n          total_lp_tokens: output_total_lp_tokens,\n        }: pool.Datum = contract_datum\n        let output_is_positive = output_lent_out >= 0 && output_balance >= 0\n        let expected_change_value =\n          from_asset(\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n            output_balance - balance,\n          )\n        let expected_value_with_input =\n          merge(pool_input_value, expected_change_value)\n\n        let dust_attack_check =\n          without_lovelace(expected_value_with_input) == without_lovelace(\n            pool_output.value,\n          )\n\n        let valid_pool_output_address = pool_output.address == this_address\n\n        // Pool receives value it expects\n        let value_change_check =\n          quantity_of(\n            expected_value_with_input,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          ) == quantity_of(\n            pool_output.value,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          )\n        // Pol NFT is present in both input and output\n        let pool_input_nft_check =\n          quantity_of(pool_input_value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let pool_output_nft_check =\n          quantity_of(pool_output.value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let valid_pool_token_tx = pool_output_nft_check && pool_input_nft_check\n\n        let params_check = output_params == params\n        let f_delta_check =\n          f_delta(\n            output_balance - balance,\n            output_lent_out - lent_out,\n            output_total_lp_tokens - total_lp_tokens,\n          )\n        and {\n          valid_pool_token_tx?,\n          value_change_check?,\n          f_delta_check?,\n          params_check?,\n          output_is_positive?,\n          dust_attack_check?,\n          valid_pool_output_address?,\n        }\n      }\n    when action is {\n      pool.Destroy -> {\n        // Can only destroy if all LP tokens are burned\n        let lp_token_delta =\n          quantity_of(\n            mint,\n            params.lp_token.policy_id,\n            params.lp_token.asset_name,\n          )\n        let no_remaining_liquidity_tokens =\n          lp_token_delta + total_lp_tokens == 0\n\n        // Only one pool mint transaction when destroying\n        expect Some(mint_redeemer) =\n          redeemers\n            |> dict.get(Mint(pool_nft_policy))\n\n        expect mint_redeemer: pool.PoolNFTAction = mint_redeemer\n        expect pool.BurnPoolNFT(burn_tn) = mint_redeemer\n        let burned_token_name_match = burn_tn == params.pool_nft_name\n        let burnt_delegator_nft =\n          quantity_of(mint, delegator_nft_policy, params.pool_config_assetname) == -1\n        and {\n          no_remaining_liquidity_tokens?,\n          burnt_delegator_nft?,\n          config_has_nft?,\n          burned_token_name_match?,\n        }\n      }\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.LpAdjust { value_delta, continuing_output } -> {\n            let lp_token_delta =\n              quantity_of(\n                mint,\n                params.lp_token.policy_id,\n                params.lp_token.asset_name,\n              )\n\n            expect Some(owned_proportion) =\n              lp_token_delta * ( balance + lent_out )\n                |> rational.new(total_lp_tokens)\n\n            let sign_check = or {\n                // Withdraw scenario\n                and {\n                  value_delta < 0,\n                  lp_token_delta < 0,\n                  value_delta * -1 >= min_transition,\n                  lp_token_delta * -1 < total_lp_tokens,\n                },\n                // ensure not withdrawing more than existing supply\n                // Deposit scenario\n                and {\n                  value_delta > 0,\n                  lp_token_delta > 0,\n                  value_delta >= min_transition,\n                },\n              }\n\n            let notzero =\n              rational.compare(owned_proportion, rational.from_int(0)) != Equal\n\n            // When withdrawing owned_proportion means max you can withdraw.\n            // When depositing owned_proportion means min you can deposit.\n\n            let check_delta_amount =\n              if value_delta < 0 {\n                value_delta * -1 <= rational.truncate(owned_proportion) * -1\n              } else {\n                value_delta >= rational.truncate(owned_proportion)\n              }\n\n            let value_delta_check = and {\n                sign_check,\n                notzero,\n              }\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + value_delta,\n                  lent_delta == 0,\n                  tokens_delta == lp_token_delta,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n\n            and {\n              check_delta_amount?,\n              valid_transition?,\n              value_delta_check?,\n              config_has_nft?,\n            }\n          }\n          pool.Borrow { loan_amount, interest_rate, continuing_output, .. } -> {\n            let loan_is_positive = loan_amount > 0\n            let passes_min_threshold = loan_amount >= min_loan\n            let interest_rate_is_positive = interest_rate > 0\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) {\n                pool_fee - loan_amount == balance_delta && loan_amount == lent_delta && tokens_delta == 0\n              }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            let valid_interest_rates =\n              interest_rate >= finance.get_interest_rates(\n                interest_params,\n                loan_amount,\n                lent_out,\n                balance,\n              )\n\n            expect ScriptCredential(collateral_policy) =\n              params.collateral_address.payment_credential\n            expect Some(collateral_mint_redeemer) =\n              redeemers |> dict.get(Mint(collateral_policy))\n            expect collateral_mint_redeemer: CollateralNFTRedeemerLists =\n              collateral_mint_redeemer\n\n            let valid_collateral_exists =\n              collateral_mint_redeemer.mints\n                |> list.any(\n                     fn(el) {\n                       let MintNFTElem(pool_utxo, _) = el\n                       pool_utxo == output_ref\n                     },\n                   )\n            and {\n              loan_is_positive?,\n              interest_rate_is_positive?,\n              passes_min_threshold?,\n              valid_collateral_exists?,\n              valid_transition?,\n              valid_interest_rates?,\n              config_has_nft?,\n            }\n          }\n          pool.CloseLoan { loan_amount, repay_amount, continuing_output } -> {\n            let loan_amt_check = loan_amount > 0\n            let repay_amt_check = repay_amount > loan_amount\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + repay_amount,\n                  lent_delta == -loan_amount,\n                  tokens_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n          pool.PayFee { fee, continuing_output } -> {\n            let valid_minimum_amount = fee > min_fee\n            let transition_validator =\n              fn(balance_delta, lent_value_delta, tokens_mint_delta) { and {\n                  balance_delta == fee,\n                  lent_value_delta == 0,\n                  tokens_mint_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              valid_minimum_amount?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n        }\n    }\n  }\n\n  fn mint(redeemer: pool.PoolNFTAction, ctx: ScriptContext) -> Bool {\n    let ScriptContext {\n      transaction: Transaction { outputs, mint, redeemers, .. },\n      purpose,\n    } = ctx\n\n    expect Mint(own_script) = purpose\n    let pool_control_credential = ScriptCredential(own_script)\n    let mint = from_minted_value(mint)\n\n    when redeemer is {\n      pool.MintPoolNFT(pool_mint_details) -> {\n        let pool_mint_details: pool.PoolCreateDetails = pool_mint_details\n        let pool_output =\n          outputs\n            |> list.at(pool_mint_details.output_index)\n        expect Some(Output {\n          address: Address(out_credential, Some(out_stake_credential)),\n          value,\n          ..\n        }) = pool_output\n        expect Inline(stake_cred) = out_stake_credential\n        expect ScriptCredential(stake_hash) = stake_cred\n\n        expect Some(stake_validator_redeemer) =\n          dict.get(\n            redeemers,\n            Publish(\n              CredentialDelegation(\n                out_stake_credential,\n                pool_mint_details.initial_pool_delegation,\n              ),\n            ),\n          )\n        expect withdraw_validator_redeemer: pool_stake.StakeRedeemer =\n          stake_validator_redeemer\n\n        expect pool_stake.CreatePool(_withdraw_validator_oref) =\n          withdraw_validator_redeemer\n        let correct_credential = out_credential == pool_control_credential\n        // Pool NFT name is stake_hash\n        let correct_quantity_output =\n          quantity_of(value, own_script, stake_hash) == 1\n\n        expect [(_stake_hash, 1)] = tokens(mint, own_script) |> dict.to_list\n\n        let no_dust_attack =\n          when flatten(value) is {\n            [(_, _, _)] -> True\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        and {\n          correct_credential,\n          correct_quantity_output,\n          no_dust_attack,\n        }\n      }\n\n      // Pool NFT is locked in Pool Validator. You can't easily burn it.\n      // Should expect only one policy mint and it's -1\n      pool.BurnPoolNFT(burn_tn) -> {\n        expect [(burnt_nft_name, -1)] =\n          dict.to_list(value.tokens(mint, own_script))\n        burn_tn == burnt_nft_name\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `validate_transition` function where the `f_delta` function is called. The `f_delta` function is used to check the changes in balance, lent_out, and total_lp_tokens. However, there is no check to ensure that the subtraction operations (e.g., `output_balance - balance`) do not result in an overflow or underflow. This can lead to incorrect calculations if the values are manipulated to cause an overflow or underflow, potentially allowing an attacker to exploit this to their advantage.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aada/finance\nuse aada/nft.{CollateralNFTRedeemerLists, MintNFTElem}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aiken/dict\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, Publish, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/certificate.{CredentialDelegation}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{\n  PolicyId, flatten, from_asset, from_minted_value, merge, quantity_of, tokens,\n  without_lovelace,\n}\n\nvalidator(delegator_nft_policy: PolicyId, pool_config_script_hash: PolicyId) {\n  fn spend(datum: pool.Datum, redeemer: pool.Redeemer, ctx: ScriptContext) {\n    let pool.Datum { params, balance, lent_out, total_lp_tokens } = datum\n    let ScriptContext {\n      transaction: Transaction {\n        inputs,\n        mint,\n        redeemers,\n        reference_inputs,\n        outputs,\n        ..\n      },\n      purpose,\n    } = ctx\n    let mint = from_minted_value(mint)\n    expect Spend(output_ref) = purpose\n    expect Some(Input {\n      output: Output { address: this_address, value: pool_input_value, .. },\n      ..\n    }) =\n      list.find(inputs, fn(inp) -> Bool { inp.output_reference == output_ref })\n    expect ScriptCredential(this_script_hash) = this_address.payment_credential\n    let pool_nft_policy: PolicyId = this_script_hash\n\n    // Validates that pool receives right amount and correct datum is assigned\n    // Validate if pool token is in transaction\n    let pool.Redeemer { action, config_ref, .. } = redeemer\n    expect Some(config_input) =\n      list.find(\n        reference_inputs,\n        fn(inp) -> Bool { inp.output_reference == config_ref },\n      )\n    // Make sure pool config NFT is in the transaction\n    let config_has_nft =\n      quantity_of(\n        config_input.output.value,\n        pool_config_script_hash,\n        params.pool_config_assetname,\n      ) == 1\n\n    expect InlineDatum(raw_config_input_datum) = config_input.output.datum\n    expect pool.Config {\n      pool_fee,\n      min_transition,\n      min_loan,\n      min_fee,\n      interest_params,\n      ..\n    }: pool.Config = raw_config_input_datum\n\n    // Validated pool deposit/withdraw transition\n    let validate_transition =\n      fn(pool_output: pool.OutputIndex, f_delta: fn(Int, Int, Int) -> Bool) -> Bool {\n        expect Some(pool_output) = outputs |> list.at(pool_output)\n        expect InlineDatum(contract_datum) = pool_output.datum\n        expect pool.Datum {\n          params: output_params,\n          balance: output_balance,\n          lent_out: output_lent_out,\n          total_lp_tokens: output_total_lp_tokens,\n        }: pool.Datum = contract_datum\n        let output_is_positive = output_lent_out >= 0 && output_balance >= 0\n        let expected_change_value =\n          from_asset(\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n            output_balance - balance,\n          )\n        let expected_value_with_input =\n          merge(pool_input_value, expected_change_value)\n\n        let dust_attack_check =\n          without_lovelace(expected_value_with_input) == without_lovelace(\n            pool_output.value,\n          )\n\n        let valid_pool_output_address = pool_output.address == this_address\n\n        // Pool receives value it expects\n        let value_change_check =\n          quantity_of(\n            expected_value_with_input,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          ) == quantity_of(\n            pool_output.value,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          )\n        // Pol NFT is present in both input and output\n        let pool_input_nft_check =\n          quantity_of(pool_input_value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let pool_output_nft_check =\n          quantity_of(pool_output.value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let valid_pool_token_tx = pool_output_nft_check && pool_input_nft_check\n\n        let params_check = output_params == params\n        let f_delta_check =\n          f_delta(\n            output_balance - balance,\n            output_lent_out - lent_out,\n            output_total_lp_tokens - total_lp_tokens,\n          )\n        and {\n          valid_pool_token_tx?,\n          value_change_check?,\n          f_delta_check?,\n          params_check?,\n          output_is_positive?,\n          dust_attack_check?,\n          valid_pool_output_address?,\n        }\n      }\n    when action is {\n      pool.Destroy -> {\n        // Can only destroy if all LP tokens are burned\n        let lp_token_delta =\n          quantity_of(\n            mint,\n            params.lp_token.policy_id,\n            params.lp_token.asset_name,\n          )\n        let no_remaining_liquidity_tokens =\n          lp_token_delta + total_lp_tokens == 0\n\n        // Only one pool mint transaction when destroying\n        expect Some(mint_redeemer) =\n          redeemers\n            |> dict.get(Mint(pool_nft_policy))\n\n        expect mint_redeemer: pool.PoolNFTAction = mint_redeemer\n        expect pool.BurnPoolNFT(burn_tn) = mint_redeemer\n        let burned_token_name_match = burn_tn == params.pool_nft_name\n        let burnt_delegator_nft =\n          quantity_of(mint, delegator_nft_policy, params.pool_config_assetname) == -1\n        and {\n          no_remaining_liquidity_tokens?,\n          burnt_delegator_nft?,\n          config_has_nft?,\n          burned_token_name_match?,\n        }\n      }\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.LpAdjust { value_delta, continuing_output } -> {\n            let lp_token_delta =\n              quantity_of(\n                mint,\n                params.lp_token.policy_id,\n                params.lp_token.asset_name,\n              )\n\n            expect Some(owned_proportion) =\n              lp_token_delta * ( balance + lent_out )\n                |> rational.new(total_lp_tokens)\n\n            let sign_check = or {\n                // Withdraw scenario\n                and {\n                  value_delta < 0,\n                  lp_token_delta < 0,\n                  value_delta * -1 >= min_transition,\n                  lp_token_delta * -1 < total_lp_tokens,\n                },\n                // ensure not withdrawing more than existing supply\n                // Deposit scenario\n                and {\n                  value_delta > 0,\n                  lp_token_delta > 0,\n                  value_delta >= min_transition,\n                },\n              }\n\n            let notzero =\n              rational.compare(owned_proportion, rational.from_int(0)) != Equal\n\n            // When withdrawing owned_proportion means max you can withdraw.\n            // When depositing owned_proportion means min you can deposit.\n\n            let check_delta_amount =\n              if value_delta < 0 {\n                value_delta * -1 <= rational.truncate(owned_proportion) * -1\n              } else {\n                value_delta >= rational.truncate(owned_proportion)\n              }\n\n            let value_delta_check = and {\n                sign_check,\n                notzero,\n              }\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + value_delta,\n                  lent_delta == 0,\n                  tokens_delta == lp_token_delta,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n\n            and {\n              check_delta_amount?,\n              valid_transition?,\n              value_delta_check?,\n              config_has_nft?,\n            }\n          }\n          pool.Borrow { loan_amount, interest_rate, continuing_output, .. } -> {\n            let loan_is_positive = loan_amount > 0\n            let passes_min_threshold = loan_amount >= min_loan\n            let interest_rate_is_positive = interest_rate > 0\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) {\n                pool_fee - loan_amount == balance_delta && loan_amount == lent_delta && tokens_delta == 0\n              }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            let valid_interest_rates =\n              interest_rate >= finance.get_interest_rates(\n                interest_params,\n                loan_amount,\n                lent_out,\n                balance,\n              )\n\n            expect ScriptCredential(collateral_policy) =\n              params.collateral_address.payment_credential\n            expect Some(collateral_mint_redeemer) =\n              redeemers |> dict.get(Mint(collateral_policy))\n            expect collateral_mint_redeemer: CollateralNFTRedeemerLists =\n              collateral_mint_redeemer\n\n            let valid_collateral_exists =\n              collateral_mint_redeemer.mints\n                |> list.any(\n                     fn(el) {\n                       let MintNFTElem(pool_utxo, _) = el\n                       pool_utxo == output_ref\n                     },\n                   )\n            and {\n              loan_is_positive?,\n              interest_rate_is_positive?,\n              passes_min_threshold?,\n              valid_collateral_exists?,\n              valid_transition?,\n              valid_interest_rates?,\n              config_has_nft?,\n            }\n          }\n          pool.CloseLoan { loan_amount, repay_amount, continuing_output } -> {\n            let loan_amt_check = loan_amount > 0\n            let repay_amt_check = repay_amount > loan_amount\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + repay_amount,\n                  lent_delta == -loan_amount,\n                  tokens_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n          pool.PayFee { fee, continuing_output } -> {\n            let valid_minimum_amount = fee > min_fee\n            let transition_validator =\n              fn(balance_delta, lent_value_delta, tokens_mint_delta) { and {\n                  balance_delta == fee,\n                  lent_value_delta == 0,\n                  tokens_mint_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              valid_minimum_amount?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n        }\n    }\n  }\n\n  fn mint(redeemer: pool.PoolNFTAction, ctx: ScriptContext) -> Bool {\n    let ScriptContext {\n      transaction: Transaction { outputs, mint, redeemers, .. },\n      purpose,\n    } = ctx\n\n    expect Mint(own_script) = purpose\n    let pool_control_credential = ScriptCredential(own_script)\n    let mint = from_minted_value(mint)\n\n    when redeemer is {\n      pool.MintPoolNFT(pool_mint_details) -> {\n        let pool_mint_details: pool.PoolCreateDetails = pool_mint_details\n        let pool_output =\n          outputs\n            |> list.at(pool_mint_details.output_index)\n        expect Some(Output {\n          address: Address(out_credential, Some(out_stake_credential)),\n          value,\n          ..\n        }) = pool_output\n        expect Inline(stake_cred) = out_stake_credential\n        expect ScriptCredential(stake_hash) = stake_cred\n\n        expect Some(stake_validator_redeemer) =\n          dict.get(\n            redeemers,\n            Publish(\n              CredentialDelegation(\n                out_stake_credential,\n                pool_mint_details.initial_pool_delegation,\n              ),\n            ),\n          )\n        expect withdraw_validator_redeemer: pool_stake.StakeRedeemer =\n          stake_validator_redeemer\n\n        expect pool_stake.CreatePool(_withdraw_validator_oref) =\n          withdraw_validator_redeemer\n        let correct_credential = out_credential == pool_control_credential\n        // Pool NFT name is stake_hash\n        let correct_quantity_output =\n          quantity_of(value, own_script, stake_hash) == 1\n\n        expect [(_stake_hash, 1)] = tokens(mint, own_script) |> dict.to_list\n\n        let no_dust_attack =\n          when flatten(value) is {\n            [(_, _, _)] -> True\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        and {\n          correct_credential,\n          correct_quantity_output,\n          no_dust_attack,\n        }\n      }\n\n      // Pool NFT is locked in Pool Validator. You can't easily burn it.\n      // Should expect only one policy mint and it's -1\n      pool.BurnPoolNFT(burn_tn) -> {\n        expect [(burnt_nft_name, -1)] =\n          dict.to_list(value.tokens(mint, own_script))\n        burn_tn == burnt_nft_name\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `check_delta_amount` function within the `pool.LpAdjust` action. The condition `value_delta * -1 <= rational.truncate(owned_proportion) * -1` is incorrect because it incorrectly handles negative values. The multiplication by `-1` on both sides of the inequality should not be there, as it can lead to incorrect validation when `value_delta` is negative, allowing more withdrawal than intended.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aada/finance\nuse aada/nft.{CollateralNFTRedeemerLists, MintNFTElem}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aiken/dict\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, Publish, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/certificate.{CredentialDelegation}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{\n  PolicyId, flatten, from_asset, from_minted_value, merge, quantity_of, tokens,\n  without_lovelace,\n}\n\nvalidator(delegator_nft_policy: PolicyId, pool_config_script_hash: PolicyId) {\n  fn spend(datum: pool.Datum, redeemer: pool.Redeemer, ctx: ScriptContext) {\n    let pool.Datum { params, balance, lent_out, total_lp_tokens } = datum\n    let ScriptContext {\n      transaction: Transaction {\n        inputs,\n        mint,\n        redeemers,\n        reference_inputs,\n        outputs,\n        ..\n      },\n      purpose,\n    } = ctx\n    let mint = from_minted_value(mint)\n    expect Spend(output_ref) = purpose\n    expect Some(Input {\n      output: Output { address: this_address, value: pool_input_value, .. },\n      ..\n    }) =\n      list.find(inputs, fn(inp) -> Bool { inp.output_reference == output_ref })\n    expect ScriptCredential(this_script_hash) = this_address.payment_credential\n    let pool_nft_policy: PolicyId = this_script_hash\n\n    // Validates that pool receives right amount and correct datum is assigned\n    // Validate if pool token is in transaction\n    let pool.Redeemer { action, config_ref, .. } = redeemer\n    expect Some(config_input) =\n      list.find(\n        reference_inputs,\n        fn(inp) -> Bool { inp.output_reference == config_ref },\n      )\n    // Make sure pool config NFT is in the transaction\n    let config_has_nft =\n      quantity_of(\n        config_input.output.value,\n        pool_config_script_hash,\n        params.pool_config_assetname,\n      ) == 1\n\n    expect InlineDatum(raw_config_input_datum) = config_input.output.datum\n    expect pool.Config {\n      pool_fee,\n      min_transition,\n      min_loan,\n      min_fee,\n      interest_params,\n      ..\n    }: pool.Config = raw_config_input_datum\n\n    // Validated pool deposit/withdraw transition\n    let validate_transition =\n      fn(pool_output: pool.OutputIndex, f_delta: fn(Int, Int, Int) -> Bool) -> Bool {\n        expect Some(pool_output) = outputs |> list.at(pool_output)\n        expect InlineDatum(contract_datum) = pool_output.datum\n        expect pool.Datum {\n          params: output_params,\n          balance: output_balance,\n          lent_out: output_lent_out,\n          total_lp_tokens: output_total_lp_tokens,\n        }: pool.Datum = contract_datum\n        let output_is_positive = output_lent_out >= 0 && output_balance >= 0\n        let expected_change_value =\n          from_asset(\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n            output_balance - balance,\n          )\n        let expected_value_with_input =\n          merge(pool_input_value, expected_change_value)\n\n        let dust_attack_check =\n          without_lovelace(expected_value_with_input) == without_lovelace(\n            pool_output.value,\n          )\n\n        let valid_pool_output_address = pool_output.address == this_address\n\n        // Pool receives value it expects\n        let value_change_check =\n          quantity_of(\n            expected_value_with_input,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          ) == quantity_of(\n            pool_output.value,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          )\n        // Pol NFT is present in both input and output\n        let pool_input_nft_check =\n          quantity_of(pool_input_value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let pool_output_nft_check =\n          quantity_of(pool_output.value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let valid_pool_token_tx = pool_output_nft_check && pool_input_nft_check\n\n        let params_check = output_params == params\n        let f_delta_check =\n          f_delta(\n            output_balance - balance,\n            output_lent_out - lent_out,\n            output_total_lp_tokens - total_lp_tokens,\n          )\n        and {\n          valid_pool_token_tx?,\n          value_change_check?,\n          f_delta_check?,\n          params_check?,\n          output_is_positive?,\n          dust_attack_check?,\n          valid_pool_output_address?,\n        }\n      }\n    when action is {\n      pool.Destroy -> {\n        // Can only destroy if all LP tokens are burned\n        let lp_token_delta =\n          quantity_of(\n            mint,\n            params.lp_token.policy_id,\n            params.lp_token.asset_name,\n          )\n        let no_remaining_liquidity_tokens =\n          lp_token_delta + total_lp_tokens == 0\n\n        // Only one pool mint transaction when destroying\n        expect Some(mint_redeemer) =\n          redeemers\n            |> dict.get(Mint(pool_nft_policy))\n\n        expect mint_redeemer: pool.PoolNFTAction = mint_redeemer\n        expect pool.BurnPoolNFT(burn_tn) = mint_redeemer\n        let burned_token_name_match = burn_tn == params.pool_nft_name\n        let burnt_delegator_nft =\n          quantity_of(mint, delegator_nft_policy, params.pool_config_assetname) == -1\n        and {\n          no_remaining_liquidity_tokens?,\n          burnt_delegator_nft?,\n          config_has_nft?,\n          burned_token_name_match?,\n        }\n      }\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.LpAdjust { value_delta, continuing_output } -> {\n            let lp_token_delta =\n              quantity_of(\n                mint,\n                params.lp_token.policy_id,\n                params.lp_token.asset_name,\n              )\n\n            expect Some(owned_proportion) =\n              lp_token_delta * ( balance + lent_out )\n                |> rational.new(total_lp_tokens)\n\n            let sign_check = or {\n                // Withdraw scenario\n                and {\n                  value_delta < 0,\n                  lp_token_delta < 0,\n                  value_delta * -1 >= min_transition,\n                  lp_token_delta * -1 < total_lp_tokens,\n                },\n                // ensure not withdrawing more than existing supply\n                // Deposit scenario\n                and {\n                  value_delta > 0,\n                  lp_token_delta > 0,\n                  value_delta >= min_transition,\n                },\n              }\n\n            let notzero =\n              rational.compare(owned_proportion, rational.from_int(0)) != Equal\n\n            // When withdrawing owned_proportion means max you can withdraw.\n            // When depositing owned_proportion means min you can deposit.\n\n            let check_delta_amount =\n              if value_delta < 0 {\n                value_delta * -1 <= rational.truncate(owned_proportion) * -1\n              } else {\n                value_delta >= rational.truncate(owned_proportion)\n              }\n\n            let value_delta_check = and {\n                sign_check,\n                notzero,\n              }\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + value_delta,\n                  lent_delta == 0,\n                  tokens_delta == lp_token_delta,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n\n            and {\n              check_delta_amount?,\n              valid_transition?,\n              value_delta_check?,\n              config_has_nft?,\n            }\n          }\n          pool.Borrow { loan_amount, interest_rate, continuing_output, .. } -> {\n            let loan_is_positive = loan_amount > 0\n            let passes_min_threshold = loan_amount >= min_loan\n            let interest_rate_is_positive = interest_rate > 0\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) {\n                pool_fee - loan_amount == balance_delta && loan_amount == lent_delta && tokens_delta == 0\n              }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            let valid_interest_rates =\n              interest_rate >= finance.get_interest_rates(\n                interest_params,\n                loan_amount,\n                lent_out,\n                balance,\n              )\n\n            expect ScriptCredential(collateral_policy) =\n              params.collateral_address.payment_credential\n            expect Some(collateral_mint_redeemer) =\n              redeemers |> dict.get(Mint(collateral_policy))\n            expect collateral_mint_redeemer: CollateralNFTRedeemerLists =\n              collateral_mint_redeemer\n\n            let valid_collateral_exists =\n              collateral_mint_redeemer.mints\n                |> list.any(\n                     fn(el) {\n                       let MintNFTElem(pool_utxo, _) = el\n                       pool_utxo == output_ref\n                     },\n                   )\n            and {\n              loan_is_positive?,\n              interest_rate_is_positive?,\n              passes_min_threshold?,\n              valid_collateral_exists?,\n              valid_transition?,\n              valid_interest_rates?,\n              config_has_nft?,\n            }\n          }\n          pool.CloseLoan { loan_amount, repay_amount, continuing_output } -> {\n            let loan_amt_check = loan_amount > 0\n            let repay_amt_check = repay_amount > loan_amount\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + repay_amount,\n                  lent_delta == -loan_amount,\n                  tokens_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n          pool.PayFee { fee, continuing_output } -> {\n            let valid_minimum_amount = fee > min_fee\n            let transition_validator =\n              fn(balance_delta, lent_value_delta, tokens_mint_delta) { and {\n                  balance_delta == fee,\n                  lent_value_delta == 0,\n                  tokens_mint_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              valid_minimum_amount?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n        }\n    }\n  }\n\n  fn mint(redeemer: pool.PoolNFTAction, ctx: ScriptContext) -> Bool {\n    let ScriptContext {\n      transaction: Transaction { outputs, mint, redeemers, .. },\n      purpose,\n    } = ctx\n\n    expect Mint(own_script) = purpose\n    let pool_control_credential = ScriptCredential(own_script)\n    let mint = from_minted_value(mint)\n\n    when redeemer is {\n      pool.MintPoolNFT(pool_mint_details) -> {\n        let pool_mint_details: pool.PoolCreateDetails = pool_mint_details\n        let pool_output =\n          outputs\n            |> list.at(pool_mint_details.output_index)\n        expect Some(Output {\n          address: Address(out_credential, Some(out_stake_credential)),\n          value,\n          ..\n        }) = pool_output\n        expect Inline(stake_cred) = out_stake_credential\n        expect ScriptCredential(stake_hash) = stake_cred\n\n        expect Some(stake_validator_redeemer) =\n          dict.get(\n            redeemers,\n            Publish(\n              CredentialDelegation(\n                out_stake_credential,\n                pool_mint_details.initial_pool_delegation,\n              ),\n            ),\n          )\n        expect withdraw_validator_redeemer: pool_stake.StakeRedeemer =\n          stake_validator_redeemer\n\n        expect pool_stake.CreatePool(_withdraw_validator_oref) =\n          withdraw_validator_redeemer\n        let correct_credential = out_credential == pool_control_credential\n        // Pool NFT name is stake_hash\n        let correct_quantity_output =\n          quantity_of(value, own_script, stake_hash) == 1\n\n        expect [(_stake_hash, 1)] = tokens(mint, own_script) |> dict.to_list\n\n        let no_dust_attack =\n          when flatten(value) is {\n            [(_, _, _)] -> True\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        and {\n          correct_credential,\n          correct_quantity_output,\n          no_dust_attack,\n        }\n      }\n\n      // Pool NFT is locked in Pool Validator. You can't easily burn it.\n      // Should expect only one policy mint and it's -1\n      pool.BurnPoolNFT(burn_tn) -> {\n        expect [(burnt_nft_name, -1)] =\n          dict.to_list(value.tokens(mint, own_script))\n        burn_tn == burnt_nft_name\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `validate_transition` function where the `outputs` list is accessed. The code uses `outputs |> list.at(pool_output)` to get the pool output, but it does not check if `pool_output` is within the bounds of the `outputs` list. This can lead to an out-of-bounds access if `pool_output` is not a valid index, potentially causing incorrect behavior or validation failures.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aada/finance\nuse aada/nft.{CollateralNFTRedeemerLists, MintNFTElem}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aiken/dict\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, Publish, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/certificate.{CredentialDelegation}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{\n  PolicyId, flatten, from_asset, from_minted_value, merge, quantity_of, tokens,\n  without_lovelace,\n}\n\nvalidator(delegator_nft_policy: PolicyId, pool_config_script_hash: PolicyId) {\n  fn spend(datum: pool.Datum, redeemer: pool.Redeemer, ctx: ScriptContext) {\n    let pool.Datum { params, balance, lent_out, total_lp_tokens } = datum\n    let ScriptContext {\n      transaction: Transaction {\n        inputs,\n        mint,\n        redeemers,\n        reference_inputs,\n        outputs,\n        ..\n      },\n      purpose,\n    } = ctx\n    let mint = from_minted_value(mint)\n    expect Spend(output_ref) = purpose\n    expect Some(Input {\n      output: Output { address: this_address, value: pool_input_value, .. },\n      ..\n    }) =\n      list.find(inputs, fn(inp) -> Bool { inp.output_reference == output_ref })\n    expect ScriptCredential(this_script_hash) = this_address.payment_credential\n    let pool_nft_policy: PolicyId = this_script_hash\n\n    // Validates that pool receives right amount and correct datum is assigned\n    // Validate if pool token is in transaction\n    let pool.Redeemer { action, config_ref, .. } = redeemer\n    expect Some(config_input) =\n      list.find(\n        reference_inputs,\n        fn(inp) -> Bool { inp.output_reference == config_ref },\n      )\n    // Make sure pool config NFT is in the transaction\n    let config_has_nft =\n      quantity_of(\n        config_input.output.value,\n        pool_config_script_hash,\n        params.pool_config_assetname,\n      ) == 1\n\n    expect InlineDatum(raw_config_input_datum) = config_input.output.datum\n    expect pool.Config {\n      pool_fee,\n      min_transition,\n      min_loan,\n      min_fee,\n      interest_params,\n      ..\n    }: pool.Config = raw_config_input_datum\n\n    // Validated pool deposit/withdraw transition\n    let validate_transition =\n      fn(pool_output: pool.OutputIndex, f_delta: fn(Int, Int, Int) -> Bool) -> Bool {\n        expect Some(pool_output) = outputs |> list.at(pool_output)\n        expect InlineDatum(contract_datum) = pool_output.datum\n        expect pool.Datum {\n          params: output_params,\n          balance: output_balance,\n          lent_out: output_lent_out,\n          total_lp_tokens: output_total_lp_tokens,\n        }: pool.Datum = contract_datum\n        let output_is_positive = output_lent_out >= 0 && output_balance >= 0\n        let expected_change_value =\n          from_asset(\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n            output_balance - balance,\n          )\n        let expected_value_with_input =\n          merge(pool_input_value, expected_change_value)\n\n        let dust_attack_check =\n          without_lovelace(expected_value_with_input) == without_lovelace(\n            pool_output.value,\n          )\n\n        let valid_pool_output_address = pool_output.address == this_address\n\n        // Pool receives value it expects\n        let value_change_check =\n          quantity_of(\n            expected_value_with_input,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          ) == quantity_of(\n            pool_output.value,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          )\n        // Pol NFT is present in both input and output\n        let pool_input_nft_check =\n          quantity_of(pool_input_value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let pool_output_nft_check =\n          quantity_of(pool_output.value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let valid_pool_token_tx = pool_output_nft_check && pool_input_nft_check\n\n        let params_check = output_params == params\n        let f_delta_check =\n          f_delta(\n            output_balance - balance,\n            output_lent_out - lent_out,\n            output_total_lp_tokens - total_lp_tokens,\n          )\n        and {\n          valid_pool_token_tx?,\n          value_change_check?,\n          f_delta_check?,\n          params_check?,\n          output_is_positive?,\n          dust_attack_check?,\n          valid_pool_output_address?,\n        }\n      }\n    when action is {\n      pool.Destroy -> {\n        // Can only destroy if all LP tokens are burned\n        let lp_token_delta =\n          quantity_of(\n            mint,\n            params.lp_token.policy_id,\n            params.lp_token.asset_name,\n          )\n        let no_remaining_liquidity_tokens =\n          lp_token_delta + total_lp_tokens == 0\n\n        // Only one pool mint transaction when destroying\n        expect Some(mint_redeemer) =\n          redeemers\n            |> dict.get(Mint(pool_nft_policy))\n\n        expect mint_redeemer: pool.PoolNFTAction = mint_redeemer\n        expect pool.BurnPoolNFT(burn_tn) = mint_redeemer\n        let burned_token_name_match = burn_tn == params.pool_nft_name\n        let burnt_delegator_nft =\n          quantity_of(mint, delegator_nft_policy, params.pool_config_assetname) == -1\n        and {\n          no_remaining_liquidity_tokens?,\n          burnt_delegator_nft?,\n          config_has_nft?,\n          burned_token_name_match?,\n        }\n      }\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.LpAdjust { value_delta, continuing_output } -> {\n            let lp_token_delta =\n              quantity_of(\n                mint,\n                params.lp_token.policy_id,\n                params.lp_token.asset_name,\n              )\n\n            expect Some(owned_proportion) =\n              lp_token_delta * ( balance + lent_out )\n                |> rational.new(total_lp_tokens)\n\n            let sign_check = or {\n                // Withdraw scenario\n                and {\n                  value_delta < 0,\n                  lp_token_delta < 0,\n                  value_delta * -1 >= min_transition,\n                  lp_token_delta * -1 < total_lp_tokens,\n                },\n                // ensure not withdrawing more than existing supply\n                // Deposit scenario\n                and {\n                  value_delta > 0,\n                  lp_token_delta > 0,\n                  value_delta >= min_transition,\n                },\n              }\n\n            let notzero =\n              rational.compare(owned_proportion, rational.from_int(0)) != Equal\n\n            // When withdrawing owned_proportion means max you can withdraw.\n            // When depositing owned_proportion means min you can deposit.\n\n            let check_delta_amount =\n              if value_delta < 0 {\n                value_delta * -1 <= rational.truncate(owned_proportion) * -1\n              } else {\n                value_delta >= rational.truncate(owned_proportion)\n              }\n\n            let value_delta_check = and {\n                sign_check,\n                notzero,\n              }\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + value_delta,\n                  lent_delta == 0,\n                  tokens_delta == lp_token_delta,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n\n            and {\n              check_delta_amount?,\n              valid_transition?,\n              value_delta_check?,\n              config_has_nft?,\n            }\n          }\n          pool.Borrow { loan_amount, interest_rate, continuing_output, .. } -> {\n            let loan_is_positive = loan_amount > 0\n            let passes_min_threshold = loan_amount >= min_loan\n            let interest_rate_is_positive = interest_rate > 0\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) {\n                pool_fee - loan_amount == balance_delta && loan_amount == lent_delta && tokens_delta == 0\n              }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            let valid_interest_rates =\n              interest_rate >= finance.get_interest_rates(\n                interest_params,\n                loan_amount,\n                lent_out,\n                balance,\n              )\n\n            expect ScriptCredential(collateral_policy) =\n              params.collateral_address.payment_credential\n            expect Some(collateral_mint_redeemer) =\n              redeemers |> dict.get(Mint(collateral_policy))\n            expect collateral_mint_redeemer: CollateralNFTRedeemerLists =\n              collateral_mint_redeemer\n\n            let valid_collateral_exists =\n              collateral_mint_redeemer.mints\n                |> list.any(\n                     fn(el) {\n                       let MintNFTElem(pool_utxo, _) = el\n                       pool_utxo == output_ref\n                     },\n                   )\n            and {\n              loan_is_positive?,\n              interest_rate_is_positive?,\n              passes_min_threshold?,\n              valid_collateral_exists?,\n              valid_transition?,\n              valid_interest_rates?,\n              config_has_nft?,\n            }\n          }\n          pool.CloseLoan { loan_amount, repay_amount, continuing_output } -> {\n            let loan_amt_check = loan_amount > 0\n            let repay_amt_check = repay_amount > loan_amount\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + repay_amount,\n                  lent_delta == -loan_amount,\n                  tokens_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n          pool.PayFee { fee, continuing_output } -> {\n            let valid_minimum_amount = fee > min_fee\n            let transition_validator =\n              fn(balance_delta, lent_value_delta, tokens_mint_delta) { and {\n                  balance_delta == fee,\n                  lent_value_delta == 0,\n                  tokens_mint_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              valid_minimum_amount?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n        }\n    }\n  }\n\n  fn mint(redeemer: pool.PoolNFTAction, ctx: ScriptContext) -> Bool {\n    let ScriptContext {\n      transaction: Transaction { outputs, mint, redeemers, .. },\n      purpose,\n    } = ctx\n\n    expect Mint(own_script) = purpose\n    let pool_control_credential = ScriptCredential(own_script)\n    let mint = from_minted_value(mint)\n\n    when redeemer is {\n      pool.MintPoolNFT(pool_mint_details) -> {\n        let pool_mint_details: pool.PoolCreateDetails = pool_mint_details\n        let pool_output =\n          outputs\n            |> list.at(pool_mint_details.output_index)\n        expect Some(Output {\n          address: Address(out_credential, Some(out_stake_credential)),\n          value,\n          ..\n        }) = pool_output\n        expect Inline(stake_cred) = out_stake_credential\n        expect ScriptCredential(stake_hash) = stake_cred\n\n        expect Some(stake_validator_redeemer) =\n          dict.get(\n            redeemers,\n            Publish(\n              CredentialDelegation(\n                out_stake_credential,\n                pool_mint_details.initial_pool_delegation,\n              ),\n            ),\n          )\n        expect withdraw_validator_redeemer: pool_stake.StakeRedeemer =\n          stake_validator_redeemer\n\n        expect pool_stake.CreatePool(_withdraw_validator_oref) =\n          withdraw_validator_redeemer\n        let correct_credential = out_credential == pool_control_credential\n        // Pool NFT name is stake_hash\n        let correct_quantity_output =\n          quantity_of(value, own_script, stake_hash) == 1\n\n        expect [(_stake_hash, 1)] = tokens(mint, own_script) |> dict.to_list\n\n        let no_dust_attack =\n          when flatten(value) is {\n            [(_, _, _)] -> True\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        and {\n          correct_credential,\n          correct_quantity_output,\n          no_dust_attack,\n        }\n      }\n\n      // Pool NFT is locked in Pool Validator. You can't easily burn it.\n      // Should expect only one policy mint and it's -1\n      pool.BurnPoolNFT(burn_tn) -> {\n        expect [(burnt_nft_name, -1)] =\n          dict.to_list(value.tokens(mint, own_script))\n        burn_tn == burnt_nft_name\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include a check for the uniqueness of transaction IDs, which allows the same transaction to be replayed multiple times. This can lead to replay attacks where an attacker can reuse a transaction to perform unauthorized actions repeatedly.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aada/finance\nuse aada/nft.{CollateralNFTRedeemerLists, MintNFTElem}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aiken/dict\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, Publish, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/certificate.{CredentialDelegation}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{\n  PolicyId, flatten, from_asset, from_minted_value, merge, quantity_of, tokens,\n  without_lovelace,\n}\n\nvalidator(delegator_nft_policy: PolicyId, pool_config_script_hash: PolicyId) {\n  fn spend(datum: pool.Datum, redeemer: pool.Redeemer, ctx: ScriptContext) {\n    let pool.Datum { params, balance, lent_out, total_lp_tokens } = datum\n    let ScriptContext {\n      transaction: Transaction {\n        inputs,\n        mint,\n        redeemers,\n        reference_inputs,\n        outputs,\n        ..\n      },\n      purpose,\n    } = ctx\n    let mint = from_minted_value(mint)\n    expect Spend(output_ref) = purpose\n    expect Some(Input {\n      output: Output { address: this_address, value: pool_input_value, .. },\n      ..\n    }) =\n      list.find(inputs, fn(inp) -> Bool { inp.output_reference == output_ref })\n    expect ScriptCredential(this_script_hash) = this_address.payment_credential\n    let pool_nft_policy: PolicyId = this_script_hash\n\n    // Validates that pool receives right amount and correct datum is assigned\n    // Validate if pool token is in transaction\n    let pool.Redeemer { action, config_ref, .. } = redeemer\n    expect Some(config_input) =\n      list.find(\n        reference_inputs,\n        fn(inp) -> Bool { inp.output_reference == config_ref },\n      )\n    // Make sure pool config NFT is in the transaction\n    let config_has_nft =\n      quantity_of(\n        config_input.output.value,\n        pool_config_script_hash,\n        params.pool_config_assetname,\n      ) == 1\n\n    expect InlineDatum(raw_config_input_datum) = config_input.output.datum\n    expect pool.Config {\n      pool_fee,\n      min_transition,\n      min_loan,\n      min_fee,\n      interest_params,\n      ..\n    }: pool.Config = raw_config_input_datum\n\n    // Validated pool deposit/withdraw transition\n    let validate_transition =\n      fn(pool_output: pool.OutputIndex, f_delta: fn(Int, Int, Int) -> Bool) -> Bool {\n        expect Some(pool_output) = outputs |> list.at(pool_output)\n        expect InlineDatum(contract_datum) = pool_output.datum\n        expect pool.Datum {\n          params: output_params,\n          balance: output_balance,\n          lent_out: output_lent_out,\n          total_lp_tokens: output_total_lp_tokens,\n        }: pool.Datum = contract_datum\n        let output_is_positive = output_lent_out >= 0 && output_balance >= 0\n        let expected_change_value =\n          from_asset(\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n            output_balance - balance,\n          )\n        let expected_value_with_input =\n          merge(pool_input_value, expected_change_value)\n\n        let dust_attack_check =\n          without_lovelace(expected_value_with_input) == without_lovelace(\n            pool_output.value,\n          )\n\n        let valid_pool_output_address = pool_output.address == this_address\n\n        // Pool receives value it expects\n        let value_change_check =\n          quantity_of(\n            expected_value_with_input,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          ) == quantity_of(\n            pool_output.value,\n            params.loan_cs.policy_id,\n            params.loan_cs.asset_name,\n          )\n        // Pol NFT is present in both input and output\n        let pool_input_nft_check =\n          quantity_of(pool_input_value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let pool_output_nft_check =\n          quantity_of(pool_output.value, pool_nft_policy, params.pool_nft_name) == 1\n\n        let valid_pool_token_tx = pool_output_nft_check && pool_input_nft_check\n\n        let params_check = output_params == params\n        let f_delta_check =\n          f_delta(\n            output_balance - balance,\n            output_lent_out - lent_out,\n            output_total_lp_tokens - total_lp_tokens,\n          )\n        and {\n          valid_pool_token_tx?,\n          value_change_check?,\n          f_delta_check?,\n          params_check?,\n          output_is_positive?,\n          dust_attack_check?,\n          valid_pool_output_address?,\n        }\n      }\n    when action is {\n      pool.Destroy -> {\n        // Can only destroy if all LP tokens are burned\n        let lp_token_delta =\n          quantity_of(\n            mint,\n            params.lp_token.policy_id,\n            params.lp_token.asset_name,\n          )\n        let no_remaining_liquidity_tokens =\n          lp_token_delta + total_lp_tokens == 0\n\n        // Only one pool mint transaction when destroying\n        expect Some(mint_redeemer) =\n          redeemers\n            |> dict.get(Mint(pool_nft_policy))\n\n        expect mint_redeemer: pool.PoolNFTAction = mint_redeemer\n        expect pool.BurnPoolNFT(burn_tn) = mint_redeemer\n        let burned_token_name_match = burn_tn == params.pool_nft_name\n        let burnt_delegator_nft =\n          quantity_of(mint, delegator_nft_policy, params.pool_config_assetname) == -1\n        and {\n          no_remaining_liquidity_tokens?,\n          burnt_delegator_nft?,\n          config_has_nft?,\n          burned_token_name_match?,\n        }\n      }\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.LpAdjust { value_delta, continuing_output } -> {\n            let lp_token_delta =\n              quantity_of(\n                mint,\n                params.lp_token.policy_id,\n                params.lp_token.asset_name,\n              )\n\n            expect Some(owned_proportion) =\n              lp_token_delta * ( balance + lent_out )\n                |> rational.new(total_lp_tokens)\n\n            let sign_check = or {\n                // Withdraw scenario\n                and {\n                  value_delta < 0,\n                  lp_token_delta < 0,\n                  value_delta * -1 >= min_transition,\n                  lp_token_delta * -1 < total_lp_tokens,\n                },\n                // ensure not withdrawing more than existing supply\n                // Deposit scenario\n                and {\n                  value_delta > 0,\n                  lp_token_delta > 0,\n                  value_delta >= min_transition,\n                },\n              }\n\n            let notzero =\n              rational.compare(owned_proportion, rational.from_int(0)) != Equal\n\n            // When withdrawing owned_proportion means max you can withdraw.\n            // When depositing owned_proportion means min you can deposit.\n\n            let check_delta_amount =\n              if value_delta < 0 {\n                value_delta * -1 <= rational.truncate(owned_proportion) * -1\n              } else {\n                value_delta >= rational.truncate(owned_proportion)\n              }\n\n            let value_delta_check = and {\n                sign_check,\n                notzero,\n              }\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + value_delta,\n                  lent_delta == 0,\n                  tokens_delta == lp_token_delta,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n\n            and {\n              check_delta_amount?,\n              valid_transition?,\n              value_delta_check?,\n              config_has_nft?,\n            }\n          }\n          pool.Borrow { loan_amount, interest_rate, continuing_output, .. } -> {\n            let loan_is_positive = loan_amount > 0\n            let passes_min_threshold = loan_amount >= min_loan\n            let interest_rate_is_positive = interest_rate > 0\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) {\n                pool_fee - loan_amount == balance_delta && loan_amount == lent_delta && tokens_delta == 0\n              }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            let valid_interest_rates =\n              interest_rate >= finance.get_interest_rates(\n                interest_params,\n                loan_amount,\n                lent_out,\n                balance,\n              )\n\n            expect ScriptCredential(collateral_policy) =\n              params.collateral_address.payment_credential\n            expect Some(collateral_mint_redeemer) =\n              redeemers |> dict.get(Mint(collateral_policy))\n            expect collateral_mint_redeemer: CollateralNFTRedeemerLists =\n              collateral_mint_redeemer\n\n            let valid_collateral_exists =\n              collateral_mint_redeemer.mints\n                |> list.any(\n                     fn(el) {\n                       let MintNFTElem(pool_utxo, _) = el\n                       pool_utxo == output_ref\n                     },\n                   )\n            and {\n              loan_is_positive?,\n              interest_rate_is_positive?,\n              passes_min_threshold?,\n              valid_collateral_exists?,\n              valid_transition?,\n              valid_interest_rates?,\n              config_has_nft?,\n            }\n          }\n          pool.CloseLoan { loan_amount, repay_amount, continuing_output } -> {\n            let loan_amt_check = loan_amount > 0\n            let repay_amt_check = repay_amount > loan_amount\n            let transition_validator =\n              fn(balance_delta, lent_delta, tokens_delta) { and {\n                  balance_delta == pool_fee + repay_amount,\n                  lent_delta == -loan_amount,\n                  tokens_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n          pool.PayFee { fee, continuing_output } -> {\n            let valid_minimum_amount = fee > min_fee\n            let transition_validator =\n              fn(balance_delta, lent_value_delta, tokens_mint_delta) { and {\n                  balance_delta == fee,\n                  lent_value_delta == 0,\n                  tokens_mint_delta == 0,\n                } }\n            let valid_transition =\n              continuing_output\n                |> validate_transition(transition_validator)\n            and {\n              valid_minimum_amount?,\n              valid_transition?,\n              config_has_nft?,\n            }\n          }\n        }\n    }\n  }\n\n  fn mint(redeemer: pool.PoolNFTAction, ctx: ScriptContext) -> Bool {\n    let ScriptContext {\n      transaction: Transaction { outputs, mint, redeemers, .. },\n      purpose,\n    } = ctx\n\n    expect Mint(own_script) = purpose\n    let pool_control_credential = ScriptCredential(own_script)\n    let mint = from_minted_value(mint)\n\n    when redeemer is {\n      pool.MintPoolNFT(pool_mint_details) -> {\n        let pool_mint_details: pool.PoolCreateDetails = pool_mint_details\n        let pool_output =\n          outputs\n            |> list.at(pool_mint_details.output_index)\n        expect Some(Output {\n          address: Address(out_credential, Some(out_stake_credential)),\n          value,\n          ..\n        }) = pool_output\n        expect Inline(stake_cred) = out_stake_credential\n        expect ScriptCredential(stake_hash) = stake_cred\n\n        expect Some(stake_validator_redeemer) =\n          dict.get(\n            redeemers,\n            Publish(\n              CredentialDelegation(\n                out_stake_credential,\n                pool_mint_details.initial_pool_delegation,\n              ),\n            ),\n          )\n        expect withdraw_validator_redeemer: pool_stake.StakeRedeemer =\n          stake_validator_redeemer\n\n        expect pool_stake.CreatePool(_withdraw_validator_oref) =\n          withdraw_validator_redeemer\n        let correct_credential = out_credential == pool_control_credential\n        // Pool NFT name is stake_hash\n        let correct_quantity_output =\n          quantity_of(value, own_script, stake_hash) == 1\n\n        expect [(_stake_hash, 1)] = tokens(mint, own_script) |> dict.to_list\n\n        let no_dust_attack =\n          when flatten(value) is {\n            [(_, _, _)] -> True\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        and {\n          correct_credential,\n          correct_quantity_output,\n          no_dust_attack,\n        }\n      }\n\n      // Pool NFT is locked in Pool Validator. You can't easily burn it.\n      // Should expect only one policy mint and it's -1\n      pool.BurnPoolNFT(burn_tn) -> {\n        expect [(burnt_nft_name, -1)] =\n          dict.to_list(value.tokens(mint, own_script))\n        burn_tn == burnt_nft_name\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `validate_transition` function where the `params_check` is performed. The `params_check` is supposed to ensure that the parameters in the output datum match the expected parameters. However, the check is performed using `output_params == params`, which can be bypassed if the `output_params` are manipulated to match the expected `params` without actually being valid. This allows for incorrect reference or datum hash validation, potentially enabling misuse of datums.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by not enforcing any size or structural constraints on the `SwapDatum` when it is extracted from the `datum` parameter. This allows potentially malformed or oversized data to be passed as a valid `SwapDatum`, which could lead to unexpected behavior or vulnerabilities in the contract logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that accepts datum without enforcing size or structural constraints."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `beacon_script` function, the `UpdateSwaps` branch now allows any `tx.WithdrawFrom` purpose to pass, as long as it contains an `Inline(ScriptCredential(policy_id))`. This means that a `WithdrawFrom` purpose that is not intended for `UpdateSwaps` can still be processed, potentially allowing unauthorized redeemer values to be used.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows redeemer values not intended for that branch of logic."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `beacon_script` function for the `CreateOrCloseSwaps` redeemer. The `policy_id` is extracted from the `purpose` using `tx.Mint(policy_id)`, but it does not verify that the `policy_id` matches the expected `dapp_hash`. This allows incorrect script usage by not ensuring the script hash is validated against the expected DApp hash.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to validate the spending script hash, allowing incorrect script usage."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not verify that the correct signer (pubkey) is present in the transaction. This means that any transaction can be executed without checking if the transaction is signed by the required public key, potentially allowing unauthorized users to perform actions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by omitting the check for the transaction's validity interval, specifically the `valid_from` and `valid_to` constraints, in the `swap_script` function. This allows the swap to be executed outside the intended time range, potentially leading to unauthorized or unintended transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that misuses the time range constraints (`valid_from`, `valid_to`), allowing invalid execution timing."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `swap_script` function, within the `TakeAsset1` and `TakeAsset2` cases, the `utils.valid_swap` function is called with the `outputs` list. If this function internally uses list indexing or loops, an off-by-one error could occur if the function assumes the list is zero-indexed but is actually one-indexed, or vice versa. This could lead to incorrect validation of the swap conditions, potentially allowing invalid swaps to be processed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by removing the check for `asset1_price` and `asset2_price` to ensure that their numerators and denominators are greater than zero in the `TakeAsset1` and `TakeAsset2` cases. This omission can lead to potential numeric overflows or underflows during price calculations, as division by zero or multiplication with zero is not prevented.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `TakeAsset1` and `TakeAsset2` branches, the `utils.valid_swap` function is called with the `outputs` parameter. However, the code does not check if the `outputs` list is empty before calling this function. This could lead to incorrect behavior if the transaction has no outputs, as the function might assume at least one output is present.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `TakeAsset1` and `TakeAsset2` branches where the `asset1_price` and `asset2_price` are used. The code does not handle the case where these prices could be negative, which could lead to incorrect calculations and validations when negative values are provided. This could allow for unintended behavior in swaps, such as allowing trades that should not be valid.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `TakeAsset1` and `TakeAsset2` branches of the `swap_script` function. The `Transaction` pattern in `ScriptContext` is missing the `validity_interval` field, which is crucial for interpreting transaction deadlines. This omission can lead to incorrect validation of transaction deadlines, potentially allowing transactions to be processed outside their intended time frame.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows the same transaction to be replayed multiple times. This can lead to replay attacks where an attacker can reuse a transaction to perform the same action repeatedly, potentially causing unintended consequences or financial loss.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `TakeAsset1` and `TakeAsset2` branches, the `SwapDatum` extraction does not include a check for the `prev_input` field, which is supposed to ensure that the datum is correctly linked to the input reference. This omission allows for the possibility of reusing datums across different transactions without proper validation, potentially leading to misuse.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/transaction.{Mint, ScriptContext, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{AssetName, PolicyId}\nuse assist/addresses\nuse assist/find\nuse assist/minting\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash, TxHash, ValidatorHash}\nuse assist/values\nuse mint_contract/types.{BurnTokens, MintRedeemer, MintTokens}\n\n// This allows a hot key to mint 1 reference and 1 nft for a cip 68 token or\n// the hot key may be either the reference or nft.\nvalidator(\n  // this key controls everything\n  hot_key: PublicKeyHash,\n  // the cip 68 and stake data\n  cip68_hash_data: Data,\n  stake_hash_data: Data,\n  // this allows many policy ids\n  _random_string: ByteArray,\n) {\n  fn params(redeemer: MintRedeemer, context: ScriptContext) -> Bool {\n    // this transaction\n    let tx: Transaction = context.transaction\n    // the minted value from the tx\n    let mint: List<(PolicyId, AssetName, Int)> =\n      tx.mint\n        |> value.from_minted_value()\n        |> value.flatten()\n    // mint only\n    when context.purpose is {\n      // mint 1 ref and 1 nft\n      Mint(own_currency_symbol) ->\n        when redeemer is {\n          MintTokens -> {\n            // cip68 address know at compile time\n            expect cip68_hash: ValidatorHash = cip68_hash_data\n            expect stake_hash: ValidatorHash = stake_hash_data\n            // staking at this address\n            let cip68_addr: Address =\n              addresses.create_script_address(cip68_hash, stake_hash)\n            // get first input info from the tx in lexographical order\n            let first_index: Int = find.first_input_index(tx.inputs)\n            let first_tx_hash: TxHash = find.first_input_txid(tx.inputs)\n            // use the reference prefix\n            let ref_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_100,\n              )\n            // use the nft prefix\n            let nft_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_222,\n              )\n            // this should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)\n            //\n            // The hot key has to sign the tx to mint 1 ref and 1 nft. There\n            // is destination validation for the cip68 token but not for the \n            // nft. This should allow a lot of flexability.\n            //\n            and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // prevent roll over double nft attack\n              (first_index < 256)?,\n              // must mint 1 reference token\n              minting.exact(mint, own_currency_symbol, ref_tkn, 1)?,\n              // the nft can go anywhere; ref must go to metadatum contract\n              // must mint 1 non-fungible token\n              minting.exact(mint, own_currency_symbol, nft_tkn, 1)?,\n              // reference token must go to cip contract\n              payout.at_least(\n                cip68_addr,\n                value.from_asset(own_currency_symbol, ref_tkn, 1),\n                tx.outputs,\n              )?,\n            }\n          }\n          // burn the ref or the nft or both at the same time\n          BurnTokens -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // this allows optional burning of either or both\n              or {\n                // burn only 1 ref token\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_100,\n                  -1,\n                )?,\n                // burn only 1 nft\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_222,\n                  -1,\n                )?,\n              }?,\n            }\n        }\n      // Mint Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is introduced by omitting the validation of the token names `ref_tkn` and `nft_tkn` before minting. This allows the minting of tokens with any name, bypassing the intended restriction to specific token names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/minter.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aada/types/pool\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{InlineDatum, Mint, OutputReference, ScriptContext}\nuse aiken/transaction/value.{flatten, from_minted_value, quantity_of, tokens}\n\ntype TokenRedeemer {\n  TransitionPool {\n    pool_oref: OutputReference,\n    continuing_output: pool.OutputIndex,\n  }\n  CreatePool { produced_output: pool.OutputIndex }\n  DestroyPool { pool_oref: OutputReference }\n}\n\n// Liquidity token is a representation of the pool liquidity.\n\nvalidator(pool_hash: ByteArray, token_name: ByteArray) {\n  fn liquidity_token(redeemer: TokenRedeemer, ctx: ScriptContext) {\n    expect Mint(own_policy) = ctx.purpose\n    when redeemer is {\n      // Deposit or Withdraw redeemer\n      TransitionPool { pool_oref, continuing_output } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(continuing_output)\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let pool_addresses_matches =\n          pool_input.output.address == pool_output.address\n        let id = input_datum.params.pool_nft_name\n\n        let dust_attack_check =\n          when flatten(pool_input.output.value) is {\n            [(_, _, _)] -> False\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        // Makes sure Pool NFT is present as well as it's in the output\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, id) == 1 && quantity_of(\n            pool_output.value,\n            pool_hash,\n            id,\n          ) == 1\n\n        expect [(lp_token_name, lp_tokens_amount)] =\n          tokens(from_minted_value(ctx.transaction.mint), own_policy)\n            |> dict.to_list()\n\n        // LP token name must match LP token name which is also pool Stake-creds hash\n        let valid_lp_token_name =\n          lp_token_name == output_datum.params.pool_nft_name && lp_token_name == token_name\n        let valid_lp_token_change =\n          output_datum.total_lp_tokens - input_datum.total_lp_tokens == lp_tokens_amount\n        and {\n          valid_lp_token_change,\n          valid_lp_token_name,\n          nfts_check,\n          dust_attack_check,\n          pool_addresses_matches,\n        }\n      }\n      DestroyPool { pool_oref } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, token_name) == 1\n        let nft_name_datum_check =\n          input_datum.params.pool_nft_name == token_name\n\n        let actual_tokens_minted =\n          quantity_of(\n            from_minted_value(ctx.transaction.mint),\n            own_policy,\n            token_name,\n          )\n\n        let tokens_mint_check =\n          actual_tokens_minted + input_datum.total_lp_tokens == 0\n\n        and {\n          tokens_mint_check?,\n          nfts_check?,\n          nft_name_datum_check?,\n        }\n      }\n      CreatePool { produced_output } -> {\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(produced_output)\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let mint = from_minted_value(ctx.transaction.mint)\n\n        // Expects only one tokenName to be minted\n        expect [(pool_token_name, 1)] = dict.to_list(tokens(mint, pool_hash))\n\n        // Doing an extra check for all the name matching\n        let correct_pooltoken_name = and {\n            pool_token_name == output_datum.params.pool_nft_name,\n            token_name == pool_token_name,\n          }\n\n        let lp_tokens_minted = quantity_of(mint, own_policy, pool_token_name)\n        let depositing_tokens_count_actual =\n          quantity_of(\n            pool_output.value,\n            output_datum.params.loan_cs.policy_id,\n            output_datum.params.loan_cs.asset_name,\n          )\n        let correct_pooltoken_out =\n          quantity_of(pool_output.value, pool_hash, pool_token_name) == 1\n\n        let correct_recorded_lptokens =\n          output_datum.total_lp_tokens == lp_tokens_minted\n\n        let depositing_gt_0 = depositing_tokens_count_actual > 0\n        let depositing_at_script =\n          depositing_tokens_count_actual == output_datum.balance\n\n        let minted_lp_match_deposit =\n          depositing_tokens_count_actual == lp_tokens_minted\n        and {\n          correct_pooltoken_out?,\n          correct_recorded_lptokens?,\n          depositing_gt_0?,\n          depositing_at_script?,\n          minted_lp_match_deposit?,\n          correct_pooltoken_name?,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "In the `DestroyPool` branch, the check `tokens_mint_check` is intended to ensure that the sum of `actual_tokens_minted` and `input_datum.total_lp_tokens` is zero, indicating that no tokens are left after destruction. However, using `==` instead of `!=` would incorrectly allow the transaction to pass if there are leftover tokens, potentially leading to an incorrect state where tokens are not properly accounted for.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/liquidity_token.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aada/types/pool\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{InlineDatum, Mint, OutputReference, ScriptContext}\nuse aiken/transaction/value.{flatten, from_minted_value, quantity_of, tokens}\n\ntype TokenRedeemer {\n  TransitionPool {\n    pool_oref: OutputReference,\n    continuing_output: pool.OutputIndex,\n  }\n  CreatePool { produced_output: pool.OutputIndex }\n  DestroyPool { pool_oref: OutputReference }\n}\n\n// Liquidity token is a representation of the pool liquidity.\n\nvalidator(pool_hash: ByteArray, token_name: ByteArray) {\n  fn liquidity_token(redeemer: TokenRedeemer, ctx: ScriptContext) {\n    expect Mint(own_policy) = ctx.purpose\n    when redeemer is {\n      // Deposit or Withdraw redeemer\n      TransitionPool { pool_oref, continuing_output } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(continuing_output)\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let pool_addresses_matches =\n          pool_input.output.address == pool_output.address\n        let id = input_datum.params.pool_nft_name\n\n        let dust_attack_check =\n          when flatten(pool_input.output.value) is {\n            [(_, _, _)] -> False\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        // Makes sure Pool NFT is present as well as it's in the output\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, id) == 1 && quantity_of(\n            pool_output.value,\n            pool_hash,\n            id,\n          ) == 1\n\n        expect [(lp_token_name, lp_tokens_amount)] =\n          tokens(from_minted_value(ctx.transaction.mint), own_policy)\n            |> dict.to_list()\n\n        // LP token name must match LP token name which is also pool Stake-creds hash\n        let valid_lp_token_name =\n          lp_token_name == output_datum.params.pool_nft_name && lp_token_name == token_name\n        let valid_lp_token_change =\n          output_datum.total_lp_tokens - input_datum.total_lp_tokens == lp_tokens_amount\n        and {\n          valid_lp_token_change,\n          valid_lp_token_name,\n          nfts_check,\n          dust_attack_check,\n          pool_addresses_matches,\n        }\n      }\n      DestroyPool { pool_oref } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, token_name) == 1\n        let nft_name_datum_check =\n          input_datum.params.pool_nft_name == token_name\n\n        let actual_tokens_minted =\n          quantity_of(\n            from_minted_value(ctx.transaction.mint),\n            own_policy,\n            token_name,\n          )\n\n        let tokens_mint_check =\n          actual_tokens_minted + input_datum.total_lp_tokens == 0\n\n        and {\n          tokens_mint_check?,\n          nfts_check?,\n          nft_name_datum_check?,\n        }\n      }\n      CreatePool { produced_output } -> {\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(produced_output)\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let mint = from_minted_value(ctx.transaction.mint)\n\n        // Expects only one tokenName to be minted\n        expect [(pool_token_name, 1)] = dict.to_list(tokens(mint, pool_hash))\n\n        // Doing an extra check for all the name matching\n        let correct_pooltoken_name = and {\n            pool_token_name == output_datum.params.pool_nft_name,\n            token_name == pool_token_name,\n          }\n\n        let lp_tokens_minted = quantity_of(mint, own_policy, pool_token_name)\n        let depositing_tokens_count_actual =\n          quantity_of(\n            pool_output.value,\n            output_datum.params.loan_cs.policy_id,\n            output_datum.params.loan_cs.asset_name,\n          )\n        let correct_pooltoken_out =\n          quantity_of(pool_output.value, pool_hash, pool_token_name) == 1\n\n        let correct_recorded_lptokens =\n          output_datum.total_lp_tokens == lp_tokens_minted\n\n        let depositing_gt_0 = depositing_tokens_count_actual > 0\n        let depositing_at_script =\n          depositing_tokens_count_actual == output_datum.balance\n\n        let minted_lp_match_deposit =\n          depositing_tokens_count_actual == lp_tokens_minted\n        and {\n          correct_pooltoken_out?,\n          correct_recorded_lptokens?,\n          depositing_gt_0?,\n          depositing_at_script?,\n          minted_lp_match_deposit?,\n          correct_pooltoken_name?,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "The code does not verify that the correct signer (pubkey) is present in the transaction. This means that any transaction can be processed without checking if it was authorized by the expected signer, potentially allowing unauthorized actions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/liquidity_token.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aada/types/pool\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{InlineDatum, Mint, OutputReference, ScriptContext}\nuse aiken/transaction/value.{flatten, from_minted_value, quantity_of, tokens}\n\ntype TokenRedeemer {\n  TransitionPool {\n    pool_oref: OutputReference,\n    continuing_output: pool.OutputIndex,\n  }\n  CreatePool { produced_output: pool.OutputIndex }\n  DestroyPool { pool_oref: OutputReference }\n}\n\n// Liquidity token is a representation of the pool liquidity.\n\nvalidator(pool_hash: ByteArray, token_name: ByteArray) {\n  fn liquidity_token(redeemer: TokenRedeemer, ctx: ScriptContext) {\n    expect Mint(own_policy) = ctx.purpose\n    when redeemer is {\n      // Deposit or Withdraw redeemer\n      TransitionPool { pool_oref, continuing_output } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(continuing_output)\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let pool_addresses_matches =\n          pool_input.output.address == pool_output.address\n        let id = input_datum.params.pool_nft_name\n\n        let dust_attack_check =\n          when flatten(pool_input.output.value) is {\n            [(_, _, _)] -> False\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        // Makes sure Pool NFT is present as well as it's in the output\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, id) == 1 && quantity_of(\n            pool_output.value,\n            pool_hash,\n            id,\n          ) == 1\n\n        expect [(lp_token_name, lp_tokens_amount)] =\n          tokens(from_minted_value(ctx.transaction.mint), own_policy)\n            |> dict.to_list()\n\n        // LP token name must match LP token name which is also pool Stake-creds hash\n        let valid_lp_token_name =\n          lp_token_name == output_datum.params.pool_nft_name && lp_token_name == token_name\n        let valid_lp_token_change =\n          output_datum.total_lp_tokens - input_datum.total_lp_tokens == lp_tokens_amount\n        and {\n          valid_lp_token_change,\n          valid_lp_token_name,\n          nfts_check,\n          dust_attack_check,\n          pool_addresses_matches,\n        }\n      }\n      DestroyPool { pool_oref } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, token_name) == 1\n        let nft_name_datum_check =\n          input_datum.params.pool_nft_name == token_name\n\n        let actual_tokens_minted =\n          quantity_of(\n            from_minted_value(ctx.transaction.mint),\n            own_policy,\n            token_name,\n          )\n\n        let tokens_mint_check =\n          actual_tokens_minted + input_datum.total_lp_tokens == 0\n\n        and {\n          tokens_mint_check?,\n          nfts_check?,\n          nft_name_datum_check?,\n        }\n      }\n      CreatePool { produced_output } -> {\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(produced_output)\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let mint = from_minted_value(ctx.transaction.mint)\n\n        // Expects only one tokenName to be minted\n        expect [(pool_token_name, 1)] = dict.to_list(tokens(mint, pool_hash))\n\n        // Doing an extra check for all the name matching\n        let correct_pooltoken_name = and {\n            pool_token_name == output_datum.params.pool_nft_name,\n            token_name == pool_token_name,\n          }\n\n        let lp_tokens_minted = quantity_of(mint, own_policy, pool_token_name)\n        let depositing_tokens_count_actual =\n          quantity_of(\n            pool_output.value,\n            output_datum.params.loan_cs.policy_id,\n            output_datum.params.loan_cs.asset_name,\n          )\n        let correct_pooltoken_out =\n          quantity_of(pool_output.value, pool_hash, pool_token_name) == 1\n\n        let correct_recorded_lptokens =\n          output_datum.total_lp_tokens == lp_tokens_minted\n\n        let depositing_gt_0 = depositing_tokens_count_actual > 0\n        let depositing_at_script =\n          depositing_tokens_count_actual == output_datum.balance\n\n        let minted_lp_match_deposit =\n          depositing_tokens_count_actual == lp_tokens_minted\n        and {\n          correct_pooltoken_out?,\n          correct_recorded_lptokens?,\n          depositing_gt_0?,\n          depositing_at_script?,\n          minted_lp_match_deposit?,\n          correct_pooltoken_name?,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the code does not check for valid time constraints (`valid_from`, `valid_to`) in any of the transaction cases. This omission allows transactions to be executed at any time, even outside the intended valid time range, potentially leading to unauthorized or unintended operations.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/liquidity_token.ak", "language": "ak", "bug_prompt": "Introduce a bug that misuses the time range constraints (`valid_from`, `valid_to`), allowing invalid execution timing."}
{"contract": "use aada/types/pool\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{InlineDatum, Mint, OutputReference, ScriptContext}\nuse aiken/transaction/value.{flatten, from_minted_value, quantity_of, tokens}\n\ntype TokenRedeemer {\n  TransitionPool {\n    pool_oref: OutputReference,\n    continuing_output: pool.OutputIndex,\n  }\n  CreatePool { produced_output: pool.OutputIndex }\n  DestroyPool { pool_oref: OutputReference }\n}\n\n// Liquidity token is a representation of the pool liquidity.\n\nvalidator(pool_hash: ByteArray, token_name: ByteArray) {\n  fn liquidity_token(redeemer: TokenRedeemer, ctx: ScriptContext) {\n    expect Mint(own_policy) = ctx.purpose\n    when redeemer is {\n      // Deposit or Withdraw redeemer\n      TransitionPool { pool_oref, continuing_output } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(continuing_output)\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let pool_addresses_matches =\n          pool_input.output.address == pool_output.address\n        let id = input_datum.params.pool_nft_name\n\n        let dust_attack_check =\n          when flatten(pool_input.output.value) is {\n            [(_, _, _)] -> False\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        // Makes sure Pool NFT is present as well as it's in the output\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, id) == 1 && quantity_of(\n            pool_output.value,\n            pool_hash,\n            id,\n          ) == 1\n\n        expect [(lp_token_name, lp_tokens_amount)] =\n          tokens(from_minted_value(ctx.transaction.mint), own_policy)\n            |> dict.to_list()\n\n        // LP token name must match LP token name which is also pool Stake-creds hash\n        let valid_lp_token_name =\n          lp_token_name == output_datum.params.pool_nft_name && lp_token_name == token_name\n        let valid_lp_token_change =\n          output_datum.total_lp_tokens - input_datum.total_lp_tokens == lp_tokens_amount\n        and {\n          valid_lp_token_change,\n          valid_lp_token_name,\n          nfts_check,\n          dust_attack_check,\n          pool_addresses_matches,\n        }\n      }\n      DestroyPool { pool_oref } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, token_name) == 1\n        let nft_name_datum_check =\n          input_datum.params.pool_nft_name == token_name\n\n        let actual_tokens_minted =\n          quantity_of(\n            from_minted_value(ctx.transaction.mint),\n            own_policy,\n            token_name,\n          )\n\n        let tokens_mint_check =\n          actual_tokens_minted + input_datum.total_lp_tokens == 0\n\n        and {\n          tokens_mint_check?,\n          nfts_check?,\n          nft_name_datum_check?,\n        }\n      }\n      CreatePool { produced_output } -> {\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(produced_output)\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let mint = from_minted_value(ctx.transaction.mint)\n\n        // Expects only one tokenName to be minted\n        expect [(pool_token_name, 1)] = dict.to_list(tokens(mint, pool_hash))\n\n        // Doing an extra check for all the name matching\n        let correct_pooltoken_name = and {\n            pool_token_name == output_datum.params.pool_nft_name,\n            token_name == pool_token_name,\n          }\n\n        let lp_tokens_minted = quantity_of(mint, own_policy, pool_token_name)\n        let depositing_tokens_count_actual =\n          quantity_of(\n            pool_output.value,\n            output_datum.params.loan_cs.policy_id,\n            output_datum.params.loan_cs.asset_name,\n          )\n        let correct_pooltoken_out =\n          quantity_of(pool_output.value, pool_hash, pool_token_name) == 1\n\n        let correct_recorded_lptokens =\n          output_datum.total_lp_tokens == lp_tokens_minted\n\n        let depositing_gt_0 = depositing_tokens_count_actual > 0\n        let depositing_at_script =\n          depositing_tokens_count_actual == output_datum.balance\n\n        let minted_lp_match_deposit =\n          depositing_tokens_count_actual == lp_tokens_minted\n        and {\n          correct_pooltoken_out?,\n          correct_recorded_lptokens?,\n          depositing_gt_0?,\n          depositing_at_script?,\n          minted_lp_match_deposit?,\n          correct_pooltoken_name?,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `valid_lp_token_change` check within the `TransitionPool` case. The subtraction `output_datum.total_lp_tokens - input_datum.total_lp_tokens` can result in a negative value if `input_datum.total_lp_tokens` is greater than `output_datum.total_lp_tokens`, leading to an underflow since there is no check to ensure that `output_datum.total_lp_tokens` is greater than or equal to `input_datum.total_lp_tokens`.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/liquidity_token.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aada/types/pool\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{InlineDatum, Mint, OutputReference, ScriptContext}\nuse aiken/transaction/value.{flatten, from_minted_value, quantity_of, tokens}\n\ntype TokenRedeemer {\n  TransitionPool {\n    pool_oref: OutputReference,\n    continuing_output: pool.OutputIndex,\n  }\n  CreatePool { produced_output: pool.OutputIndex }\n  DestroyPool { pool_oref: OutputReference }\n}\n\n// Liquidity token is a representation of the pool liquidity.\n\nvalidator(pool_hash: ByteArray, token_name: ByteArray) {\n  fn liquidity_token(redeemer: TokenRedeemer, ctx: ScriptContext) {\n    expect Mint(own_policy) = ctx.purpose\n    when redeemer is {\n      // Deposit or Withdraw redeemer\n      TransitionPool { pool_oref, continuing_output } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(continuing_output)\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let pool_addresses_matches =\n          pool_input.output.address == pool_output.address\n        let id = input_datum.params.pool_nft_name\n\n        let dust_attack_check =\n          when flatten(pool_input.output.value) is {\n            [(_, _, _)] -> False\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        // Makes sure Pool NFT is present as well as it's in the output\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, id) == 1 && quantity_of(\n            pool_output.value,\n            pool_hash,\n            id,\n          ) == 1\n\n        expect [(lp_token_name, lp_tokens_amount)] =\n          tokens(from_minted_value(ctx.transaction.mint), own_policy)\n            |> dict.to_list()\n\n        // LP token name must match LP token name which is also pool Stake-creds hash\n        let valid_lp_token_name =\n          lp_token_name == output_datum.params.pool_nft_name && lp_token_name == token_name\n        let valid_lp_token_change =\n          output_datum.total_lp_tokens - input_datum.total_lp_tokens == lp_tokens_amount\n        and {\n          valid_lp_token_change,\n          valid_lp_token_name,\n          nfts_check,\n          dust_attack_check,\n          pool_addresses_matches,\n        }\n      }\n      DestroyPool { pool_oref } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, token_name) == 1\n        let nft_name_datum_check =\n          input_datum.params.pool_nft_name == token_name\n\n        let actual_tokens_minted =\n          quantity_of(\n            from_minted_value(ctx.transaction.mint),\n            own_policy,\n            token_name,\n          )\n\n        let tokens_mint_check =\n          actual_tokens_minted + input_datum.total_lp_tokens == 0\n\n        and {\n          tokens_mint_check?,\n          nfts_check?,\n          nft_name_datum_check?,\n        }\n      }\n      CreatePool { produced_output } -> {\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(produced_output)\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let mint = from_minted_value(ctx.transaction.mint)\n\n        // Expects only one tokenName to be minted\n        expect [(pool_token_name, 1)] = dict.to_list(tokens(mint, pool_hash))\n\n        // Doing an extra check for all the name matching\n        let correct_pooltoken_name = and {\n            pool_token_name == output_datum.params.pool_nft_name,\n            token_name == pool_token_name,\n          }\n\n        let lp_tokens_minted = quantity_of(mint, own_policy, pool_token_name)\n        let depositing_tokens_count_actual =\n          quantity_of(\n            pool_output.value,\n            output_datum.params.loan_cs.policy_id,\n            output_datum.params.loan_cs.asset_name,\n          )\n        let correct_pooltoken_out =\n          quantity_of(pool_output.value, pool_hash, pool_token_name) == 1\n\n        let correct_recorded_lptokens =\n          output_datum.total_lp_tokens == lp_tokens_minted\n\n        let depositing_gt_0 = depositing_tokens_count_actual > 0\n        let depositing_at_script =\n          depositing_tokens_count_actual == output_datum.balance\n\n        let minted_lp_match_deposit =\n          depositing_tokens_count_actual == lp_tokens_minted\n        and {\n          correct_pooltoken_out?,\n          correct_recorded_lptokens?,\n          depositing_gt_0?,\n          depositing_at_script?,\n          minted_lp_match_deposit?,\n          correct_pooltoken_name?,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `CreatePool` case where the code expects only one token name to be minted. The line `expect [(pool_token_name, 1)] = dict.to_list(tokens(mint, pool_hash))` should ensure that exactly one token is minted. However, if multiple tokens are minted with the same name, this check will still pass, as it only checks for the presence of one token with the specified name, not the total number of tokens minted. This could allow unintended minting of additional tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/liquidity_token.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aada/types/pool\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{InlineDatum, Mint, OutputReference, ScriptContext}\nuse aiken/transaction/value.{flatten, from_minted_value, quantity_of, tokens}\n\ntype TokenRedeemer {\n  TransitionPool {\n    pool_oref: OutputReference,\n    continuing_output: pool.OutputIndex,\n  }\n  CreatePool { produced_output: pool.OutputIndex }\n  DestroyPool { pool_oref: OutputReference }\n}\n\n// Liquidity token is a representation of the pool liquidity.\n\nvalidator(pool_hash: ByteArray, token_name: ByteArray) {\n  fn liquidity_token(redeemer: TokenRedeemer, ctx: ScriptContext) {\n    expect Mint(own_policy) = ctx.purpose\n    when redeemer is {\n      // Deposit or Withdraw redeemer\n      TransitionPool { pool_oref, continuing_output } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(continuing_output)\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let pool_addresses_matches =\n          pool_input.output.address == pool_output.address\n        let id = input_datum.params.pool_nft_name\n\n        let dust_attack_check =\n          when flatten(pool_input.output.value) is {\n            [(_, _, _)] -> False\n            [(_, _, _), (_, _, _)] -> True\n            [(_, _, _), (_, _, _), (_, _, _)] -> True\n            _ -> False\n          }\n        // Makes sure Pool NFT is present as well as it's in the output\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, id) == 1 && quantity_of(\n            pool_output.value,\n            pool_hash,\n            id,\n          ) == 1\n\n        expect [(lp_token_name, lp_tokens_amount)] =\n          tokens(from_minted_value(ctx.transaction.mint), own_policy)\n            |> dict.to_list()\n\n        // LP token name must match LP token name which is also pool Stake-creds hash\n        let valid_lp_token_name =\n          lp_token_name == output_datum.params.pool_nft_name && lp_token_name == token_name\n        let valid_lp_token_change =\n          output_datum.total_lp_tokens - input_datum.total_lp_tokens == lp_tokens_amount\n        and {\n          valid_lp_token_change,\n          valid_lp_token_name,\n          nfts_check,\n          dust_attack_check,\n          pool_addresses_matches,\n        }\n      }\n      DestroyPool { pool_oref } -> {\n        expect Some(pool_input) =\n          ctx.transaction.inputs\n            |> list.find(fn(inp) { inp.output_reference == pool_oref })\n        expect InlineDatum(input_datum) = pool_input.output.datum\n        expect input_datum: pool.Datum = input_datum\n\n        let nfts_check =\n          quantity_of(pool_input.output.value, pool_hash, token_name) == 1\n        let nft_name_datum_check =\n          input_datum.params.pool_nft_name == token_name\n\n        let actual_tokens_minted =\n          quantity_of(\n            from_minted_value(ctx.transaction.mint),\n            own_policy,\n            token_name,\n          )\n\n        let tokens_mint_check =\n          actual_tokens_minted + input_datum.total_lp_tokens == 0\n\n        and {\n          tokens_mint_check?,\n          nfts_check?,\n          nft_name_datum_check?,\n        }\n      }\n      CreatePool { produced_output } -> {\n        expect Some(pool_output) =\n          ctx.transaction.outputs |> list.at(produced_output)\n        expect InlineDatum(output_datum) = pool_output.datum\n        expect output_datum: pool.Datum = output_datum\n        let mint = from_minted_value(ctx.transaction.mint)\n\n        // Expects only one tokenName to be minted\n        expect [(pool_token_name, 1)] = dict.to_list(tokens(mint, pool_hash))\n\n        // Doing an extra check for all the name matching\n        let correct_pooltoken_name = and {\n            pool_token_name == output_datum.params.pool_nft_name,\n            token_name == pool_token_name,\n          }\n\n        let lp_tokens_minted = quantity_of(mint, own_policy, pool_token_name)\n        let depositing_tokens_count_actual =\n          quantity_of(\n            pool_output.value,\n            output_datum.params.loan_cs.policy_id,\n            output_datum.params.loan_cs.asset_name,\n          )\n        let correct_pooltoken_out =\n          quantity_of(pool_output.value, pool_hash, pool_token_name) == 1\n\n        let correct_recorded_lptokens =\n          output_datum.total_lp_tokens == lp_tokens_minted\n\n        let depositing_gt_0 = depositing_tokens_count_actual > 0\n        let depositing_at_script =\n          depositing_tokens_count_actual == output_datum.balance\n\n        let minted_lp_match_deposit =\n          depositing_tokens_count_actual == lp_tokens_minted\n        and {\n          correct_pooltoken_out?,\n          correct_recorded_lptokens?,\n          depositing_gt_0?,\n          depositing_at_script?,\n          minted_lp_match_deposit?,\n          correct_pooltoken_name?,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include a check for the uniqueness of transaction IDs, which allows replay attacks. An attacker could reuse a valid transaction multiple times, as the contract does not verify if a transaction ID has already been processed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/liquidity_token.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is introduced by not properly checking the `transaction.validity_range` in the `spend` function. This allows transactions to be executed outside the intended valid time range, potentially enabling unauthorized or unintended updates to the settings.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug that misuses the time range constraints (`valid_from`, `valid_to`), allowing invalid execution timing."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is introduced in the `mint` function where the `list.filter` function is used to find the `settings_output`. The `expect [settings_output] = list.filter(...)` assumes that the filter will return exactly one output. However, if the list has more than one matching output, this will cause an off-by-one error, as the code expects exactly one match but does not handle the case where there are multiple matches. This can lead to unexpected behavior if the transaction outputs contain more than one output that matches the filter criteria.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is in the `mint` function where the code expects exactly one output that matches the expected mint value. However, it does not check if there are additional outputs beyond the one expected. This allows a transaction to include extra outputs, which could be used to divert funds or tokens without being detected by the current validation logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is in the `spend` function where the `value_not_changed` check compares the values of `own_output.value` and `own_input.value` using `assets.without_lovelace`. This comparison does not handle negative values correctly, allowing transactions with negative asset values to pass this check, potentially leading to unintended behavior or exploitation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is in the `multisig.satisfied` function call, where the `transaction.validity_range` is used. If the validity range is incorrectly interpreted, it could allow transactions to be considered valid outside their intended time frame, potentially enabling unauthorized updates to the settings.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker could reuse a valid transaction to perform unauthorized actions repeatedly.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is introduced by not validating the hash of the `output_datum` against the expected hash derived from the `input_datum`. This allows an attacker to use a different datum with the same structure but different content, potentially bypassing intended restrictions on datum changes.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The check `treasury_output.datum == InlineDatum(Void)` is intended to ensure that the treasury is paid with a null datum. However, using `==` instead of `!=` means that the condition will pass only if the datum is exactly `InlineDatum(Void)`, potentially allowing transactions with non-null datums to pass if they match this condition, which could lead to unintended behavior.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code neglects to verify that the correct signer (pubkey) is present in the transaction. The `multisig.satisfied` function checks if the multisig conditions are met, but it does not explicitly verify that a specific required signer is present in `extra_signatories`. This could allow unauthorized parties to satisfy the multisig conditions without being the intended signer.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is that the `validity_range` is not properly checked for the `Withdrawing` case, allowing transactions to be executed outside the intended time range. This can lead to unauthorized withdrawals if the transaction is processed at an invalid time.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that misuses the time range constraints (`valid_from`, `valid_to`), allowing invalid execution timing."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not check for overflow when calculating `allowance` using `amount_withdrawn * settings_datum.treasury_allowance.1st`. If `amount_withdrawn` and `settings_datum.treasury_allowance.1st` are large enough, this multiplication can overflow, leading to incorrect calculations for `allowance` and `to_treasury`.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is that the code does not validate the number of outputs in the transaction. It assumes there is only one output to the treasury address, but does not enforce this condition. This could allow multiple outputs to the treasury address, potentially leading to incorrect assumptions about the transaction's intent or the distribution of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not handle negative values for `amount_withdrawn` correctly. If `amount_withdrawn` is negative, the calculation for `to_treasury` could result in a negative value, which would incorrectly pass the check `assets.lovelace_of(treasury_output.value) >= to_treasury` if `to_treasury` is negative, allowing unintended transactions to succeed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is in the `multisig.satisfied` function call, where the `validity_range` is passed as a parameter. If the `validity_range` is incorrectly interpreted, it could allow transactions to be considered valid outside their intended time frame, potentially enabling unauthorized transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a valid transaction ID to perform the same transaction multiple times, potentially withdrawing funds repeatedly.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is in the validation of the datum for the treasury output. The condition `treasury_output.datum == InlineDatum(Void)` is intended to ensure that the output is sent with a null datum. However, this check can be bypassed if the datum is not exactly `InlineDatum(Void)` but still effectively null or empty in another form, allowing misuse of datums.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Credential, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value.{PolicyId}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Batching, BatchingPool, GlobalSetting, OrderDatum, PAMSignature,\n  PAMSpendScript, PAMWithdrawScript, PoolBatchingRedeemer, PoolDatum,\n  PoolRedeemer, SwapMultiRouting, SwapRouting, UpdateDynamicFee, UpdatePoolFee,\n  UpdatePoolParameters, UpdatePoolStakeCredential, WithdrawFeeSharing,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n) {\n  fn validate_pool(\n    datum: PoolDatum,\n    redeemer: PoolRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(pool_input_ref) } =\n      context\n    when redeemer is {\n      Batching -> {\n        let Transaction { withdrawals, .. } = transaction\n        let PoolDatum { pool_batching_stake_credential, .. } = datum\n        dict.has_key(withdrawals, pool_batching_stake_credential)\n      }\n      UpdatePoolParameters(action) -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting {\n          pool_fee_updater,\n          pool_stake_key_updater,\n          pool_dynamic_fee_updater,\n          ..\n        } = global_setting\n        let authorizer =\n          when action is {\n            UpdatePoolFee -> pool_fee_updater\n            UpdateDynamicFee -> pool_dynamic_fee_updater\n            UpdatePoolStakeCredential -> pool_stake_key_updater\n          }\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: authorizer,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: authorizer,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_update_pool_parameters(\n            action: action,\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n      WithdrawFeeSharing -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting { fee_sharing_taker, .. } = global_setting\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: fee_sharing_taker,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: fee_sharing_taker,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_withdraw_fee_sharing(\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // The Payment Credential of Pool Validator\n  pool_payment_cred: Credential,\n) {\n  fn validate_pool_batching(\n    redeemer: PoolBatchingRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext {\n      transaction,\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    let Transaction {\n      inputs,\n      outputs,\n      datums,\n      validity_range,\n      mint,\n      reference_inputs,\n      extra_signatories,\n      withdrawals,\n      ..\n    } = transaction\n    let PoolBatchingRedeemer {\n      batcher_index,\n      orders_fee,\n      input_indexes,\n      pool_input_indexes_opt,\n      vol_fees,\n    } = redeemer\n    let global_setting =\n      pool_validation.get_and_validate_global_setting(\n        reference_inputs: reference_inputs,\n        authen_policy_id: authen_policy_id,\n      )\n    let GlobalSetting { batchers, .. } = global_setting\n    let current_time_approximation =\n      utils.must_get_current_time_approximation(validity_range)\n\n    // Due to authorized batchers is a list so we use @batcher_index to save the On-chain cost \n    // on searching the batcher address in this section \n    let batcher_address = utils.list_at_index(batchers, batcher_index)\n    expect and {\n        // Transaction must be executed by the authorized batchers\n        utils.authorize_pool_license(\n          author: batcher_address,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n        ),\n        // Input indexes must not be empty list and be unique\n        utils.is_unique_bytearray_unsorted(input_indexes),\n        // validate Transaction won't mint any assets\n        value.is_zero(value.from_minted_value(mint)),\n      }\n\n    let pool_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: Output { address: addr, .. }, .. } = input\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n    let pool_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: addr, .. } = output\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n\n    // We assume that inputs not belonging to the batcher or liquidity pool are orders. \n    // These inputs' structure will be verified in the @apply_orders function and SwapMultiRouting branch. \n    // We do not force finding the order script hash here, as we allow for the possibility of upgrading the order contract (possibly to Plutus V3).\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: out, .. } = input\n          let Output { address: addr, .. } = out\n          let Address { payment_credential: payment_cred, .. } = addr\n          and {\n            payment_cred != pool_payment_cred,\n            when batcher_address is {\n              PAMSignature(pkh) ->\n                payment_cred != VerificationKeyCredential(pkh)\n              PAMSpendScript(sh) -> payment_cred != ScriptCredential(sh)\n              PAMWithdrawScript(sh) -> payment_cred != ScriptCredential(sh)\n            },\n          }\n        },\n      )\n    // Currently, transaction inputs will be sorted by TxId and TxIndex of UTxO.\n    // We have to calculate indexes of orders inputs sorting by the ASC created time\n    // on the off-chain and on-chain will sort the TxIns by the indexes\n    // Input Indexes in parameter will be the index indexes of @order_inputs\n    let sorted_order_inputs =\n      bytearray.foldr(\n        input_indexes,\n        [],\n        fn(idx, ips) { list.push(ips, utils.list_at_index(order_inputs, idx)) },\n      )\n\n    expect and {\n        // Order Inputs and Input Indexes must have the same length\n        builtin.length_of_bytearray(input_indexes) == list.length(order_inputs),\n        // Pool Inputs & Outputs must have the same length\n        utils.compare_list_length(pool_inputs, pool_outputs),\n      }\n\n    when pool_inputs is {\n      [pool_input] -> {\n        // In case transaction only contains 1 Pool Input & Output, all order types are accepted except SwapMultiRouting\n        let pool_output = pool_outputs |> builtin.head_list\n        expect [vol_fee] = vol_fees\n        let Input { output: pool_in_output, .. } = pool_input\n        let BatchingPool {\n          asset_a,\n          asset_b,\n          lp_asset,\n          trading_fee_a_numerator,\n          trading_fee_b_numerator,\n          fee_sharing_numerator_opt,\n          pool_state_in,\n          pool_state_out,\n        } =\n          pool_validation.get_batching_pool(\n            stake_credential: stake_credential,\n            pool_input: pool_in_output,\n            pool_output: pool_output,\n            authen_policy_id: authen_policy_id,\n            require_total_liquidity_unchange: False,\n            vol_fee: vol_fee,\n          )\n        pool_state_out == order_validation.apply_orders(\n          datum_map: datums,\n          asset_a: asset_a,\n          asset_b: asset_b,\n          lp_asset: lp_asset,\n          trading_fee_a_numerator: trading_fee_a_numerator,\n          trading_fee_b_numerator: trading_fee_b_numerator,\n          fee_sharing_numerator_opt: fee_sharing_numerator_opt,\n          current_time_approximation: current_time_approximation,\n          order_inputs: sorted_order_inputs,\n          all_outputs: outputs,\n          orders_fee: orders_fee,\n          pool_state: pool_state_in,\n        )\n      }\n      [] -> False\n      _ -> {\n        // In case transaction only contains more than 1 Pool Input & Output, only single SwapMultiRouting Order is accepted\n        expect [order_input] = sorted_order_inputs\n        let order_output = outputs |> builtin.head_list\n        expect [order_fee] = orders_fee\n        let Input {\n          output: Output {\n            value: order_in_value,\n            datum: raw_order_in_datum,\n            ..\n          },\n          ..\n        } = order_input\n        let Output { value: order_out_value, .. } = order_output\n        expect order_in_datum: OrderDatum =\n          utils.must_find_script_datum(datums, raw_order_in_datum)\n        let OrderDatum {\n          success_receiver,\n          success_receiver_datum,\n          step: order_step,\n          max_batcher_fee,\n          lp_asset: order_lp_asset,\n          expiry_setting_opt,\n          ..\n        } = order_in_datum\n        expect SwapMultiRouting(routings, swap_amount_option, minimum_receive) =\n          order_step\n        let SwapRouting { lp_asset: first_routing_lp_asset, .. } =\n          routings |> builtin.head_list\n        expect Some(pool_input_indexes) = pool_input_indexes_opt\n        expect and {\n            // max_batcher_fee must be positive\n            max_batcher_fee > 0,\n            // Used Batcher Fee must be positive and less than or equal batcher fee\n            order_fee > 0,\n            order_fee <= max_batcher_fee,\n            // Order Output must be returned to receiver and might have receiver_datum\n            order_validation.validate_order_receiver(\n              receiver: success_receiver,\n              receiver_datum: success_receiver_datum,\n              output: order_output,\n            ),\n            // In case expired setting is turned on, the execution time must not exceed the expired_time\n            when expiry_setting_opt is {\n              None -> True\n              Some((expired_time, _)) ->\n                current_time_approximation <= expired_time\n            },\n            // Order LP Asset must be the first LP Asset on the routing config\n            order_lp_asset == first_routing_lp_asset,\n            // minimum_receive must be positive\n            minimum_receive > 0,\n            // The number of Pool Inputs and Pool Outputs must be the same with _routings_ length\n            utils.compare_list_length(pool_inputs, routings),\n            // Pool Input Indexes must be unique\n            utils.is_unique_bytearray_unsorted(pool_input_indexes),\n            // This contract allows the order routing through at most 3 Pools \n            builtin.length_of_bytearray(pool_input_indexes) <= 3,\n          }\n        let sorted_pool_inputs =\n          bytearray.foldr(\n            pool_input_indexes,\n            [],\n            fn(idx, ps) { list.push(ps, utils.list_at_index(pool_inputs, idx)) },\n          )\n        let batching_pools =\n          utils.zip_with(\n            sorted_pool_inputs,\n            pool_outputs,\n            vol_fees,\n            fn(pool_in, pool_out, vol_fee) {\n              let Input { output: pool_in_output, .. } = pool_in\n              pool_validation.get_batching_pool(\n                stake_credential: stake_credential,\n                pool_input: pool_in_output,\n                pool_output: pool_out,\n                authen_policy_id: authen_policy_id,\n                require_total_liquidity_unchange: True,\n                vol_fee: vol_fee,\n              )\n            },\n          )\n        order_validation.validate_swap_multi_routing_order(\n          pools: batching_pools,\n          routings: routings,\n          order_in_value: order_in_value,\n          order_out_value: order_out_value,\n          swap_amount_option: swap_amount_option,\n          minimum_receive: minimum_receive,\n          used_batcher_fee: order_fee,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by omitting the validation of the token name in the minting process. This allows for unrestricted token minting, as the contract does not check if the token name is valid or authorized, potentially enabling unauthorized minting of tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/pool_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Credential, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value.{PolicyId}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Batching, BatchingPool, GlobalSetting, OrderDatum, PAMSignature,\n  PAMSpendScript, PAMWithdrawScript, PoolBatchingRedeemer, PoolDatum,\n  PoolRedeemer, SwapMultiRouting, SwapRouting, UpdateDynamicFee, UpdatePoolFee,\n  UpdatePoolParameters, UpdatePoolStakeCredential, WithdrawFeeSharing,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n) {\n  fn validate_pool(\n    datum: PoolDatum,\n    redeemer: PoolRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(pool_input_ref) } =\n      context\n    when redeemer is {\n      Batching -> {\n        let Transaction { withdrawals, .. } = transaction\n        let PoolDatum { pool_batching_stake_credential, .. } = datum\n        dict.has_key(withdrawals, pool_batching_stake_credential)\n      }\n      UpdatePoolParameters(action) -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting {\n          pool_fee_updater,\n          pool_stake_key_updater,\n          pool_dynamic_fee_updater,\n          ..\n        } = global_setting\n        let authorizer =\n          when action is {\n            UpdatePoolFee -> pool_fee_updater\n            UpdateDynamicFee -> pool_dynamic_fee_updater\n            UpdatePoolStakeCredential -> pool_stake_key_updater\n          }\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: authorizer,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: authorizer,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_update_pool_parameters(\n            action: action,\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n      WithdrawFeeSharing -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting { fee_sharing_taker, .. } = global_setting\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: fee_sharing_taker,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: fee_sharing_taker,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_withdraw_fee_sharing(\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // The Payment Credential of Pool Validator\n  pool_payment_cred: Credential,\n) {\n  fn validate_pool_batching(\n    redeemer: PoolBatchingRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext {\n      transaction,\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    let Transaction {\n      inputs,\n      outputs,\n      datums,\n      validity_range,\n      mint,\n      reference_inputs,\n      extra_signatories,\n      withdrawals,\n      ..\n    } = transaction\n    let PoolBatchingRedeemer {\n      batcher_index,\n      orders_fee,\n      input_indexes,\n      pool_input_indexes_opt,\n      vol_fees,\n    } = redeemer\n    let global_setting =\n      pool_validation.get_and_validate_global_setting(\n        reference_inputs: reference_inputs,\n        authen_policy_id: authen_policy_id,\n      )\n    let GlobalSetting { batchers, .. } = global_setting\n    let current_time_approximation =\n      utils.must_get_current_time_approximation(validity_range)\n\n    // Due to authorized batchers is a list so we use @batcher_index to save the On-chain cost \n    // on searching the batcher address in this section \n    let batcher_address = utils.list_at_index(batchers, batcher_index)\n    expect and {\n        // Transaction must be executed by the authorized batchers\n        utils.authorize_pool_license(\n          author: batcher_address,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n        ),\n        // Input indexes must not be empty list and be unique\n        utils.is_unique_bytearray_unsorted(input_indexes),\n        // validate Transaction won't mint any assets\n        value.is_zero(value.from_minted_value(mint)),\n      }\n\n    let pool_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: Output { address: addr, .. }, .. } = input\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n    let pool_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: addr, .. } = output\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n\n    // We assume that inputs not belonging to the batcher or liquidity pool are orders. \n    // These inputs' structure will be verified in the @apply_orders function and SwapMultiRouting branch. \n    // We do not force finding the order script hash here, as we allow for the possibility of upgrading the order contract (possibly to Plutus V3).\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: out, .. } = input\n          let Output { address: addr, .. } = out\n          let Address { payment_credential: payment_cred, .. } = addr\n          and {\n            payment_cred != pool_payment_cred,\n            when batcher_address is {\n              PAMSignature(pkh) ->\n                payment_cred != VerificationKeyCredential(pkh)\n              PAMSpendScript(sh) -> payment_cred != ScriptCredential(sh)\n              PAMWithdrawScript(sh) -> payment_cred != ScriptCredential(sh)\n            },\n          }\n        },\n      )\n    // Currently, transaction inputs will be sorted by TxId and TxIndex of UTxO.\n    // We have to calculate indexes of orders inputs sorting by the ASC created time\n    // on the off-chain and on-chain will sort the TxIns by the indexes\n    // Input Indexes in parameter will be the index indexes of @order_inputs\n    let sorted_order_inputs =\n      bytearray.foldr(\n        input_indexes,\n        [],\n        fn(idx, ips) { list.push(ips, utils.list_at_index(order_inputs, idx)) },\n      )\n\n    expect and {\n        // Order Inputs and Input Indexes must have the same length\n        builtin.length_of_bytearray(input_indexes) == list.length(order_inputs),\n        // Pool Inputs & Outputs must have the same length\n        utils.compare_list_length(pool_inputs, pool_outputs),\n      }\n\n    when pool_inputs is {\n      [pool_input] -> {\n        // In case transaction only contains 1 Pool Input & Output, all order types are accepted except SwapMultiRouting\n        let pool_output = pool_outputs |> builtin.head_list\n        expect [vol_fee] = vol_fees\n        let Input { output: pool_in_output, .. } = pool_input\n        let BatchingPool {\n          asset_a,\n          asset_b,\n          lp_asset,\n          trading_fee_a_numerator,\n          trading_fee_b_numerator,\n          fee_sharing_numerator_opt,\n          pool_state_in,\n          pool_state_out,\n        } =\n          pool_validation.get_batching_pool(\n            stake_credential: stake_credential,\n            pool_input: pool_in_output,\n            pool_output: pool_output,\n            authen_policy_id: authen_policy_id,\n            require_total_liquidity_unchange: False,\n            vol_fee: vol_fee,\n          )\n        pool_state_out == order_validation.apply_orders(\n          datum_map: datums,\n          asset_a: asset_a,\n          asset_b: asset_b,\n          lp_asset: lp_asset,\n          trading_fee_a_numerator: trading_fee_a_numerator,\n          trading_fee_b_numerator: trading_fee_b_numerator,\n          fee_sharing_numerator_opt: fee_sharing_numerator_opt,\n          current_time_approximation: current_time_approximation,\n          order_inputs: sorted_order_inputs,\n          all_outputs: outputs,\n          orders_fee: orders_fee,\n          pool_state: pool_state_in,\n        )\n      }\n      [] -> False\n      _ -> {\n        // In case transaction only contains more than 1 Pool Input & Output, only single SwapMultiRouting Order is accepted\n        expect [order_input] = sorted_order_inputs\n        let order_output = outputs |> builtin.head_list\n        expect [order_fee] = orders_fee\n        let Input {\n          output: Output {\n            value: order_in_value,\n            datum: raw_order_in_datum,\n            ..\n          },\n          ..\n        } = order_input\n        let Output { value: order_out_value, .. } = order_output\n        expect order_in_datum: OrderDatum =\n          utils.must_find_script_datum(datums, raw_order_in_datum)\n        let OrderDatum {\n          success_receiver,\n          success_receiver_datum,\n          step: order_step,\n          max_batcher_fee,\n          lp_asset: order_lp_asset,\n          expiry_setting_opt,\n          ..\n        } = order_in_datum\n        expect SwapMultiRouting(routings, swap_amount_option, minimum_receive) =\n          order_step\n        let SwapRouting { lp_asset: first_routing_lp_asset, .. } =\n          routings |> builtin.head_list\n        expect Some(pool_input_indexes) = pool_input_indexes_opt\n        expect and {\n            // max_batcher_fee must be positive\n            max_batcher_fee > 0,\n            // Used Batcher Fee must be positive and less than or equal batcher fee\n            order_fee > 0,\n            order_fee <= max_batcher_fee,\n            // Order Output must be returned to receiver and might have receiver_datum\n            order_validation.validate_order_receiver(\n              receiver: success_receiver,\n              receiver_datum: success_receiver_datum,\n              output: order_output,\n            ),\n            // In case expired setting is turned on, the execution time must not exceed the expired_time\n            when expiry_setting_opt is {\n              None -> True\n              Some((expired_time, _)) ->\n                current_time_approximation <= expired_time\n            },\n            // Order LP Asset must be the first LP Asset on the routing config\n            order_lp_asset == first_routing_lp_asset,\n            // minimum_receive must be positive\n            minimum_receive > 0,\n            // The number of Pool Inputs and Pool Outputs must be the same with _routings_ length\n            utils.compare_list_length(pool_inputs, routings),\n            // Pool Input Indexes must be unique\n            utils.is_unique_bytearray_unsorted(pool_input_indexes),\n            // This contract allows the order routing through at most 3 Pools \n            builtin.length_of_bytearray(pool_input_indexes) <= 3,\n          }\n        let sorted_pool_inputs =\n          bytearray.foldr(\n            pool_input_indexes,\n            [],\n            fn(idx, ps) { list.push(ps, utils.list_at_index(pool_inputs, idx)) },\n          )\n        let batching_pools =\n          utils.zip_with(\n            sorted_pool_inputs,\n            pool_outputs,\n            vol_fees,\n            fn(pool_in, pool_out, vol_fee) {\n              let Input { output: pool_in_output, .. } = pool_in\n              pool_validation.get_batching_pool(\n                stake_credential: stake_credential,\n                pool_input: pool_in_output,\n                pool_output: pool_out,\n                authen_policy_id: authen_policy_id,\n                require_total_liquidity_unchange: True,\n                vol_fee: vol_fee,\n              )\n            },\n          )\n        order_validation.validate_swap_multi_routing_order(\n          pools: batching_pools,\n          routings: routings,\n          order_in_value: order_in_value,\n          order_out_value: order_out_value,\n          swap_amount_option: swap_amount_option,\n          minimum_receive: minimum_receive,\n          used_batcher_fee: order_fee,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `validate_pool` function, specifically in the `when redeemer is` pattern matching. The `Batching` branch does not check if the redeemer is actually of type `Batching`, allowing any redeemer value to be used in this branch. This can lead to unintended logic execution if a different redeemer type is mistakenly or maliciously used.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/pool_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows redeemer values not intended for that branch of logic."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Credential, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value.{PolicyId}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Batching, BatchingPool, GlobalSetting, OrderDatum, PAMSignature,\n  PAMSpendScript, PAMWithdrawScript, PoolBatchingRedeemer, PoolDatum,\n  PoolRedeemer, SwapMultiRouting, SwapRouting, UpdateDynamicFee, UpdatePoolFee,\n  UpdatePoolParameters, UpdatePoolStakeCredential, WithdrawFeeSharing,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n) {\n  fn validate_pool(\n    datum: PoolDatum,\n    redeemer: PoolRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(pool_input_ref) } =\n      context\n    when redeemer is {\n      Batching -> {\n        let Transaction { withdrawals, .. } = transaction\n        let PoolDatum { pool_batching_stake_credential, .. } = datum\n        dict.has_key(withdrawals, pool_batching_stake_credential)\n      }\n      UpdatePoolParameters(action) -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting {\n          pool_fee_updater,\n          pool_stake_key_updater,\n          pool_dynamic_fee_updater,\n          ..\n        } = global_setting\n        let authorizer =\n          when action is {\n            UpdatePoolFee -> pool_fee_updater\n            UpdateDynamicFee -> pool_dynamic_fee_updater\n            UpdatePoolStakeCredential -> pool_stake_key_updater\n          }\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: authorizer,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: authorizer,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_update_pool_parameters(\n            action: action,\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n      WithdrawFeeSharing -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting { fee_sharing_taker, .. } = global_setting\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: fee_sharing_taker,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: fee_sharing_taker,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_withdraw_fee_sharing(\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // The Payment Credential of Pool Validator\n  pool_payment_cred: Credential,\n) {\n  fn validate_pool_batching(\n    redeemer: PoolBatchingRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext {\n      transaction,\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    let Transaction {\n      inputs,\n      outputs,\n      datums,\n      validity_range,\n      mint,\n      reference_inputs,\n      extra_signatories,\n      withdrawals,\n      ..\n    } = transaction\n    let PoolBatchingRedeemer {\n      batcher_index,\n      orders_fee,\n      input_indexes,\n      pool_input_indexes_opt,\n      vol_fees,\n    } = redeemer\n    let global_setting =\n      pool_validation.get_and_validate_global_setting(\n        reference_inputs: reference_inputs,\n        authen_policy_id: authen_policy_id,\n      )\n    let GlobalSetting { batchers, .. } = global_setting\n    let current_time_approximation =\n      utils.must_get_current_time_approximation(validity_range)\n\n    // Due to authorized batchers is a list so we use @batcher_index to save the On-chain cost \n    // on searching the batcher address in this section \n    let batcher_address = utils.list_at_index(batchers, batcher_index)\n    expect and {\n        // Transaction must be executed by the authorized batchers\n        utils.authorize_pool_license(\n          author: batcher_address,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n        ),\n        // Input indexes must not be empty list and be unique\n        utils.is_unique_bytearray_unsorted(input_indexes),\n        // validate Transaction won't mint any assets\n        value.is_zero(value.from_minted_value(mint)),\n      }\n\n    let pool_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: Output { address: addr, .. }, .. } = input\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n    let pool_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: addr, .. } = output\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n\n    // We assume that inputs not belonging to the batcher or liquidity pool are orders. \n    // These inputs' structure will be verified in the @apply_orders function and SwapMultiRouting branch. \n    // We do not force finding the order script hash here, as we allow for the possibility of upgrading the order contract (possibly to Plutus V3).\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: out, .. } = input\n          let Output { address: addr, .. } = out\n          let Address { payment_credential: payment_cred, .. } = addr\n          and {\n            payment_cred != pool_payment_cred,\n            when batcher_address is {\n              PAMSignature(pkh) ->\n                payment_cred != VerificationKeyCredential(pkh)\n              PAMSpendScript(sh) -> payment_cred != ScriptCredential(sh)\n              PAMWithdrawScript(sh) -> payment_cred != ScriptCredential(sh)\n            },\n          }\n        },\n      )\n    // Currently, transaction inputs will be sorted by TxId and TxIndex of UTxO.\n    // We have to calculate indexes of orders inputs sorting by the ASC created time\n    // on the off-chain and on-chain will sort the TxIns by the indexes\n    // Input Indexes in parameter will be the index indexes of @order_inputs\n    let sorted_order_inputs =\n      bytearray.foldr(\n        input_indexes,\n        [],\n        fn(idx, ips) { list.push(ips, utils.list_at_index(order_inputs, idx)) },\n      )\n\n    expect and {\n        // Order Inputs and Input Indexes must have the same length\n        builtin.length_of_bytearray(input_indexes) == list.length(order_inputs),\n        // Pool Inputs & Outputs must have the same length\n        utils.compare_list_length(pool_inputs, pool_outputs),\n      }\n\n    when pool_inputs is {\n      [pool_input] -> {\n        // In case transaction only contains 1 Pool Input & Output, all order types are accepted except SwapMultiRouting\n        let pool_output = pool_outputs |> builtin.head_list\n        expect [vol_fee] = vol_fees\n        let Input { output: pool_in_output, .. } = pool_input\n        let BatchingPool {\n          asset_a,\n          asset_b,\n          lp_asset,\n          trading_fee_a_numerator,\n          trading_fee_b_numerator,\n          fee_sharing_numerator_opt,\n          pool_state_in,\n          pool_state_out,\n        } =\n          pool_validation.get_batching_pool(\n            stake_credential: stake_credential,\n            pool_input: pool_in_output,\n            pool_output: pool_output,\n            authen_policy_id: authen_policy_id,\n            require_total_liquidity_unchange: False,\n            vol_fee: vol_fee,\n          )\n        pool_state_out == order_validation.apply_orders(\n          datum_map: datums,\n          asset_a: asset_a,\n          asset_b: asset_b,\n          lp_asset: lp_asset,\n          trading_fee_a_numerator: trading_fee_a_numerator,\n          trading_fee_b_numerator: trading_fee_b_numerator,\n          fee_sharing_numerator_opt: fee_sharing_numerator_opt,\n          current_time_approximation: current_time_approximation,\n          order_inputs: sorted_order_inputs,\n          all_outputs: outputs,\n          orders_fee: orders_fee,\n          pool_state: pool_state_in,\n        )\n      }\n      [] -> False\n      _ -> {\n        // In case transaction only contains more than 1 Pool Input & Output, only single SwapMultiRouting Order is accepted\n        expect [order_input] = sorted_order_inputs\n        let order_output = outputs |> builtin.head_list\n        expect [order_fee] = orders_fee\n        let Input {\n          output: Output {\n            value: order_in_value,\n            datum: raw_order_in_datum,\n            ..\n          },\n          ..\n        } = order_input\n        let Output { value: order_out_value, .. } = order_output\n        expect order_in_datum: OrderDatum =\n          utils.must_find_script_datum(datums, raw_order_in_datum)\n        let OrderDatum {\n          success_receiver,\n          success_receiver_datum,\n          step: order_step,\n          max_batcher_fee,\n          lp_asset: order_lp_asset,\n          expiry_setting_opt,\n          ..\n        } = order_in_datum\n        expect SwapMultiRouting(routings, swap_amount_option, minimum_receive) =\n          order_step\n        let SwapRouting { lp_asset: first_routing_lp_asset, .. } =\n          routings |> builtin.head_list\n        expect Some(pool_input_indexes) = pool_input_indexes_opt\n        expect and {\n            // max_batcher_fee must be positive\n            max_batcher_fee > 0,\n            // Used Batcher Fee must be positive and less than or equal batcher fee\n            order_fee > 0,\n            order_fee <= max_batcher_fee,\n            // Order Output must be returned to receiver and might have receiver_datum\n            order_validation.validate_order_receiver(\n              receiver: success_receiver,\n              receiver_datum: success_receiver_datum,\n              output: order_output,\n            ),\n            // In case expired setting is turned on, the execution time must not exceed the expired_time\n            when expiry_setting_opt is {\n              None -> True\n              Some((expired_time, _)) ->\n                current_time_approximation <= expired_time\n            },\n            // Order LP Asset must be the first LP Asset on the routing config\n            order_lp_asset == first_routing_lp_asset,\n            // minimum_receive must be positive\n            minimum_receive > 0,\n            // The number of Pool Inputs and Pool Outputs must be the same with _routings_ length\n            utils.compare_list_length(pool_inputs, routings),\n            // Pool Input Indexes must be unique\n            utils.is_unique_bytearray_unsorted(pool_input_indexes),\n            // This contract allows the order routing through at most 3 Pools \n            builtin.length_of_bytearray(pool_input_indexes) <= 3,\n          }\n        let sorted_pool_inputs =\n          bytearray.foldr(\n            pool_input_indexes,\n            [],\n            fn(idx, ps) { list.push(ps, utils.list_at_index(pool_inputs, idx)) },\n          )\n        let batching_pools =\n          utils.zip_with(\n            sorted_pool_inputs,\n            pool_outputs,\n            vol_fees,\n            fn(pool_in, pool_out, vol_fee) {\n              let Input { output: pool_in_output, .. } = pool_in\n              pool_validation.get_batching_pool(\n                stake_credential: stake_credential,\n                pool_input: pool_in_output,\n                pool_output: pool_out,\n                authen_policy_id: authen_policy_id,\n                require_total_liquidity_unchange: True,\n                vol_fee: vol_fee,\n              )\n            },\n          )\n        order_validation.validate_swap_multi_routing_order(\n          pools: batching_pools,\n          routings: routings,\n          order_in_value: order_in_value,\n          order_out_value: order_out_value,\n          swap_amount_option: swap_amount_option,\n          minimum_receive: minimum_receive,\n          used_batcher_fee: order_fee,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `validate_pool_batching` function, within the `order_inputs` filtering logic, the condition `payment_cred != pool_payment_cred` was changed to `payment_cred == pool_payment_cred`. This change causes the function to incorrectly identify inputs as order inputs, potentially allowing unauthorized transactions to be processed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/pool_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Credential, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value.{PolicyId}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Batching, BatchingPool, GlobalSetting, OrderDatum, PAMSignature,\n  PAMSpendScript, PAMWithdrawScript, PoolBatchingRedeemer, PoolDatum,\n  PoolRedeemer, SwapMultiRouting, SwapRouting, UpdateDynamicFee, UpdatePoolFee,\n  UpdatePoolParameters, UpdatePoolStakeCredential, WithdrawFeeSharing,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n) {\n  fn validate_pool(\n    datum: PoolDatum,\n    redeemer: PoolRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(pool_input_ref) } =\n      context\n    when redeemer is {\n      Batching -> {\n        let Transaction { withdrawals, .. } = transaction\n        let PoolDatum { pool_batching_stake_credential, .. } = datum\n        dict.has_key(withdrawals, pool_batching_stake_credential)\n      }\n      UpdatePoolParameters(action) -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting {\n          pool_fee_updater,\n          pool_stake_key_updater,\n          pool_dynamic_fee_updater,\n          ..\n        } = global_setting\n        let authorizer =\n          when action is {\n            UpdatePoolFee -> pool_fee_updater\n            UpdateDynamicFee -> pool_dynamic_fee_updater\n            UpdatePoolStakeCredential -> pool_stake_key_updater\n          }\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: authorizer,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: authorizer,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_update_pool_parameters(\n            action: action,\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n      WithdrawFeeSharing -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting { fee_sharing_taker, .. } = global_setting\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: fee_sharing_taker,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: fee_sharing_taker,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_withdraw_fee_sharing(\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // The Payment Credential of Pool Validator\n  pool_payment_cred: Credential,\n) {\n  fn validate_pool_batching(\n    redeemer: PoolBatchingRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext {\n      transaction,\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    let Transaction {\n      inputs,\n      outputs,\n      datums,\n      validity_range,\n      mint,\n      reference_inputs,\n      extra_signatories,\n      withdrawals,\n      ..\n    } = transaction\n    let PoolBatchingRedeemer {\n      batcher_index,\n      orders_fee,\n      input_indexes,\n      pool_input_indexes_opt,\n      vol_fees,\n    } = redeemer\n    let global_setting =\n      pool_validation.get_and_validate_global_setting(\n        reference_inputs: reference_inputs,\n        authen_policy_id: authen_policy_id,\n      )\n    let GlobalSetting { batchers, .. } = global_setting\n    let current_time_approximation =\n      utils.must_get_current_time_approximation(validity_range)\n\n    // Due to authorized batchers is a list so we use @batcher_index to save the On-chain cost \n    // on searching the batcher address in this section \n    let batcher_address = utils.list_at_index(batchers, batcher_index)\n    expect and {\n        // Transaction must be executed by the authorized batchers\n        utils.authorize_pool_license(\n          author: batcher_address,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n        ),\n        // Input indexes must not be empty list and be unique\n        utils.is_unique_bytearray_unsorted(input_indexes),\n        // validate Transaction won't mint any assets\n        value.is_zero(value.from_minted_value(mint)),\n      }\n\n    let pool_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: Output { address: addr, .. }, .. } = input\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n    let pool_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: addr, .. } = output\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n\n    // We assume that inputs not belonging to the batcher or liquidity pool are orders. \n    // These inputs' structure will be verified in the @apply_orders function and SwapMultiRouting branch. \n    // We do not force finding the order script hash here, as we allow for the possibility of upgrading the order contract (possibly to Plutus V3).\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: out, .. } = input\n          let Output { address: addr, .. } = out\n          let Address { payment_credential: payment_cred, .. } = addr\n          and {\n            payment_cred != pool_payment_cred,\n            when batcher_address is {\n              PAMSignature(pkh) ->\n                payment_cred != VerificationKeyCredential(pkh)\n              PAMSpendScript(sh) -> payment_cred != ScriptCredential(sh)\n              PAMWithdrawScript(sh) -> payment_cred != ScriptCredential(sh)\n            },\n          }\n        },\n      )\n    // Currently, transaction inputs will be sorted by TxId and TxIndex of UTxO.\n    // We have to calculate indexes of orders inputs sorting by the ASC created time\n    // on the off-chain and on-chain will sort the TxIns by the indexes\n    // Input Indexes in parameter will be the index indexes of @order_inputs\n    let sorted_order_inputs =\n      bytearray.foldr(\n        input_indexes,\n        [],\n        fn(idx, ips) { list.push(ips, utils.list_at_index(order_inputs, idx)) },\n      )\n\n    expect and {\n        // Order Inputs and Input Indexes must have the same length\n        builtin.length_of_bytearray(input_indexes) == list.length(order_inputs),\n        // Pool Inputs & Outputs must have the same length\n        utils.compare_list_length(pool_inputs, pool_outputs),\n      }\n\n    when pool_inputs is {\n      [pool_input] -> {\n        // In case transaction only contains 1 Pool Input & Output, all order types are accepted except SwapMultiRouting\n        let pool_output = pool_outputs |> builtin.head_list\n        expect [vol_fee] = vol_fees\n        let Input { output: pool_in_output, .. } = pool_input\n        let BatchingPool {\n          asset_a,\n          asset_b,\n          lp_asset,\n          trading_fee_a_numerator,\n          trading_fee_b_numerator,\n          fee_sharing_numerator_opt,\n          pool_state_in,\n          pool_state_out,\n        } =\n          pool_validation.get_batching_pool(\n            stake_credential: stake_credential,\n            pool_input: pool_in_output,\n            pool_output: pool_output,\n            authen_policy_id: authen_policy_id,\n            require_total_liquidity_unchange: False,\n            vol_fee: vol_fee,\n          )\n        pool_state_out == order_validation.apply_orders(\n          datum_map: datums,\n          asset_a: asset_a,\n          asset_b: asset_b,\n          lp_asset: lp_asset,\n          trading_fee_a_numerator: trading_fee_a_numerator,\n          trading_fee_b_numerator: trading_fee_b_numerator,\n          fee_sharing_numerator_opt: fee_sharing_numerator_opt,\n          current_time_approximation: current_time_approximation,\n          order_inputs: sorted_order_inputs,\n          all_outputs: outputs,\n          orders_fee: orders_fee,\n          pool_state: pool_state_in,\n        )\n      }\n      [] -> False\n      _ -> {\n        // In case transaction only contains more than 1 Pool Input & Output, only single SwapMultiRouting Order is accepted\n        expect [order_input] = sorted_order_inputs\n        let order_output = outputs |> builtin.head_list\n        expect [order_fee] = orders_fee\n        let Input {\n          output: Output {\n            value: order_in_value,\n            datum: raw_order_in_datum,\n            ..\n          },\n          ..\n        } = order_input\n        let Output { value: order_out_value, .. } = order_output\n        expect order_in_datum: OrderDatum =\n          utils.must_find_script_datum(datums, raw_order_in_datum)\n        let OrderDatum {\n          success_receiver,\n          success_receiver_datum,\n          step: order_step,\n          max_batcher_fee,\n          lp_asset: order_lp_asset,\n          expiry_setting_opt,\n          ..\n        } = order_in_datum\n        expect SwapMultiRouting(routings, swap_amount_option, minimum_receive) =\n          order_step\n        let SwapRouting { lp_asset: first_routing_lp_asset, .. } =\n          routings |> builtin.head_list\n        expect Some(pool_input_indexes) = pool_input_indexes_opt\n        expect and {\n            // max_batcher_fee must be positive\n            max_batcher_fee > 0,\n            // Used Batcher Fee must be positive and less than or equal batcher fee\n            order_fee > 0,\n            order_fee <= max_batcher_fee,\n            // Order Output must be returned to receiver and might have receiver_datum\n            order_validation.validate_order_receiver(\n              receiver: success_receiver,\n              receiver_datum: success_receiver_datum,\n              output: order_output,\n            ),\n            // In case expired setting is turned on, the execution time must not exceed the expired_time\n            when expiry_setting_opt is {\n              None -> True\n              Some((expired_time, _)) ->\n                current_time_approximation <= expired_time\n            },\n            // Order LP Asset must be the first LP Asset on the routing config\n            order_lp_asset == first_routing_lp_asset,\n            // minimum_receive must be positive\n            minimum_receive > 0,\n            // The number of Pool Inputs and Pool Outputs must be the same with _routings_ length\n            utils.compare_list_length(pool_inputs, routings),\n            // Pool Input Indexes must be unique\n            utils.is_unique_bytearray_unsorted(pool_input_indexes),\n            // This contract allows the order routing through at most 3 Pools \n            builtin.length_of_bytearray(pool_input_indexes) <= 3,\n          }\n        let sorted_pool_inputs =\n          bytearray.foldr(\n            pool_input_indexes,\n            [],\n            fn(idx, ps) { list.push(ps, utils.list_at_index(pool_inputs, idx)) },\n          )\n        let batching_pools =\n          utils.zip_with(\n            sorted_pool_inputs,\n            pool_outputs,\n            vol_fees,\n            fn(pool_in, pool_out, vol_fee) {\n              let Input { output: pool_in_output, .. } = pool_in\n              pool_validation.get_batching_pool(\n                stake_credential: stake_credential,\n                pool_input: pool_in_output,\n                pool_output: pool_out,\n                authen_policy_id: authen_policy_id,\n                require_total_liquidity_unchange: True,\n                vol_fee: vol_fee,\n              )\n            },\n          )\n        order_validation.validate_swap_multi_routing_order(\n          pools: batching_pools,\n          routings: routings,\n          order_in_value: order_in_value,\n          order_out_value: order_out_value,\n          swap_amount_option: swap_amount_option,\n          minimum_receive: minimum_receive,\n          used_batcher_fee: order_fee,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `order_inputs` filtering logic. The condition `payment_cred != pool_payment_cred` is used to filter out inputs that do not belong to the pool or batcher. However, the condition for `PAMSpendScript(sh)` and `PAMWithdrawScript(sh)` is not correctly validated, allowing incorrect script usage. This can lead to unauthorized scripts being used in transactions, bypassing the intended security checks.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/pool_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to validate the spending script hash, allowing incorrect script usage."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Credential, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value.{PolicyId}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Batching, BatchingPool, GlobalSetting, OrderDatum, PAMSignature,\n  PAMSpendScript, PAMWithdrawScript, PoolBatchingRedeemer, PoolDatum,\n  PoolRedeemer, SwapMultiRouting, SwapRouting, UpdateDynamicFee, UpdatePoolFee,\n  UpdatePoolParameters, UpdatePoolStakeCredential, WithdrawFeeSharing,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n) {\n  fn validate_pool(\n    datum: PoolDatum,\n    redeemer: PoolRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(pool_input_ref) } =\n      context\n    when redeemer is {\n      Batching -> {\n        let Transaction { withdrawals, .. } = transaction\n        let PoolDatum { pool_batching_stake_credential, .. } = datum\n        dict.has_key(withdrawals, pool_batching_stake_credential)\n      }\n      UpdatePoolParameters(action) -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting {\n          pool_fee_updater,\n          pool_stake_key_updater,\n          pool_dynamic_fee_updater,\n          ..\n        } = global_setting\n        let authorizer =\n          when action is {\n            UpdatePoolFee -> pool_fee_updater\n            UpdateDynamicFee -> pool_dynamic_fee_updater\n            UpdatePoolStakeCredential -> pool_stake_key_updater\n          }\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: authorizer,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: authorizer,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_update_pool_parameters(\n            action: action,\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n      WithdrawFeeSharing -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting { fee_sharing_taker, .. } = global_setting\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: fee_sharing_taker,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: fee_sharing_taker,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_withdraw_fee_sharing(\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // The Payment Credential of Pool Validator\n  pool_payment_cred: Credential,\n) {\n  fn validate_pool_batching(\n    redeemer: PoolBatchingRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext {\n      transaction,\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    let Transaction {\n      inputs,\n      outputs,\n      datums,\n      validity_range,\n      mint,\n      reference_inputs,\n      extra_signatories,\n      withdrawals,\n      ..\n    } = transaction\n    let PoolBatchingRedeemer {\n      batcher_index,\n      orders_fee,\n      input_indexes,\n      pool_input_indexes_opt,\n      vol_fees,\n    } = redeemer\n    let global_setting =\n      pool_validation.get_and_validate_global_setting(\n        reference_inputs: reference_inputs,\n        authen_policy_id: authen_policy_id,\n      )\n    let GlobalSetting { batchers, .. } = global_setting\n    let current_time_approximation =\n      utils.must_get_current_time_approximation(validity_range)\n\n    // Due to authorized batchers is a list so we use @batcher_index to save the On-chain cost \n    // on searching the batcher address in this section \n    let batcher_address = utils.list_at_index(batchers, batcher_index)\n    expect and {\n        // Transaction must be executed by the authorized batchers\n        utils.authorize_pool_license(\n          author: batcher_address,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n        ),\n        // Input indexes must not be empty list and be unique\n        utils.is_unique_bytearray_unsorted(input_indexes),\n        // validate Transaction won't mint any assets\n        value.is_zero(value.from_minted_value(mint)),\n      }\n\n    let pool_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: Output { address: addr, .. }, .. } = input\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n    let pool_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: addr, .. } = output\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n\n    // We assume that inputs not belonging to the batcher or liquidity pool are orders. \n    // These inputs' structure will be verified in the @apply_orders function and SwapMultiRouting branch. \n    // We do not force finding the order script hash here, as we allow for the possibility of upgrading the order contract (possibly to Plutus V3).\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: out, .. } = input\n          let Output { address: addr, .. } = out\n          let Address { payment_credential: payment_cred, .. } = addr\n          and {\n            payment_cred != pool_payment_cred,\n            when batcher_address is {\n              PAMSignature(pkh) ->\n                payment_cred != VerificationKeyCredential(pkh)\n              PAMSpendScript(sh) -> payment_cred != ScriptCredential(sh)\n              PAMWithdrawScript(sh) -> payment_cred != ScriptCredential(sh)\n            },\n          }\n        },\n      )\n    // Currently, transaction inputs will be sorted by TxId and TxIndex of UTxO.\n    // We have to calculate indexes of orders inputs sorting by the ASC created time\n    // on the off-chain and on-chain will sort the TxIns by the indexes\n    // Input Indexes in parameter will be the index indexes of @order_inputs\n    let sorted_order_inputs =\n      bytearray.foldr(\n        input_indexes,\n        [],\n        fn(idx, ips) { list.push(ips, utils.list_at_index(order_inputs, idx)) },\n      )\n\n    expect and {\n        // Order Inputs and Input Indexes must have the same length\n        builtin.length_of_bytearray(input_indexes) == list.length(order_inputs),\n        // Pool Inputs & Outputs must have the same length\n        utils.compare_list_length(pool_inputs, pool_outputs),\n      }\n\n    when pool_inputs is {\n      [pool_input] -> {\n        // In case transaction only contains 1 Pool Input & Output, all order types are accepted except SwapMultiRouting\n        let pool_output = pool_outputs |> builtin.head_list\n        expect [vol_fee] = vol_fees\n        let Input { output: pool_in_output, .. } = pool_input\n        let BatchingPool {\n          asset_a,\n          asset_b,\n          lp_asset,\n          trading_fee_a_numerator,\n          trading_fee_b_numerator,\n          fee_sharing_numerator_opt,\n          pool_state_in,\n          pool_state_out,\n        } =\n          pool_validation.get_batching_pool(\n            stake_credential: stake_credential,\n            pool_input: pool_in_output,\n            pool_output: pool_output,\n            authen_policy_id: authen_policy_id,\n            require_total_liquidity_unchange: False,\n            vol_fee: vol_fee,\n          )\n        pool_state_out == order_validation.apply_orders(\n          datum_map: datums,\n          asset_a: asset_a,\n          asset_b: asset_b,\n          lp_asset: lp_asset,\n          trading_fee_a_numerator: trading_fee_a_numerator,\n          trading_fee_b_numerator: trading_fee_b_numerator,\n          fee_sharing_numerator_opt: fee_sharing_numerator_opt,\n          current_time_approximation: current_time_approximation,\n          order_inputs: sorted_order_inputs,\n          all_outputs: outputs,\n          orders_fee: orders_fee,\n          pool_state: pool_state_in,\n        )\n      }\n      [] -> False\n      _ -> {\n        // In case transaction only contains more than 1 Pool Input & Output, only single SwapMultiRouting Order is accepted\n        expect [order_input] = sorted_order_inputs\n        let order_output = outputs |> builtin.head_list\n        expect [order_fee] = orders_fee\n        let Input {\n          output: Output {\n            value: order_in_value,\n            datum: raw_order_in_datum,\n            ..\n          },\n          ..\n        } = order_input\n        let Output { value: order_out_value, .. } = order_output\n        expect order_in_datum: OrderDatum =\n          utils.must_find_script_datum(datums, raw_order_in_datum)\n        let OrderDatum {\n          success_receiver,\n          success_receiver_datum,\n          step: order_step,\n          max_batcher_fee,\n          lp_asset: order_lp_asset,\n          expiry_setting_opt,\n          ..\n        } = order_in_datum\n        expect SwapMultiRouting(routings, swap_amount_option, minimum_receive) =\n          order_step\n        let SwapRouting { lp_asset: first_routing_lp_asset, .. } =\n          routings |> builtin.head_list\n        expect Some(pool_input_indexes) = pool_input_indexes_opt\n        expect and {\n            // max_batcher_fee must be positive\n            max_batcher_fee > 0,\n            // Used Batcher Fee must be positive and less than or equal batcher fee\n            order_fee > 0,\n            order_fee <= max_batcher_fee,\n            // Order Output must be returned to receiver and might have receiver_datum\n            order_validation.validate_order_receiver(\n              receiver: success_receiver,\n              receiver_datum: success_receiver_datum,\n              output: order_output,\n            ),\n            // In case expired setting is turned on, the execution time must not exceed the expired_time\n            when expiry_setting_opt is {\n              None -> True\n              Some((expired_time, _)) ->\n                current_time_approximation <= expired_time\n            },\n            // Order LP Asset must be the first LP Asset on the routing config\n            order_lp_asset == first_routing_lp_asset,\n            // minimum_receive must be positive\n            minimum_receive > 0,\n            // The number of Pool Inputs and Pool Outputs must be the same with _routings_ length\n            utils.compare_list_length(pool_inputs, routings),\n            // Pool Input Indexes must be unique\n            utils.is_unique_bytearray_unsorted(pool_input_indexes),\n            // This contract allows the order routing through at most 3 Pools \n            builtin.length_of_bytearray(pool_input_indexes) <= 3,\n          }\n        let sorted_pool_inputs =\n          bytearray.foldr(\n            pool_input_indexes,\n            [],\n            fn(idx, ps) { list.push(ps, utils.list_at_index(pool_inputs, idx)) },\n          )\n        let batching_pools =\n          utils.zip_with(\n            sorted_pool_inputs,\n            pool_outputs,\n            vol_fees,\n            fn(pool_in, pool_out, vol_fee) {\n              let Input { output: pool_in_output, .. } = pool_in\n              pool_validation.get_batching_pool(\n                stake_credential: stake_credential,\n                pool_input: pool_in_output,\n                pool_output: pool_out,\n                authen_policy_id: authen_policy_id,\n                require_total_liquidity_unchange: True,\n                vol_fee: vol_fee,\n              )\n            },\n          )\n        order_validation.validate_swap_multi_routing_order(\n          pools: batching_pools,\n          routings: routings,\n          order_in_value: order_in_value,\n          order_out_value: order_out_value,\n          swap_amount_option: swap_amount_option,\n          minimum_receive: minimum_receive,\n          used_batcher_fee: order_fee,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by removing the bounds check for the `batcher_index` when accessing the `batchers` list. This can lead to a numeric overflow or underflow if `batcher_index` is out of the valid range, potentially causing the contract to behave unexpectedly or fail.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/pool_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Credential, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value.{PolicyId}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Batching, BatchingPool, GlobalSetting, OrderDatum, PAMSignature,\n  PAMSpendScript, PAMWithdrawScript, PoolBatchingRedeemer, PoolDatum,\n  PoolRedeemer, SwapMultiRouting, SwapRouting, UpdateDynamicFee, UpdatePoolFee,\n  UpdatePoolParameters, UpdatePoolStakeCredential, WithdrawFeeSharing,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n) {\n  fn validate_pool(\n    datum: PoolDatum,\n    redeemer: PoolRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(pool_input_ref) } =\n      context\n    when redeemer is {\n      Batching -> {\n        let Transaction { withdrawals, .. } = transaction\n        let PoolDatum { pool_batching_stake_credential, .. } = datum\n        dict.has_key(withdrawals, pool_batching_stake_credential)\n      }\n      UpdatePoolParameters(action) -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting {\n          pool_fee_updater,\n          pool_stake_key_updater,\n          pool_dynamic_fee_updater,\n          ..\n        } = global_setting\n        let authorizer =\n          when action is {\n            UpdatePoolFee -> pool_fee_updater\n            UpdateDynamicFee -> pool_dynamic_fee_updater\n            UpdatePoolStakeCredential -> pool_stake_key_updater\n          }\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: authorizer,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: authorizer,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_update_pool_parameters(\n            action: action,\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n      WithdrawFeeSharing -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting { fee_sharing_taker, .. } = global_setting\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: fee_sharing_taker,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: fee_sharing_taker,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_withdraw_fee_sharing(\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // The Payment Credential of Pool Validator\n  pool_payment_cred: Credential,\n) {\n  fn validate_pool_batching(\n    redeemer: PoolBatchingRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext {\n      transaction,\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    let Transaction {\n      inputs,\n      outputs,\n      datums,\n      validity_range,\n      mint,\n      reference_inputs,\n      extra_signatories,\n      withdrawals,\n      ..\n    } = transaction\n    let PoolBatchingRedeemer {\n      batcher_index,\n      orders_fee,\n      input_indexes,\n      pool_input_indexes_opt,\n      vol_fees,\n    } = redeemer\n    let global_setting =\n      pool_validation.get_and_validate_global_setting(\n        reference_inputs: reference_inputs,\n        authen_policy_id: authen_policy_id,\n      )\n    let GlobalSetting { batchers, .. } = global_setting\n    let current_time_approximation =\n      utils.must_get_current_time_approximation(validity_range)\n\n    // Due to authorized batchers is a list so we use @batcher_index to save the On-chain cost \n    // on searching the batcher address in this section \n    let batcher_address = utils.list_at_index(batchers, batcher_index)\n    expect and {\n        // Transaction must be executed by the authorized batchers\n        utils.authorize_pool_license(\n          author: batcher_address,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n        ),\n        // Input indexes must not be empty list and be unique\n        utils.is_unique_bytearray_unsorted(input_indexes),\n        // validate Transaction won't mint any assets\n        value.is_zero(value.from_minted_value(mint)),\n      }\n\n    let pool_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: Output { address: addr, .. }, .. } = input\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n    let pool_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: addr, .. } = output\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n\n    // We assume that inputs not belonging to the batcher or liquidity pool are orders. \n    // These inputs' structure will be verified in the @apply_orders function and SwapMultiRouting branch. \n    // We do not force finding the order script hash here, as we allow for the possibility of upgrading the order contract (possibly to Plutus V3).\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: out, .. } = input\n          let Output { address: addr, .. } = out\n          let Address { payment_credential: payment_cred, .. } = addr\n          and {\n            payment_cred != pool_payment_cred,\n            when batcher_address is {\n              PAMSignature(pkh) ->\n                payment_cred != VerificationKeyCredential(pkh)\n              PAMSpendScript(sh) -> payment_cred != ScriptCredential(sh)\n              PAMWithdrawScript(sh) -> payment_cred != ScriptCredential(sh)\n            },\n          }\n        },\n      )\n    // Currently, transaction inputs will be sorted by TxId and TxIndex of UTxO.\n    // We have to calculate indexes of orders inputs sorting by the ASC created time\n    // on the off-chain and on-chain will sort the TxIns by the indexes\n    // Input Indexes in parameter will be the index indexes of @order_inputs\n    let sorted_order_inputs =\n      bytearray.foldr(\n        input_indexes,\n        [],\n        fn(idx, ips) { list.push(ips, utils.list_at_index(order_inputs, idx)) },\n      )\n\n    expect and {\n        // Order Inputs and Input Indexes must have the same length\n        builtin.length_of_bytearray(input_indexes) == list.length(order_inputs),\n        // Pool Inputs & Outputs must have the same length\n        utils.compare_list_length(pool_inputs, pool_outputs),\n      }\n\n    when pool_inputs is {\n      [pool_input] -> {\n        // In case transaction only contains 1 Pool Input & Output, all order types are accepted except SwapMultiRouting\n        let pool_output = pool_outputs |> builtin.head_list\n        expect [vol_fee] = vol_fees\n        let Input { output: pool_in_output, .. } = pool_input\n        let BatchingPool {\n          asset_a,\n          asset_b,\n          lp_asset,\n          trading_fee_a_numerator,\n          trading_fee_b_numerator,\n          fee_sharing_numerator_opt,\n          pool_state_in,\n          pool_state_out,\n        } =\n          pool_validation.get_batching_pool(\n            stake_credential: stake_credential,\n            pool_input: pool_in_output,\n            pool_output: pool_output,\n            authen_policy_id: authen_policy_id,\n            require_total_liquidity_unchange: False,\n            vol_fee: vol_fee,\n          )\n        pool_state_out == order_validation.apply_orders(\n          datum_map: datums,\n          asset_a: asset_a,\n          asset_b: asset_b,\n          lp_asset: lp_asset,\n          trading_fee_a_numerator: trading_fee_a_numerator,\n          trading_fee_b_numerator: trading_fee_b_numerator,\n          fee_sharing_numerator_opt: fee_sharing_numerator_opt,\n          current_time_approximation: current_time_approximation,\n          order_inputs: sorted_order_inputs,\n          all_outputs: outputs,\n          orders_fee: orders_fee,\n          pool_state: pool_state_in,\n        )\n      }\n      [] -> False\n      _ -> {\n        // In case transaction only contains more than 1 Pool Input & Output, only single SwapMultiRouting Order is accepted\n        expect [order_input] = sorted_order_inputs\n        let order_output = outputs |> builtin.head_list\n        expect [order_fee] = orders_fee\n        let Input {\n          output: Output {\n            value: order_in_value,\n            datum: raw_order_in_datum,\n            ..\n          },\n          ..\n        } = order_input\n        let Output { value: order_out_value, .. } = order_output\n        expect order_in_datum: OrderDatum =\n          utils.must_find_script_datum(datums, raw_order_in_datum)\n        let OrderDatum {\n          success_receiver,\n          success_receiver_datum,\n          step: order_step,\n          max_batcher_fee,\n          lp_asset: order_lp_asset,\n          expiry_setting_opt,\n          ..\n        } = order_in_datum\n        expect SwapMultiRouting(routings, swap_amount_option, minimum_receive) =\n          order_step\n        let SwapRouting { lp_asset: first_routing_lp_asset, .. } =\n          routings |> builtin.head_list\n        expect Some(pool_input_indexes) = pool_input_indexes_opt\n        expect and {\n            // max_batcher_fee must be positive\n            max_batcher_fee > 0,\n            // Used Batcher Fee must be positive and less than or equal batcher fee\n            order_fee > 0,\n            order_fee <= max_batcher_fee,\n            // Order Output must be returned to receiver and might have receiver_datum\n            order_validation.validate_order_receiver(\n              receiver: success_receiver,\n              receiver_datum: success_receiver_datum,\n              output: order_output,\n            ),\n            // In case expired setting is turned on, the execution time must not exceed the expired_time\n            when expiry_setting_opt is {\n              None -> True\n              Some((expired_time, _)) ->\n                current_time_approximation <= expired_time\n            },\n            // Order LP Asset must be the first LP Asset on the routing config\n            order_lp_asset == first_routing_lp_asset,\n            // minimum_receive must be positive\n            minimum_receive > 0,\n            // The number of Pool Inputs and Pool Outputs must be the same with _routings_ length\n            utils.compare_list_length(pool_inputs, routings),\n            // Pool Input Indexes must be unique\n            utils.is_unique_bytearray_unsorted(pool_input_indexes),\n            // This contract allows the order routing through at most 3 Pools \n            builtin.length_of_bytearray(pool_input_indexes) <= 3,\n          }\n        let sorted_pool_inputs =\n          bytearray.foldr(\n            pool_input_indexes,\n            [],\n            fn(idx, ps) { list.push(ps, utils.list_at_index(pool_inputs, idx)) },\n          )\n        let batching_pools =\n          utils.zip_with(\n            sorted_pool_inputs,\n            pool_outputs,\n            vol_fees,\n            fn(pool_in, pool_out, vol_fee) {\n              let Input { output: pool_in_output, .. } = pool_in\n              pool_validation.get_batching_pool(\n                stake_credential: stake_credential,\n                pool_input: pool_in_output,\n                pool_output: pool_out,\n                authen_policy_id: authen_policy_id,\n                require_total_liquidity_unchange: True,\n                vol_fee: vol_fee,\n              )\n            },\n          )\n        order_validation.validate_swap_multi_routing_order(\n          pools: batching_pools,\n          routings: routings,\n          order_in_value: order_in_value,\n          order_out_value: order_out_value,\n          swap_amount_option: swap_amount_option,\n          minimum_receive: minimum_receive,\n          used_batcher_fee: order_fee,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `validate_pool_batching` function, specifically in the line where the `order_in_datum` is extracted. The function `utils.must_find_script_datum(datums, raw_order_in_datum)` is used to find the datum, but it should have been validated against a specific hash or reference to ensure its integrity. This omission allows for the possibility of using an incorrect or manipulated datum, which can lead to misuse of datums in the contract.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/pool_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Address, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{Input, Output, Transaction}\n\nvalidator btc(scriptHash: ByteArray) {\n  mint(_redeemer: Data, _policy: PolicyId, self: Transaction) {\n    is_sc_present(self.inputs, scriptHash)\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn is_sc_present(inputs: List<Input>, sc_hash: ByteArray) {\n  list.any(\n    inputs,\n    fn(input) { input.output.address.payment_credential == Script(sc_hash) },\n  )\n}", "bug_explanation": "The code checks if the script hash is present in the transaction inputs but does not verify that the correct signer (pubkey) is present in the transaction. This omission allows transactions to be validated without ensuring that the intended signer has authorized them.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aada/types.{AssetClass}\nuse aada/types/leftovers.{LeftoversDatum}\nuse aada/utils\nuse aiken/transaction.{ScriptContext}\n\n// You can spend from this contract whenever NFT is burned. \n// Only one NFT per transaction\n// Contract is used to save deployed validators when creating the pool and to save Borrowers remaining collateral after liquidation\nvalidator {\n  fn leftovers(datum: LeftoversDatum, _r: Void, ctx: ScriptContext) {\n    let AssetClass { policy_id, asset_name } = datum\n    utils.validate_mint_nft(ctx.transaction.mint, policy_id, asset_name, -1)\n  }\n}", "bug_explanation": "The code does not enforce any size or structural constraints on the `datum` parameter of type `LeftoversDatum`. This allows any datum that can be cast to `LeftoversDatum` to be accepted, potentially leading to unexpected behavior if the datum does not conform to the expected structure or size.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/leftovers.ak", "language": "ak", "bug_prompt": "Introduce a bug that accepts datum without enforcing size or structural constraints."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/option.{is_some}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{\n  Address, Credential, Script, from_script, from_verification_key,\n  with_delegation_key, with_delegation_script,\n}\nuse cardano/assets.{from_asset, from_lovelace, merge, negate, quantity_of, zero}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n  find_input,\n}\nuse constants\nuse redeemer.{Merge, Redeemer, Send, Stake}\n\nvalidator global(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(\n        signature,\n        utxos,\n        policy,\n        assetname,\n        amount,\n        policyInput,\n        assetnameInput,\n        amountInput,\n        spendingscriptflag,\n        pubkey,\n        stakingscriptflag,\n        stakekey,\n        datumflag,\n        datum,\n        payment_index,\n        fee,\n        signer,\n      ) -> {\n        let list_utxos =\n          list.foldr(\n            utxos,\n            [],\n            fn(utxo, xs) {\n              [\n                utxo.transaction_id,\n                bytearray.from_int_big_endian(utxo.output_index, 1),\n                ..xs\n              ]\n            },\n          )\n        expect datum_converted: ByteArray = datum\n        let message_array: List<ByteArray> =\n          list.push([], bytearray.from_int_big_endian(fee, 20))\n            |> list.push(bytearray.from_int_big_endian(payment_index, 1))\n            |> list.push(datum_converted)\n            |> list.push(bytearray.from_int_big_endian(datumflag, 1))\n            |> list.push(stakekey)\n            |> list.push(bytearray.from_int_big_endian(stakingscriptflag, 1))\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(spendingscriptflag, 1))\n            |> list.push(bytearray.from_int_big_endian(amountInput, 20))\n            |> list.push(assetnameInput)\n            |> list.push(policyInput)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n\n        let concat_array = concat_array(list.concat(list_utxos, message_array))\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_array)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_array)\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n        let incoming_value =\n          if amountInput > 0 {\n            from_asset(policy, assetname, amount)\n          } else {\n            zero\n          }\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, payment_index)\n\n        let starting_value =\n          find_inputs_value(self.inputs, contract_input.output.address)\n        let final_value =\n          find_outputs_value(self.outputs, contract_input.output.address)\n\n        let flag_utxo_present = list.has(utxos, own_ref)\n\n        let basic_validation = and {\n            flag_utxo_present,\n            or {\n              validate_signature_key(pubKey, message_hash_btc, signature),\n              validate_signature_key(pubKey, message_hash_eth, signature),\n            },\n          }\n        //Check 1) The output is sending the right amount\n        //Check 2) It is returning the right amount\n        //Check 3) Is the right receiver\n        //Check 4) Has the datum?\n        //Check 5) Are all inputs in utxos present? This is important otherwise I could cancel something random\n        //Check 6) Inputs that were not willing to be inside are from the same address and is a user\n        //7)Issue now is the expected value coming, this is something we want to sign also? Add input value signed and we are done\n        //Let's limit the max amount of outputs to the same wallet, otherwise someone could split all my ada in so many utxos making hard to spend them\n        let expected_datum = calculate_datum(datumflag, datum)\n        let expected_address =\n          calculate_address(\n            spendingscriptflag,\n            stakingscriptflag,\n            pubkey,\n            stakekey,\n          )\n        and {\n          quantity_of(payment_output.value, policy, assetname) == quantity_of(\n            sending_value,\n            policy,\n            assetname,\n          ),\n          assets.match(\n            final_value,\n            merge(\n              merge(\n                merge(starting_value, negate(sending_value)),\n                incoming_value,\n              ),\n              negate(from_lovelace(fee)),\n            ),\n            >=,\n          ),\n          basic_validation,\n          payment_output.address == expected_address,\n          payment_output.datum == expected_datum,\n          all_inputs_present(utxos, self.inputs),\n          only_external_signer_inputs_extra(utxos, self.inputs, signer),\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address == (\n            from_script(hash) |> with_delegation_script(hash)\n          ),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_message)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        and {\n          or {\n            validate_signature_key(pubKey, message_hash_btc, signature),\n            validate_signature_key(pubKey, message_hash_eth, signature),\n          },\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray_btc(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_btc)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn get_hash_from_bytearray_eth(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_eth)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n\nfn find_inputs_value(inputs: List<Input>, sc_address: Address) {\n  list.foldl(\n    inputs,\n    zero,\n    fn(input, total) {\n      if input.output.address == sc_address {\n        merge(input.output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\nfn find_outputs_value(outputs: List<Output>, sc_address: Address) {\n  list.foldl(\n    outputs,\n    zero,\n    fn(output, total) {\n      if output.address == sc_address {\n        merge(output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\npub fn calculate_address(\n  flag_spending_script: Int,\n  flag_staking_script: Int,\n  pubkey: ByteArray,\n  stakekey: ByteArray,\n) -> Address {\n  if flag_spending_script == 0 && flag_staking_script == 0 {\n    from_verification_key(pubkey) |> with_delegation_key(stakekey)\n  } else {\n    if flag_spending_script == 0 && flag_staking_script == 1 {\n      from_verification_key(pubkey) |> with_delegation_script(stakekey)\n    } else {\n      if flag_spending_script == 1 && flag_staking_script == 0 {\n        from_script(pubkey) |> with_delegation_key(stakekey)\n      } else {\n        if flag_spending_script == 1 && flag_staking_script == 1 {\n          from_script(pubkey) |> with_delegation_script(stakekey)\n        } else {\n          from_verification_key(pubkey) |> with_delegation_key(stakekey)\n        }\n      }\n    }\n  }\n}\n\npub fn calculate_datum(flag_datum: Int, datum: Data) -> Datum {\n  if flag_datum == 0 {\n    NoDatum\n  } else {\n    InlineDatum(datum)\n  }\n}\n\npub fn all_inputs_present(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n) {\n  list.all(utxos_chosen, fn(input) { is_some(find_input(real_utxos, input)) })\n}\n\npub fn only_external_signer_inputs_extra(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n  address_signer: Address,\n) {\n  let list_external =\n    list.filter(\n      real_utxos,\n      fn(input) { !list.has(utxos_chosen, input.output_reference) },\n    )\n  list.all(list_external, fn(input) { input.output.address == address_signer })\n}", "bug_explanation": "The code omits validation of the `assetname` when creating the `sending_value` and `incoming_value`. This allows tokens to be minted without checking if the `assetname` is valid, potentially enabling unrestricted token minting.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/global.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/option.{is_some}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{\n  Address, Credential, Script, from_script, from_verification_key,\n  with_delegation_key, with_delegation_script,\n}\nuse cardano/assets.{from_asset, from_lovelace, merge, negate, quantity_of, zero}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n  find_input,\n}\nuse constants\nuse redeemer.{Merge, Redeemer, Send, Stake}\n\nvalidator global(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(\n        signature,\n        utxos,\n        policy,\n        assetname,\n        amount,\n        policyInput,\n        assetnameInput,\n        amountInput,\n        spendingscriptflag,\n        pubkey,\n        stakingscriptflag,\n        stakekey,\n        datumflag,\n        datum,\n        payment_index,\n        fee,\n        signer,\n      ) -> {\n        let list_utxos =\n          list.foldr(\n            utxos,\n            [],\n            fn(utxo, xs) {\n              [\n                utxo.transaction_id,\n                bytearray.from_int_big_endian(utxo.output_index, 1),\n                ..xs\n              ]\n            },\n          )\n        expect datum_converted: ByteArray = datum\n        let message_array: List<ByteArray> =\n          list.push([], bytearray.from_int_big_endian(fee, 20))\n            |> list.push(bytearray.from_int_big_endian(payment_index, 1))\n            |> list.push(datum_converted)\n            |> list.push(bytearray.from_int_big_endian(datumflag, 1))\n            |> list.push(stakekey)\n            |> list.push(bytearray.from_int_big_endian(stakingscriptflag, 1))\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(spendingscriptflag, 1))\n            |> list.push(bytearray.from_int_big_endian(amountInput, 20))\n            |> list.push(assetnameInput)\n            |> list.push(policyInput)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n\n        let concat_array = concat_array(list.concat(list_utxos, message_array))\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_array)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_array)\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n        let incoming_value =\n          if amountInput > 0 {\n            from_asset(policy, assetname, amount)\n          } else {\n            zero\n          }\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, payment_index)\n\n        let starting_value =\n          find_inputs_value(self.inputs, contract_input.output.address)\n        let final_value =\n          find_outputs_value(self.outputs, contract_input.output.address)\n\n        let flag_utxo_present = list.has(utxos, own_ref)\n\n        let basic_validation = and {\n            flag_utxo_present,\n            or {\n              validate_signature_key(pubKey, message_hash_btc, signature),\n              validate_signature_key(pubKey, message_hash_eth, signature),\n            },\n          }\n        //Check 1) The output is sending the right amount\n        //Check 2) It is returning the right amount\n        //Check 3) Is the right receiver\n        //Check 4) Has the datum?\n        //Check 5) Are all inputs in utxos present? This is important otherwise I could cancel something random\n        //Check 6) Inputs that were not willing to be inside are from the same address and is a user\n        //7)Issue now is the expected value coming, this is something we want to sign also? Add input value signed and we are done\n        //Let's limit the max amount of outputs to the same wallet, otherwise someone could split all my ada in so many utxos making hard to spend them\n        let expected_datum = calculate_datum(datumflag, datum)\n        let expected_address =\n          calculate_address(\n            spendingscriptflag,\n            stakingscriptflag,\n            pubkey,\n            stakekey,\n          )\n        and {\n          quantity_of(payment_output.value, policy, assetname) == quantity_of(\n            sending_value,\n            policy,\n            assetname,\n          ),\n          assets.match(\n            final_value,\n            merge(\n              merge(\n                merge(starting_value, negate(sending_value)),\n                incoming_value,\n              ),\n              negate(from_lovelace(fee)),\n            ),\n            >=,\n          ),\n          basic_validation,\n          payment_output.address == expected_address,\n          payment_output.datum == expected_datum,\n          all_inputs_present(utxos, self.inputs),\n          only_external_signer_inputs_extra(utxos, self.inputs, signer),\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address == (\n            from_script(hash) |> with_delegation_script(hash)\n          ),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_message)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        and {\n          or {\n            validate_signature_key(pubKey, message_hash_btc, signature),\n            validate_signature_key(pubKey, message_hash_eth, signature),\n          },\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray_btc(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_btc)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn get_hash_from_bytearray_eth(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_eth)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n\nfn find_inputs_value(inputs: List<Input>, sc_address: Address) {\n  list.foldl(\n    inputs,\n    zero,\n    fn(input, total) {\n      if input.output.address == sc_address {\n        merge(input.output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\nfn find_outputs_value(outputs: List<Output>, sc_address: Address) {\n  list.foldl(\n    outputs,\n    zero,\n    fn(output, total) {\n      if output.address == sc_address {\n        merge(output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\npub fn calculate_address(\n  flag_spending_script: Int,\n  flag_staking_script: Int,\n  pubkey: ByteArray,\n  stakekey: ByteArray,\n) -> Address {\n  if flag_spending_script == 0 && flag_staking_script == 0 {\n    from_verification_key(pubkey) |> with_delegation_key(stakekey)\n  } else {\n    if flag_spending_script == 0 && flag_staking_script == 1 {\n      from_verification_key(pubkey) |> with_delegation_script(stakekey)\n    } else {\n      if flag_spending_script == 1 && flag_staking_script == 0 {\n        from_script(pubkey) |> with_delegation_key(stakekey)\n      } else {\n        if flag_spending_script == 1 && flag_staking_script == 1 {\n          from_script(pubkey) |> with_delegation_script(stakekey)\n        } else {\n          from_verification_key(pubkey) |> with_delegation_key(stakekey)\n        }\n      }\n    }\n  }\n}\n\npub fn calculate_datum(flag_datum: Int, datum: Data) -> Datum {\n  if flag_datum == 0 {\n    NoDatum\n  } else {\n    InlineDatum(datum)\n  }\n}\n\npub fn all_inputs_present(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n) {\n  list.all(utxos_chosen, fn(input) { is_some(find_input(real_utxos, input)) })\n}\n\npub fn only_external_signer_inputs_extra(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n  address_signer: Address,\n) {\n  let list_external =\n    list.filter(\n      real_utxos,\n      fn(input) { !list.has(utxos_chosen, input.output_reference) },\n    )\n  list.all(list_external, fn(input) { input.output.address == address_signer })\n}", "bug_explanation": "The bug is in the `calculate_address` function. The condition `if flag_spending_script == 1 && flag_staking_script == 1` is missing a proper validation for the spending script hash. This allows incorrect script usage by not properly validating the spending script hash when both flags are set to 1, potentially allowing unauthorized script execution.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/global.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to validate the spending script hash, allowing incorrect script usage."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/option.{is_some}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{\n  Address, Credential, Script, from_script, from_verification_key,\n  with_delegation_key, with_delegation_script,\n}\nuse cardano/assets.{from_asset, from_lovelace, merge, negate, quantity_of, zero}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n  find_input,\n}\nuse constants\nuse redeemer.{Merge, Redeemer, Send, Stake}\n\nvalidator global(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(\n        signature,\n        utxos,\n        policy,\n        assetname,\n        amount,\n        policyInput,\n        assetnameInput,\n        amountInput,\n        spendingscriptflag,\n        pubkey,\n        stakingscriptflag,\n        stakekey,\n        datumflag,\n        datum,\n        payment_index,\n        fee,\n        signer,\n      ) -> {\n        let list_utxos =\n          list.foldr(\n            utxos,\n            [],\n            fn(utxo, xs) {\n              [\n                utxo.transaction_id,\n                bytearray.from_int_big_endian(utxo.output_index, 1),\n                ..xs\n              ]\n            },\n          )\n        expect datum_converted: ByteArray = datum\n        let message_array: List<ByteArray> =\n          list.push([], bytearray.from_int_big_endian(fee, 20))\n            |> list.push(bytearray.from_int_big_endian(payment_index, 1))\n            |> list.push(datum_converted)\n            |> list.push(bytearray.from_int_big_endian(datumflag, 1))\n            |> list.push(stakekey)\n            |> list.push(bytearray.from_int_big_endian(stakingscriptflag, 1))\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(spendingscriptflag, 1))\n            |> list.push(bytearray.from_int_big_endian(amountInput, 20))\n            |> list.push(assetnameInput)\n            |> list.push(policyInput)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n\n        let concat_array = concat_array(list.concat(list_utxos, message_array))\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_array)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_array)\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n        let incoming_value =\n          if amountInput > 0 {\n            from_asset(policy, assetname, amount)\n          } else {\n            zero\n          }\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, payment_index)\n\n        let starting_value =\n          find_inputs_value(self.inputs, contract_input.output.address)\n        let final_value =\n          find_outputs_value(self.outputs, contract_input.output.address)\n\n        let flag_utxo_present = list.has(utxos, own_ref)\n\n        let basic_validation = and {\n            flag_utxo_present,\n            or {\n              validate_signature_key(pubKey, message_hash_btc, signature),\n              validate_signature_key(pubKey, message_hash_eth, signature),\n            },\n          }\n        //Check 1) The output is sending the right amount\n        //Check 2) It is returning the right amount\n        //Check 3) Is the right receiver\n        //Check 4) Has the datum?\n        //Check 5) Are all inputs in utxos present? This is important otherwise I could cancel something random\n        //Check 6) Inputs that were not willing to be inside are from the same address and is a user\n        //7)Issue now is the expected value coming, this is something we want to sign also? Add input value signed and we are done\n        //Let's limit the max amount of outputs to the same wallet, otherwise someone could split all my ada in so many utxos making hard to spend them\n        let expected_datum = calculate_datum(datumflag, datum)\n        let expected_address =\n          calculate_address(\n            spendingscriptflag,\n            stakingscriptflag,\n            pubkey,\n            stakekey,\n          )\n        and {\n          quantity_of(payment_output.value, policy, assetname) == quantity_of(\n            sending_value,\n            policy,\n            assetname,\n          ),\n          assets.match(\n            final_value,\n            merge(\n              merge(\n                merge(starting_value, negate(sending_value)),\n                incoming_value,\n              ),\n              negate(from_lovelace(fee)),\n            ),\n            >=,\n          ),\n          basic_validation,\n          payment_output.address == expected_address,\n          payment_output.datum == expected_datum,\n          all_inputs_present(utxos, self.inputs),\n          only_external_signer_inputs_extra(utxos, self.inputs, signer),\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address == (\n            from_script(hash) |> with_delegation_script(hash)\n          ),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_message)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        and {\n          or {\n            validate_signature_key(pubKey, message_hash_btc, signature),\n            validate_signature_key(pubKey, message_hash_eth, signature),\n          },\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray_btc(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_btc)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn get_hash_from_bytearray_eth(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_eth)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n\nfn find_inputs_value(inputs: List<Input>, sc_address: Address) {\n  list.foldl(\n    inputs,\n    zero,\n    fn(input, total) {\n      if input.output.address == sc_address {\n        merge(input.output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\nfn find_outputs_value(outputs: List<Output>, sc_address: Address) {\n  list.foldl(\n    outputs,\n    zero,\n    fn(output, total) {\n      if output.address == sc_address {\n        merge(output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\npub fn calculate_address(\n  flag_spending_script: Int,\n  flag_staking_script: Int,\n  pubkey: ByteArray,\n  stakekey: ByteArray,\n) -> Address {\n  if flag_spending_script == 0 && flag_staking_script == 0 {\n    from_verification_key(pubkey) |> with_delegation_key(stakekey)\n  } else {\n    if flag_spending_script == 0 && flag_staking_script == 1 {\n      from_verification_key(pubkey) |> with_delegation_script(stakekey)\n    } else {\n      if flag_spending_script == 1 && flag_staking_script == 0 {\n        from_script(pubkey) |> with_delegation_key(stakekey)\n      } else {\n        if flag_spending_script == 1 && flag_staking_script == 1 {\n          from_script(pubkey) |> with_delegation_script(stakekey)\n        } else {\n          from_verification_key(pubkey) |> with_delegation_key(stakekey)\n        }\n      }\n    }\n  }\n}\n\npub fn calculate_datum(flag_datum: Int, datum: Data) -> Datum {\n  if flag_datum == 0 {\n    NoDatum\n  } else {\n    InlineDatum(datum)\n  }\n}\n\npub fn all_inputs_present(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n) {\n  list.all(utxos_chosen, fn(input) { is_some(find_input(real_utxos, input)) })\n}\n\npub fn only_external_signer_inputs_extra(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n  address_signer: Address,\n) {\n  let list_external =\n    list.filter(\n      real_utxos,\n      fn(input) { !list.has(utxos_chosen, input.output_reference) },\n    )\n  list.all(list_external, fn(input) { input.output.address == address_signer })\n}", "bug_explanation": "The bug is introduced in the `withdraw` function where the `withdrawAmount` is used without checking for potential underflow when subtracting `1000000`. If `withdrawAmount` is less than `1000000`, this subtraction will result in a negative value, which can cause unexpected behavior or errors in the contract execution.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/global.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/option.{is_some}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{\n  Address, Credential, Script, from_script, from_verification_key,\n  with_delegation_key, with_delegation_script,\n}\nuse cardano/assets.{from_asset, from_lovelace, merge, negate, quantity_of, zero}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n  find_input,\n}\nuse constants\nuse redeemer.{Merge, Redeemer, Send, Stake}\n\nvalidator global(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(\n        signature,\n        utxos,\n        policy,\n        assetname,\n        amount,\n        policyInput,\n        assetnameInput,\n        amountInput,\n        spendingscriptflag,\n        pubkey,\n        stakingscriptflag,\n        stakekey,\n        datumflag,\n        datum,\n        payment_index,\n        fee,\n        signer,\n      ) -> {\n        let list_utxos =\n          list.foldr(\n            utxos,\n            [],\n            fn(utxo, xs) {\n              [\n                utxo.transaction_id,\n                bytearray.from_int_big_endian(utxo.output_index, 1),\n                ..xs\n              ]\n            },\n          )\n        expect datum_converted: ByteArray = datum\n        let message_array: List<ByteArray> =\n          list.push([], bytearray.from_int_big_endian(fee, 20))\n            |> list.push(bytearray.from_int_big_endian(payment_index, 1))\n            |> list.push(datum_converted)\n            |> list.push(bytearray.from_int_big_endian(datumflag, 1))\n            |> list.push(stakekey)\n            |> list.push(bytearray.from_int_big_endian(stakingscriptflag, 1))\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(spendingscriptflag, 1))\n            |> list.push(bytearray.from_int_big_endian(amountInput, 20))\n            |> list.push(assetnameInput)\n            |> list.push(policyInput)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n\n        let concat_array = concat_array(list.concat(list_utxos, message_array))\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_array)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_array)\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n        let incoming_value =\n          if amountInput > 0 {\n            from_asset(policy, assetname, amount)\n          } else {\n            zero\n          }\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, payment_index)\n\n        let starting_value =\n          find_inputs_value(self.inputs, contract_input.output.address)\n        let final_value =\n          find_outputs_value(self.outputs, contract_input.output.address)\n\n        let flag_utxo_present = list.has(utxos, own_ref)\n\n        let basic_validation = and {\n            flag_utxo_present,\n            or {\n              validate_signature_key(pubKey, message_hash_btc, signature),\n              validate_signature_key(pubKey, message_hash_eth, signature),\n            },\n          }\n        //Check 1) The output is sending the right amount\n        //Check 2) It is returning the right amount\n        //Check 3) Is the right receiver\n        //Check 4) Has the datum?\n        //Check 5) Are all inputs in utxos present? This is important otherwise I could cancel something random\n        //Check 6) Inputs that were not willing to be inside are from the same address and is a user\n        //7)Issue now is the expected value coming, this is something we want to sign also? Add input value signed and we are done\n        //Let's limit the max amount of outputs to the same wallet, otherwise someone could split all my ada in so many utxos making hard to spend them\n        let expected_datum = calculate_datum(datumflag, datum)\n        let expected_address =\n          calculate_address(\n            spendingscriptflag,\n            stakingscriptflag,\n            pubkey,\n            stakekey,\n          )\n        and {\n          quantity_of(payment_output.value, policy, assetname) == quantity_of(\n            sending_value,\n            policy,\n            assetname,\n          ),\n          assets.match(\n            final_value,\n            merge(\n              merge(\n                merge(starting_value, negate(sending_value)),\n                incoming_value,\n              ),\n              negate(from_lovelace(fee)),\n            ),\n            >=,\n          ),\n          basic_validation,\n          payment_output.address == expected_address,\n          payment_output.datum == expected_datum,\n          all_inputs_present(utxos, self.inputs),\n          only_external_signer_inputs_extra(utxos, self.inputs, signer),\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address == (\n            from_script(hash) |> with_delegation_script(hash)\n          ),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_message)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        and {\n          or {\n            validate_signature_key(pubKey, message_hash_btc, signature),\n            validate_signature_key(pubKey, message_hash_eth, signature),\n          },\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray_btc(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_btc)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn get_hash_from_bytearray_eth(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_eth)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n\nfn find_inputs_value(inputs: List<Input>, sc_address: Address) {\n  list.foldl(\n    inputs,\n    zero,\n    fn(input, total) {\n      if input.output.address == sc_address {\n        merge(input.output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\nfn find_outputs_value(outputs: List<Output>, sc_address: Address) {\n  list.foldl(\n    outputs,\n    zero,\n    fn(output, total) {\n      if output.address == sc_address {\n        merge(output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\npub fn calculate_address(\n  flag_spending_script: Int,\n  flag_staking_script: Int,\n  pubkey: ByteArray,\n  stakekey: ByteArray,\n) -> Address {\n  if flag_spending_script == 0 && flag_staking_script == 0 {\n    from_verification_key(pubkey) |> with_delegation_key(stakekey)\n  } else {\n    if flag_spending_script == 0 && flag_staking_script == 1 {\n      from_verification_key(pubkey) |> with_delegation_script(stakekey)\n    } else {\n      if flag_spending_script == 1 && flag_staking_script == 0 {\n        from_script(pubkey) |> with_delegation_key(stakekey)\n      } else {\n        if flag_spending_script == 1 && flag_staking_script == 1 {\n          from_script(pubkey) |> with_delegation_script(stakekey)\n        } else {\n          from_verification_key(pubkey) |> with_delegation_key(stakekey)\n        }\n      }\n    }\n  }\n}\n\npub fn calculate_datum(flag_datum: Int, datum: Data) -> Datum {\n  if flag_datum == 0 {\n    NoDatum\n  } else {\n    InlineDatum(datum)\n  }\n}\n\npub fn all_inputs_present(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n) {\n  list.all(utxos_chosen, fn(input) { is_some(find_input(real_utxos, input)) })\n}\n\npub fn only_external_signer_inputs_extra(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n  address_signer: Address,\n) {\n  let list_external =\n    list.filter(\n      real_utxos,\n      fn(input) { !list.has(utxos_chosen, input.output_reference) },\n    )\n  list.all(list_external, fn(input) { input.output.address == address_signer })\n}", "bug_explanation": "The bug is in the `spend` function where the `incoming_value` is calculated. The condition `if amountInput > 0` does not account for negative values of `amountInput`. If `amountInput` is negative, it should not proceed to create an asset with a negative amount, but the current logic allows it, potentially leading to incorrect asset calculations.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/global.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/option.{is_some}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{\n  Address, Credential, Script, from_script, from_verification_key,\n  with_delegation_key, with_delegation_script,\n}\nuse cardano/assets.{from_asset, from_lovelace, merge, negate, quantity_of, zero}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n  find_input,\n}\nuse constants\nuse redeemer.{Merge, Redeemer, Send, Stake}\n\nvalidator global(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(\n        signature,\n        utxos,\n        policy,\n        assetname,\n        amount,\n        policyInput,\n        assetnameInput,\n        amountInput,\n        spendingscriptflag,\n        pubkey,\n        stakingscriptflag,\n        stakekey,\n        datumflag,\n        datum,\n        payment_index,\n        fee,\n        signer,\n      ) -> {\n        let list_utxos =\n          list.foldr(\n            utxos,\n            [],\n            fn(utxo, xs) {\n              [\n                utxo.transaction_id,\n                bytearray.from_int_big_endian(utxo.output_index, 1),\n                ..xs\n              ]\n            },\n          )\n        expect datum_converted: ByteArray = datum\n        let message_array: List<ByteArray> =\n          list.push([], bytearray.from_int_big_endian(fee, 20))\n            |> list.push(bytearray.from_int_big_endian(payment_index, 1))\n            |> list.push(datum_converted)\n            |> list.push(bytearray.from_int_big_endian(datumflag, 1))\n            |> list.push(stakekey)\n            |> list.push(bytearray.from_int_big_endian(stakingscriptflag, 1))\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(spendingscriptflag, 1))\n            |> list.push(bytearray.from_int_big_endian(amountInput, 20))\n            |> list.push(assetnameInput)\n            |> list.push(policyInput)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n\n        let concat_array = concat_array(list.concat(list_utxos, message_array))\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_array)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_array)\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n        let incoming_value =\n          if amountInput > 0 {\n            from_asset(policy, assetname, amount)\n          } else {\n            zero\n          }\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, payment_index)\n\n        let starting_value =\n          find_inputs_value(self.inputs, contract_input.output.address)\n        let final_value =\n          find_outputs_value(self.outputs, contract_input.output.address)\n\n        let flag_utxo_present = list.has(utxos, own_ref)\n\n        let basic_validation = and {\n            flag_utxo_present,\n            or {\n              validate_signature_key(pubKey, message_hash_btc, signature),\n              validate_signature_key(pubKey, message_hash_eth, signature),\n            },\n          }\n        //Check 1) The output is sending the right amount\n        //Check 2) It is returning the right amount\n        //Check 3) Is the right receiver\n        //Check 4) Has the datum?\n        //Check 5) Are all inputs in utxos present? This is important otherwise I could cancel something random\n        //Check 6) Inputs that were not willing to be inside are from the same address and is a user\n        //7)Issue now is the expected value coming, this is something we want to sign also? Add input value signed and we are done\n        //Let's limit the max amount of outputs to the same wallet, otherwise someone could split all my ada in so many utxos making hard to spend them\n        let expected_datum = calculate_datum(datumflag, datum)\n        let expected_address =\n          calculate_address(\n            spendingscriptflag,\n            stakingscriptflag,\n            pubkey,\n            stakekey,\n          )\n        and {\n          quantity_of(payment_output.value, policy, assetname) == quantity_of(\n            sending_value,\n            policy,\n            assetname,\n          ),\n          assets.match(\n            final_value,\n            merge(\n              merge(\n                merge(starting_value, negate(sending_value)),\n                incoming_value,\n              ),\n              negate(from_lovelace(fee)),\n            ),\n            >=,\n          ),\n          basic_validation,\n          payment_output.address == expected_address,\n          payment_output.datum == expected_datum,\n          all_inputs_present(utxos, self.inputs),\n          only_external_signer_inputs_extra(utxos, self.inputs, signer),\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address == (\n            from_script(hash) |> with_delegation_script(hash)\n          ),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_message)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        and {\n          or {\n            validate_signature_key(pubKey, message_hash_btc, signature),\n            validate_signature_key(pubKey, message_hash_eth, signature),\n          },\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray_btc(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_btc)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn get_hash_from_bytearray_eth(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_eth)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n\nfn find_inputs_value(inputs: List<Input>, sc_address: Address) {\n  list.foldl(\n    inputs,\n    zero,\n    fn(input, total) {\n      if input.output.address == sc_address {\n        merge(input.output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\nfn find_outputs_value(outputs: List<Output>, sc_address: Address) {\n  list.foldl(\n    outputs,\n    zero,\n    fn(output, total) {\n      if output.address == sc_address {\n        merge(output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\npub fn calculate_address(\n  flag_spending_script: Int,\n  flag_staking_script: Int,\n  pubkey: ByteArray,\n  stakekey: ByteArray,\n) -> Address {\n  if flag_spending_script == 0 && flag_staking_script == 0 {\n    from_verification_key(pubkey) |> with_delegation_key(stakekey)\n  } else {\n    if flag_spending_script == 0 && flag_staking_script == 1 {\n      from_verification_key(pubkey) |> with_delegation_script(stakekey)\n    } else {\n      if flag_spending_script == 1 && flag_staking_script == 0 {\n        from_script(pubkey) |> with_delegation_key(stakekey)\n      } else {\n        if flag_spending_script == 1 && flag_staking_script == 1 {\n          from_script(pubkey) |> with_delegation_script(stakekey)\n        } else {\n          from_verification_key(pubkey) |> with_delegation_key(stakekey)\n        }\n      }\n    }\n  }\n}\n\npub fn calculate_datum(flag_datum: Int, datum: Data) -> Datum {\n  if flag_datum == 0 {\n    NoDatum\n  } else {\n    InlineDatum(datum)\n  }\n}\n\npub fn all_inputs_present(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n) {\n  list.all(utxos_chosen, fn(input) { is_some(find_input(real_utxos, input)) })\n}\n\npub fn only_external_signer_inputs_extra(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n  address_signer: Address,\n) {\n  let list_external =\n    list.filter(\n      real_utxos,\n      fn(input) { !list.has(utxos_chosen, input.output_reference) },\n    )\n  list.all(list_external, fn(input) { input.output.address == address_signer })\n}", "bug_explanation": "The bug is in the `calculate_datum` function. The function is supposed to return `NoDatum` when `flag_datum` is 0 and `InlineDatum(datum)` otherwise. However, the function does not validate the `datum` when `flag_datum` is not 0, which could allow an incorrect or malicious datum to be used without proper validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/global.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id && tn == nft_asset_name\n  }\n}", "bug_explanation": "The code does not verify that the transaction is signed by the correct public key (pubkey). This omission allows unauthorized parties to potentially execute the transaction without the necessary permissions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id && tn == nft_asset_name\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a transaction with the same inputs and outputs, as there is no mechanism to ensure that each transaction is unique and cannot be replayed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the code does not verify that the correct signer (pubkey) is present in the transaction. This means that the transaction can be executed without ensuring that the intended party has signed it, potentially allowing unauthorized actions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `swap_script` function, within the `Swap` case, the `utils.valid_swap` function is called with the `outputs` list. If this function expects to iterate over the entire list, an off-by-one error could occur if the function internally uses a loop that incorrectly iterates one less or one more than intended, potentially missing or incorrectly processing the last element of the list.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by removing the check for `swap_price` numerator > 0 in the `Swap` case. This allows a swap to be created with a zero numerator, which can lead to division by zero errors or unintended behavior when calculating the swap price.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `Swap` case of the `swap_script` function, the `utils.valid_swap` function is called with the `outputs` parameter. However, the code does not validate the number of outputs, which could allow transactions with an incorrect number of outputs to pass validation. This could lead to unexpected behavior or security vulnerabilities if the number of outputs is critical to the contract's logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `Swap` case of the `swap_script` function. The `utils.valid_swap` function is called without checking the transaction deadline, which means that expired transactions could be incorrectly validated as valid. This could allow swaps to be executed even after their intended deadline, potentially leading to unintended consequences or exploitation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The modified code does not include a check for the uniqueness of transaction IDs (input_ref) in the `Swap` case of the `swap_script` function. This omission allows replay attacks, as the same transaction can be submitted multiple times without being detected as a duplicate.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `Swap` case of the `swap_script` function, the code incorrectly assumes that the `prev_input` field in the `SwapDatum` is not needed and does not check if it is `Some(input_ref)`. This omission allows for the acceptance of invalid data where the `prev_input` field is not correctly set, potentially leading to incorrect swap operations.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that incorrectly handles optional fields, causing unintended acceptance of invalid data."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `Swap` case of the `swap_script` function, the `utils.valid_swap` function is called with the `input_ref` parameter. This parameter is used to validate the swap datum against the input reference. If the `input_ref` is not correctly validated, it could allow the use of an incorrect or manipulated datum, leading to potential misuse of datums in the swap process.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by omitting the validation of the token name during the minting process in the `UsingSeller` case. This allows for unrestricted token minting without checking if the token name matches the expected criteria, potentially leading to unauthorized token creation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not enforce any size or structural constraints on the `seller_in_datum` parameter. This means that any data structure that matches the type `SellerDatum` can be passed in, potentially allowing malformed or unexpected data to be processed without validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug that accepts datum without enforcing size or structural constraints."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by using equality (`==`) where inequality (`!=`) was intended in a critical check within the `validate_using_seller` function. This could lead to incorrect validation logic, allowing unauthorized transactions to pass validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is an off-by-one error in the list indexing or loop logic. However, the provided code does not contain any explicit list indexing or loop constructs, so the bug would need to be introduced in a part of the code that handles such operations, which is not visible in the provided snippet. The subtlety of the bug lies in its potential impact on list operations, which could lead to incorrect validation or transaction processing.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include a check for the uniqueness of transaction IDs, which allows the same transaction to be replayed multiple times, leading to potential replay attacks.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aada/finance\nuse aada/nft.{BurnNFTElem,\n  CollateralNFTRedeemerLists, MintNFTElem, id_from_utxo}\nuse aada/types.{AssetClass, Wrapped, WrappedRedeemer}\nuse aada/types/collateral.{CollateralDatum, MergeDatum}\nuse aada/types/leftovers.{LeftoversDatum}\nuse aada/types/oracle.{Aggregated, Pooled}\nuse aada/types/pool\nuse aada/utils\nuse aiken/dict\nuse aiken/interval.{Finite}\nuse aiken/list\nuse aiken/math/rational\nuse aiken/option\n// Collateral is makes sure that loan is repaid fairly before allowing to take collateral.\n// Also collateral is a friend of lender since Collateral, not Pool cares about the interest and loan\n\nuse aiken/transaction.{\n  Datum, InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value.{flatten, from_minted_value, quantity_of, tokens}\n\ntype CollateralRedeemer {\n  action: CollateralRedeemerType,\n  interest: Int,\n  merge_type: CollateralMergeType,\n}\n\n// If liquidation - oracle data is needed.\ntype CollateralRedeemerType {\n  CollateralRepay\n  CollateralLiquidate(Int)\n}\n\ntype DelayedMergeValues {\n  output_index: Int,\n  amount_repaying: Int,\n}\n\ntype CollateralMergeType {\n  // WithPool happens with pool utxo in same transaction\n  ImmediateWithPool(OutputReference)\n  // Sharded doesn't have pool in same transaction, and produces output at a merging script\n  DelayedIntoPool(DelayedMergeValues)\n}\n\nfn get_platform_fee(\n  collateral_datum: CollateralDatum,\n  // pool_input_datum: pool.Datum,\n  platform_fee_datum: pool.PlatformFeeDetails,\n) -> Int {\n  expect Some(utilization_rate) =\n    collateral_datum.loan_amount * 1000000\n      |> rational.new(collateral_datum.lent_out + collateral_datum.balance)\n\n  if\n  (\n    utilization_rate\n      |> rational.compare(rational.from_int(platform_fee_datum.tier_1_threshold))\n  ) == Less{\n  \n    platform_fee_datum.tier_1_fee\n  } else if (\n    utilization_rate\n      |> rational.compare(rational.from_int(platform_fee_datum.tier_2_threshold))\n  ) == Less {\n    platform_fee_datum.tier_2_fee\n  } else {\n    platform_fee_datum.tier_3_fee\n  }\n}\n\ntype CollateralParams {\n  pool_script_hash: ByteArray,\n  liquidations_pkh: ByteArray,\n  param_merge_script_hash: ByteArray,\n}\n\nvalidator(collateral_script_params: CollateralParams) {\n  fn spend(\n    datum: CollateralDatum,\n    redeemer: CollateralRedeemer,\n    ctx: ScriptContext,\n  ) {\n    let CollateralParams {\n      pool_script_hash,\n      liquidations_pkh,\n      param_merge_script_hash,\n    } = collateral_script_params\n    let ScriptContext {\n      transaction: Transaction {\n        validity_range,\n        inputs,\n        outputs,\n        redeemers,\n        reference_inputs,\n        ..\n      },\n      purpose,\n    } = ctx\n    expect Spend(this_oref) = purpose\n\n    expect Finite(lower_bound) = validity_range.lower_bound.bound_type\n    expect Finite(upper_bound) = validity_range.upper_bound.bound_type\n\n    let valid_validity_range = upper_bound - lower_bound <= 3600000\n\n    let CollateralDatum { pool_nft_name, borrower_tn, .. } = datum\n    let pool.Config {\n      loan_fee_details: platform_fee_details,\n      liquidation_threshold,\n      merge_action_fee,\n      min_liquidation_fee,\n      ..\n    }: pool.Config = datum.pool_config\n    let platform_fee_rate = get_platform_fee(datum, platform_fee_details)\n    let CollateralRedeemer { action, interest: interest_amount, merge_type } =\n      redeemer\n\n    expect Some(calculated_interest_amount) =\n      finance.calculate_interest_amount(\n        datum.interest_rate,\n        datum.loan_amount,\n        datum.deposit_time,\n        upper_bound,\n      )\n\n    let interest_check =\n      (\n        rational.from_int(interest_amount)\n          |> rational.compare(calculated_interest_amount)\n      ) != Less\n    let interest_amount_is_positive = interest_amount > 0\n    let interest_rate_is_positive = datum.interest_rate > 0\n    expect Some(platform_fee_amount) =\n      interest_amount * platform_fee_rate |> rational.new(1000000)\n    let platform_fee_amount_int = platform_fee_amount |> rational.truncate\n    let amount_to_repay =\n      calculated_interest_amount\n        |> rational.add(rational.from_int(datum.loan_amount))\n\n    let platform_fee_paid =\n      if platform_fee_amount_int > 0 {\n        list.any(\n          outputs,\n          fn(p_output) {\n            if\n            p_output.address == platform_fee_details.platform_fee_collector_address{\n            \n              expect InlineDatum(output_datum) = p_output.datum\n              expect constructed_datum: ByteArray = output_datum\n\n              and {\n                (quantity_of(\n                  p_output.value,\n                  datum.loan_cs.policy_id,\n                  datum.loan_cs.asset_name,\n                ) >= platform_fee_amount_int)?,\n                (constructed_datum == borrower_tn)?,\n              }\n            } else {\n              False\n            }\n          },\n        )\n      } else {\n        True\n      }\n\n    expect Some(Input {\n      output: Output {\n        address: Address(\n          ScriptCredential(collateral_script_hash),\n          own_stake_key,\n        ),\n        ..\n      },\n      ..\n    }) =\n      list.find(inputs, fn(inp) -> Bool { inp.output_reference == this_oref })\n    // add redeemer check for pool\n    let confirmed_repay_amt =\n      when action is {\n        CollateralRepay -> {\n          let nft_check =\n            utils.validate_mint_nft_few_per_policy(\n              ctx.transaction.mint,\n              collateral_script_hash,\n              datum.borrower_tn,\n              -1,\n            )\n          let valid_repay = and {\n              platform_fee_paid?,\n              nft_check?,\n              interest_check?,\n            }\n          if valid_repay {\n            Some(amount_to_repay)\n          } else {\n            None\n          }\n        }\n        CollateralLiquidate(liquidation_output_ref) -> {\n          let ada_cs = AssetClass(\"\", \"\")\n          let value_to_repay =\n            if datum.loan_cs.policy_id == ada_cs.policy_id {\n              amount_to_repay |> rational.truncate\n            } else {\n              expect Some(loan_tokens_price) =\n                utils.retrieve_oracle_data(\n                  reference_inputs,\n                  datum.oracle_loan_asset,\n                  redeemers,\n                  upper_bound,\n                )\n\n              when loan_tokens_price is {\n                Aggregated(aggregated_data) -> {\n                  expect Some(token_price) =\n                    rational.new(\n                      aggregated_data.token_price_in_lovelaces,\n                      aggregated_data.denominator,\n                    )\n\n                  amount_to_repay\n                    |> rational.mul(token_price)\n                    |> rational.truncate\n                }\n                Pooled(pooled_data) ->\n                  finance.token_b_needed_to_purchase_token_a(\n                    amount_to_repay,\n                    pooled_data.token_a_amount,\n                    pooled_data.token_b_amount,\n                  )\n              }\n            }\n\n          let collateral_amount_rat =\n            datum.collateral_amount |> rational.from_int()\n\n          let collateral_value =\n            if datum.collateral_cs.policy_id == ada_cs.policy_id {\n              datum.collateral_amount\n            } else {\n              expect Some(collateral_tokens_price) =\n                utils.retrieve_oracle_data(\n                  reference_inputs,\n                  datum.oracle_collateral_asset,\n                  redeemers,\n                  upper_bound,\n                )\n              when collateral_tokens_price is {\n                Aggregated(aggregated_data) -> {\n                  expect Some(token_price) =\n                    rational.new(\n                      aggregated_data.token_price_in_lovelaces,\n                      aggregated_data.denominator,\n                    )\n\n                  collateral_amount_rat\n                    |> rational.mul(token_price)\n                    |> rational.truncate\n                }\n                Pooled(pooled_data) ->\n                  finance.token_b_received_from_seling_token_a(\n                    collateral_amount_rat,\n                    pooled_data.token_a_amount,\n                    pooled_data.token_b_amount,\n                  )\n              }\n            }\n\n          let liquidation_address =\n            Address(ScriptCredential(liquidations_pkh), own_stake_key)\n\n          expect Some(liquidation_fee) =\n            rational.new(\n              ( collateral_value - value_to_repay ) * platform_fee_details.liquidation_fee,\n              1_000_000,\n            )\n\n          let liquidation_fee =\n            if ( liquidation_fee |> rational.truncate ) < min_liquidation_fee {\n              rational.from_int(min_liquidation_fee)\n            } else {\n              liquidation_fee\n            }\n\n          let borrower_compensation_in_ada =\n            rational.from_int(collateral_value - value_to_repay)\n              |> rational.sub(liquidation_fee)\n\n          let borrower_compensation =\n            if datum.collateral_cs.policy_id == ada_cs.policy_id {\n              borrower_compensation_in_ada |> rational.truncate\n            } else {\n              expect Some(collateral_tokens_price) =\n                utils.retrieve_oracle_data(\n                  reference_inputs,\n                  datum.oracle_collateral_asset,\n                  redeemers,\n                  upper_bound,\n                )\n              when collateral_tokens_price is {\n                Aggregated(aggregated_data) -> {\n                  expect Some(token_price) =\n                    rational.new(\n                      aggregated_data.token_price_in_lovelaces,\n                      aggregated_data.denominator,\n                    )\n                  expect Some(val) =\n                    borrower_compensation_in_ada\n                      |> rational.div(token_price)\n                  val\n                    |> rational.truncate\n                }\n                Pooled(pooled_data) ->\n                  finance.token_b_received_from_seling_token_a(\n                    borrower_compensation_in_ada,\n                    pooled_data.token_b_amount, \n                    pooled_data.token_a_amount,\n                  )\n              }\n            }\n\n          let collateral_check =\n            finance.check_is_undercollaterized(\n              value_to_repay,\n              collateral_value,\n              liquidation_threshold,\n            )\n\n          let liquidation_output_check =\n            if and {\n              borrower_compensation > 0,\n              collateral_check,\n            } {\n              let AssetClass { policy_id, asset_name } = datum.collateral_cs\n\n              expect Some(Output { value, datum: wrapped_datum, address, .. }) =\n                list.at(outputs, liquidation_output_ref)\n\n              expect InlineDatum(raw_datum) = wrapped_datum\n              let constructed_datum: LeftoversDatum =\n                AssetClass {\n                  policy_id: collateral_script_hash,\n                  asset_name: datum.borrower_tn,\n                }\n              let expected_datum: Data = constructed_datum\n              let dust_attack_check =\n                when flatten(value) is {\n                  [(_, _, _)] -> True\n                  [(_, _, _), (_, _, _)] -> True\n                  _ -> False\n                }\n\n              // Liquidation output can have 2 assets at most (ADA + maybe token)\n              let quantity_check =\n                quantity_of(value, policy_id, asset_name) >= borrower_compensation\n\n              let datum_check = raw_datum == expected_datum\n              let address_check = address == liquidation_address\n              and {\n                quantity_check?,\n                datum_check?,\n                dust_attack_check?,\n                address_check?,\n              }\n            } else {\n              True\n            }\n\n          let valid_repay = and {\n              platform_fee_paid?,\n              collateral_check?,\n              liquidation_output_check?,\n              interest_check?,\n              interest_amount_is_positive?,\n              interest_rate_is_positive?,\n            }\n          if valid_repay {\n            Some(amount_to_repay)\n          } else {\n            None\n          }\n        }\n      }\n\n    when confirmed_repay_amt is {\n      Some(amt_to_pay) ->\n        when merge_type is {\n          ImmediateWithPool(pool_oref) -> {\n            // find pool\n            expect Some(pool_input) =\n              inputs |> list.find(fn(inp) { inp.output_reference == pool_oref })\n            let pool_input_has_nft =\n              quantity_of(\n                pool_input.output.value,\n                pool_script_hash,\n                pool_nft_name,\n              ) > 0\n            expect Some(raw_pool_redeemer) =\n              redeemers\n                |> dict.get(Spend(pool_oref))\n\n            expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n              raw_pool_redeemer\n\n            let pool_receives_amt =\n              when pool_redeemer.action is {\n                pool.Continuing(pool.CloseLoan { loan_amount, repay_amount, .. }) -> {\n                  let amt_repay_t = amt_to_pay |> rational.truncate\n                  let loan_amt_check = loan_amount >= datum.loan_amount\n                  let repay_amt_check = repay_amount >= amt_repay_t\n                  and {\n                    loan_amt_check,\n                    repay_amt_check,\n                  }\n                }\n                _ -> False\n              }\n            and {\n              pool_input_has_nft?,\n              pool_receives_amt?,\n              valid_validity_range?,\n            }\n          }\n          // Allow to repay to the pool later.\n          // This is useful if pool is busy and loan can't be repaid directly to pool. \n          DelayedIntoPool(merge_values) -> {\n            let merge_values: DelayedMergeValues = merge_values\n\n            expect Some(Output {\n              address,\n              datum: InlineDatum(merge_datum),\n              value,\n              ..\n            }) = outputs |> list.at(merge_values.output_index)\n            expect merge_datum: MergeDatum = merge_datum\n            let address_check =\n              address == Address(\n                ScriptCredential(param_merge_script_hash),\n                own_stake_key,\n              )\n\n            let value_check =\n              quantity_of(\n                value,\n                datum.loan_cs.policy_id,\n                datum.loan_cs.asset_name,\n              ) >= ( amt_to_pay |> rational.truncate ) + merge_action_fee\n\n            // merge_action_fee is build of 2 (pool_fee + fee received for executor.)\n            // Making sure that LF-100 is resolved\n            let dust_attack_check =\n              when flatten(value) is {\n                [(_, _, _)] -> True\n                [(_, _, _), (_, _, _)] -> True\n                _ -> False\n              }\n\n            let valid_repayment_amt =\n              merge_values.amount_repaying >= (\n                amt_to_pay |> rational.truncate\n              )\n            let datum_check =\n              merge_datum == MergeDatum {\n                borrower_tn: datum.borrower_tn,\n                // It is not actively used for any validation. Might be useful for double satisfaction?\n                pool_nft_name,\n                repay_amount: merge_values.amount_repaying,\n                // Loan + interests\n                loan_amount: datum.loan_amount,\n                collateral_oref: this_oref,\n              }\n            and {\n              address_check?,\n              valid_repayment_amt?,\n              datum_check?,\n              value_check?,\n              dust_attack_check?,\n            }\n          }\n        }\n      None -> False\n    }\n  }\n\n  fn mint(redeemer: CollateralNFTRedeemerLists, ctx: ScriptContext) -> Bool {\n    let CollateralParams { pool_script_hash, .. } = collateral_script_params\n    let ScriptContext {\n      transaction: Transaction {\n        inputs,\n        outputs,\n        validity_range,\n        mint,\n        reference_inputs,\n        redeemers,\n        ..\n      },\n      purpose,\n    } = ctx\n    let mint_value = from_minted_value(mint)\n\n    expect Mint(own_address) = purpose\n    let own_scred = ScriptCredential(own_address)\n    let own_mints = tokens(mint_value, own_address)\n\n    let CollateralNFTRedeemerLists { mints, burns } = redeemer\n    let num_minted_check =\n      dict.size(own_mints) == list.length(mints) + list.length(burns)\n\n    expect Finite(lower_bound) = validity_range.lower_bound.bound_type\n    expect Finite(upper_bound) = validity_range.upper_bound.bound_type\n    let valid_validity_range = upper_bound - lower_bound <= 3600000\n\n    let mints_are_valid =\n      list.foldl(\n        mints,\n        Some(inputs),\n        fn(collateral_mint: MintNFTElem, curr_inputs_opt: Option<List<Input>>) -> Option<\n          List<Input>,\n        > {\n          expect Some(curr_inputs) = curr_inputs_opt\n          let MintNFTElem(pool_utxo, collateral_output_idx) = collateral_mint\n          let expected_token_name = id_from_utxo(pool_utxo)\n          let token_minted_amount =\n            quantity_of(mint_value, own_address, expected_token_name)\n          let minted_amount_check = token_minted_amount == 1\n          expect Some(Output {\n            datum: InlineDatum(actual_datum_output),\n            value: collateral_value,\n            address: collateral_address,\n            ..\n          }) =\n            outputs\n              |> list.at(collateral_output_idx)\n          let collateral_at_script_check =\n            collateral_address.payment_credential == own_scred\n          expect CollateralDatum { pool_nft_name, tag, .. }: CollateralDatum =\n            actual_datum_output\n          let pruned_inputs =\n            curr_inputs\n              |> list.drop_while(fn(in) { in.output_reference != pool_utxo })\n\n          expect [\n            Input(\n              _,\n              Output {\n                datum: InlineDatum(raw_pool_datum),\n                address: pool_address,\n                value: pool_value,\n                ..\n              },\n            ),\n            ..\n          ] = pruned_inputs\n\n          let pool_nft_check =\n            quantity_of(pool_value, pool_script_hash, pool_nft_name) == 1\n          expect Some(raw_pool_redeemer): Option<Data> =\n            dict.get(ctx.transaction.redeemers, Spend(pool_utxo))\n          expect Wrapped(pool.Redeemer {\n            action: pool.Continuing(pool.Borrow {\n              loan_amount,\n              collateral_amount: borrowed_collateral_amount,\n              interest_rate,\n              borrower_tn,\n              ..\n            }),\n            config_ref,\n            ..\n          }): WrappedRedeemer<pool.Redeemer> = raw_pool_redeemer\n          expect Some(Input {\n            output: Output { datum: InlineDatum(pool_config_datum), .. },\n            ..\n          }) =\n            reference_inputs\n              |> list.find(fn(inp) -> Bool { inp.output_reference == config_ref })\n          expect pool_config: pool.Config = pool_config_datum\n          expect pool.Datum {\n            params: pool.Constants {\n              pool_nft_name,\n              loan_cs,\n              collateral_cs,\n              oracle_collateral_asset,\n              oracle_loan_asset,\n              ..\n            },\n            lent_out: pool_lent_out,\n            balance: pool_balance,\n            ..\n          }: pool.Datum = raw_pool_datum\n\n          // To validate Oracle inputs\n          let valid_borrower_tn = expected_token_name == borrower_tn\n          let expected_collateral_datum: Data =\n            CollateralDatum {\n              pool_nft_name,\n              loan_cs,\n              loan_amount,\n              pool_config,\n              collateral_cs,\n              collateral_amount: borrowed_collateral_amount,\n              interest_rate,\n              lent_out: pool_lent_out,\n              balance: pool_balance,\n              deposit_time: lower_bound,\n              borrower_tn,\n              oracle_collateral_asset,\n              oracle_loan_asset,\n              tag,\n            }\n          let dust_attack_check =\n            when flatten(collateral_value) is {\n              [(_, _, _)] -> True\n              [(_, _, _), (_, _, _)] -> True\n              _ -> False\n            }\n          // Collateral output can have 2 assets at most (ADA + maybe token)\n          let collateral_amount =\n            quantity_of(\n              collateral_value,\n              collateral_cs.policy_id,\n              collateral_cs.asset_name,\n            )\n          let collateral_amount_check =\n            collateral_amount >= borrowed_collateral_amount\n\n          let ada_cs = AssetClass(\"\", \"\")\n          let loan_amount_rat = rational.from_int(loan_amount)\n          let loan_value =\n            if loan_cs.policy_id == ada_cs.policy_id {\n              loan_amount\n            } else {\n              expect Some(loan_tokens_price) =\n                utils.retrieve_oracle_data(\n                  reference_inputs,\n                  oracle_loan_asset,\n                  redeemers,\n                  upper_bound,\n                )\n              when loan_tokens_price is {\n                Aggregated(aggregated_data) -> {\n                  expect Some(token_price) =\n                    rational.new(\n                      aggregated_data.token_price_in_lovelaces,\n                      aggregated_data.denominator,\n                    )\n                  loan_amount_rat\n                    |> rational.mul(token_price)\n                    |> rational.truncate\n                }\n                Pooled(pooled_data) ->\n                  finance.token_b_needed_to_purchase_token_a(\n                    loan_amount_rat,\n                    pooled_data.token_a_amount,\n                    pooled_data.token_b_amount,\n                  )\n              }\n            }\n          let collateral_amount_rat = collateral_amount |> rational.from_int()\n          let collateral_tokens_value =\n            if collateral_cs.policy_id == ada_cs.policy_id {\n              collateral_amount\n            } else {\n              expect Some(collateral_tokens_price) =\n                utils.retrieve_oracle_data(\n                  reference_inputs,\n                  oracle_collateral_asset,\n                  redeemers,\n                  upper_bound,\n                )\n              when collateral_tokens_price is {\n                Aggregated(aggregated_data) -> {\n                  expect Some(token_price) =\n                    rational.new(\n                      aggregated_data.token_price_in_lovelaces,\n                      aggregated_data.denominator,\n                    )\n                  collateral_amount_rat\n                    |> rational.mul(token_price)\n                    |> rational.truncate\n                }\n\n                Pooled(pooled_data) ->\n                  finance.token_b_received_from_seling_token_a(\n                    collateral_amount_rat,\n                    pooled_data.token_a_amount,\n                    pooled_data.token_b_amount,\n                  )\n              }\n            }\n          let tag_check =\n            tag\n              |> option.map(\n                   fn(oref) {\n                     list.any(inputs, fn(in) { in.output_reference == oref })\n                   },\n                 )\n              |> option.or_else(True)\n          let token_name_oref_consumed_check =\n            list.any(inputs, fn(in) { in.output_reference == pool_utxo })\n          let datum_check = actual_datum_output == expected_collateral_datum\n\n          let overcollateralized_check =\n            finance.check_is_overcollaterized(\n              loan_value,\n              collateral_tokens_value,\n              pool_config.initial_collateral_ratio,\n            )\n          let stake_check =\n            pool_address.stake_credential == collateral_address.stake_credential\n          let valid = and {\n              collateral_amount_check?,\n              collateral_at_script_check?,\n              datum_check?,\n              minted_amount_check?,\n              overcollateralized_check?,\n              pool_nft_check?,\n              stake_check?,\n              tag_check?,\n              token_name_oref_consumed_check?,\n              dust_attack_check?,\n              valid_borrower_tn?,\n              valid_validity_range?,\n            }\n          if valid {\n            pruned_inputs |> list.tail\n          } else {\n            None\n          }\n        },\n      )\n\n    let burns_are_valid =\n      list.foldl(\n        burns,\n        Some(dict.to_list(own_mints)),\n        fn(\n          collateral_burn: BurnNFTElem,\n          curr_mints_opt: Option<List<(ByteArray, Int)>>,\n        ) -> Option<List<(ByteArray, Int)>> {\n          let BurnNFTElem(burn_coll_name) = collateral_burn\n          expect Some(curr_mints) = curr_mints_opt\n          let pruned_mints =\n            curr_mints\n              |> list.drop_while(\n                   fn(burn) {\n                     let (burn_tn, _) = burn\n                     burn_coll_name != burn_tn\n                   },\n                 )\n          expect [(_, -1)] = pruned_mints |> list.take(1)\n          list.tail(pruned_mints)\n        },\n      )\n\n    and {\n      num_minted_check?,\n      option.is_some(mints_are_valid)?,\n      option.is_some(burns_are_valid)?,\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `spend` function where the `CollateralLiquidate` branch does not properly validate the type of the redeemer. This allows a redeemer intended for a different branch to be used in the `CollateralLiquidate` logic, potentially bypassing intended checks and validations.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/collateral.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows redeemer values not intended for that branch of logic."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code neglects to verify that the correct signer (pubkey) is present in the transaction for the `CollectOrder` and `RedeemOrder` cases. This means that these operations can be executed without ensuring that the transaction is signed by the expected party, potentially allowing unauthorized users to collect or redeem orders.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is an off-by-one error in the `validation.has_spend` function call. If the function internally uses list indexing or loops, it may incorrectly handle the last element of the list, potentially skipping it or causing an out-of-bounds error. This could lead to incorrect validation of transactions, especially if the last input or redeemer is crucial for the logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for numeric overflows or underflows when handling transaction values, such as the number of inputs or withdrawals. This could lead to unexpected behavior if these values exceed the maximum or minimum limits of their data types.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not handle negative values or unexpected numeric inputs in the `validate_order` function, particularly when checking for the presence of keys in the `withdrawals` dictionary. If a negative or unexpected numeric value is used as a key, it may lead to incorrect behavior or validation failure, as the dictionary lookup assumes all keys are valid and expected.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a previously valid transaction to perform unauthorized actions, as the system does not verify if a transaction ID has already been processed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the `dict.has_key` function is used without checking if `factory_policy_id` is `None`. If `factory_policy_id` is an optional field and is `None`, the `Inline(ScriptCredential(factory_policy_id))` will incorrectly accept invalid data, as it will not properly handle the case where `factory_policy_id` is missing.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that incorrectly handles optional fields, causing unintended acceptance of invalid data."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not verify that the correct signer (pubkey) is present in the transaction. This means that any transaction that meets the other conditions can be processed, regardless of who signed it, potentially allowing unauthorized users to execute transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not check for numeric overflows or underflows when handling the integer values associated with tokens. Specifically, the `assets.tokens` function returns a dictionary of token amounts, but there is no check to ensure these amounts do not exceed the maximum integer size or go below zero, which could lead to unexpected behavior if manipulated.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is that the transaction deadline is not checked at all in the validator logic. This means that transactions can be processed without regard to any intended deadline constraints, potentially allowing transactions to be executed after they should have expired.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker could reuse a valid transaction multiple times, as there is no mechanism to ensure that each transaction is unique and cannot be replayed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aada/nft.{NFTRedeemerElement, check_uniqueness}\nuse aiken/transaction.{Mint, ScriptContext, Transaction}\n\n// This validator is used to mint unique NFTs that are later used as Delegation NFT or Protocol details NFT.\n// Where _nonce is used to differentiate between the two policyIds\n// Nonce = 1 - Delegation NFT\n// Nonce = 2 - Protocol details NFT\nvalidator(_nonce: Int) {\n  fn placeholder_nft(r: NFTRedeemerElement<Void>, ctx: ScriptContext) {\n    let ScriptContext { transaction: Transaction { inputs, mint, .. }, purpose } =\n      ctx\n    let NFTRedeemerElement { action, .. } = r\n    expect Mint(own_purpose) = purpose\n    check_uniqueness(action, inputs, mint, own_purpose)\n  }\n}", "bug_explanation": "The code does not enforce any size or structural constraints on the `action` field of the `NFTRedeemerElement`. This allows any arbitrary data to be passed as the `action`, potentially leading to unexpected behavior or vulnerabilities if the `action` is assumed to have a specific structure or size elsewhere in the contract logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/placeholder_nft.ak", "language": "ak", "bug_prompt": "Introduce a bug that accepts datum without enforcing size or structural constraints."}
{"contract": "use aada/nft.{NFTRedeemerElement, check_uniqueness}\nuse aiken/transaction.{Mint, ScriptContext, Transaction}\n\n// This validator is used to mint unique NFTs that are later used as Delegation NFT or Protocol details NFT.\n// Where _nonce is used to differentiate between the two policyIds\n// Nonce = 1 - Delegation NFT\n// Nonce = 2 - Protocol details NFT\nvalidator(_nonce: Int) {\n  fn placeholder_nft(r: NFTRedeemerElement<Void>, ctx: ScriptContext) {\n    let ScriptContext { transaction: Transaction { inputs, mint, .. }, purpose } =\n      ctx\n    let NFTRedeemerElement { action, .. } = r\n    expect Mint(own_purpose) = purpose\n    check_uniqueness(action, inputs, mint, own_purpose)\n  }\n}", "bug_explanation": "The code omits a critical check to verify the signature of the transaction, allowing unauthorized users to potentially mint NFTs without proper authorization.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/placeholder_nft.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing unauthorized access by omitting critical signature checks."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, Redeemer, ScriptContext,\n  ScriptPurpose, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse lb_v2/treasury_validation.{validate_creating_treasury_out}\nuse lb_v2/types.{\n  AddSellers, Asset, BurnSeller, CloseTreasury, CollectManager, CollectOrders,\n  CollectSellers, CreateTreasury, FactoryDatum, FactoryRedeemer, Initialization,\n  ManageOrder, ManagerDatum, MintManager, MintOrder, MintRedeemOrders,\n  MintSeller, RedeemOrders, TreasuryDatum, UsingSeller, ValidatorHash,\n}\nuse lb_v2/utils.{\n  assert, compute_lp_asset_name, factory_auth_an, make_wrapper_redeemer,\n  manager_auth_an, manager_minimum_ada, minimum_number_seller,\n  must_get_end_validity, seller_auth_an, treasury_auth_an,\n}\nuse lb_v2/validation\n\n// Spending Factory for:\n// 1. Create a new Treasury (redeemer: )\n//    - 1 Factory Input needs to be spent\n//    - 2 Factory Outputs need to be paid\n//    - 1 Factory Token needs to be mint\n//    - 1 Treasury Token needs to be mint\n//    - 1 Treasury Ouptut needs to be paid\n//    - 1 Manager Token needs to be mint\n//    - 1 Manager Ouptut needs to be paid\n//    - at least @minimum_number_seller need to be mint\n//    - at least @minimum_number_seller Seller Ouptuts need to be paid\n// 2. Close a Treasury:\n//    - 1 Treasury Token needs to be burn\n//    - 1 Treasury Input needs to be spent\n//    - 1 Factory Token needs to be burn\n//    - 2 Factory Inputs need to be spent\n//    - 1 Factory Output need to be paid\n//    - Authorize by Project Owner\nvalidator(\n  // seed output to initialize Factory Linked List \n  out_ref: OutputReference,\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n  // ValidatorHash of Seller Validator\n  manager_hash: ValidatorHash,\n  // ValidatorHash of Seller Validator\n  seller_hash: ValidatorHash,\n  // ValidatorHash of Order Validator\n  order_hash: ValidatorHash,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(factory_ref) } = context\n    let Transaction {\n      inputs,\n      mint,\n      outputs,\n      extra_signatories,\n      validity_range,\n      ..\n    } = transaction\n    // find own's input to get `factory_hash`\n    expect Some(Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(factory_hash),\n          ..\n        },\n        ..\n      },\n      ..\n    }) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: in_out_ref, .. } = input\n          in_out_ref == factory_ref\n        },\n      )\n    // find all Factory Inputs\n    let factory_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          payment_credential == ScriptCredential(factory_hash)\n        },\n      )\n    // find all Factory Outputs\n    let factory_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: Address { payment_credential, .. }, .. } =\n            output\n          payment_credential == ScriptCredential(factory_hash)\n        },\n      )\n    // Extract some necessary data.\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let (base_asset, raise_asset) =\n      when redeemer is {\n        CreateTreasury { base_asset: d_base_asset, raise_asset: d_raise_asset } ->\n          (d_base_asset, d_raise_asset)\n        CloseTreasury { base_asset: d_base_asset, raise_asset: d_raise_asset } ->\n          (d_base_asset, d_raise_asset)\n        _ -> fail @\"Only spending Factory Input when Create | Close Treasury\"\n      }\n    // sort to compute `asset_a`, `asset_b` in term AMM Pool Assets  \n    let (asset_a, asset_b) = utils.sort_two_assets(base_asset, raise_asset)\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // Compute `lp_asset_name` in term AMM Pool LP Token\n    let lp_asset_name =\n      compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    when redeemer is {\n      CreateTreasury { .. } -> {\n        let Transaction { datums, .. } = transaction\n        // finding exactly 1 Factory Input\n        expect [factory_input] = factory_inputs\n        // finding exactly 2 Factory Outputs\n        expect [f_out_head, f_out_tail] = factory_outputs\n        // finding exactly 1 Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs: outputs,\n            factory_policy_id: factory_hash,\n            treasury_hash: treasury_hash,\n          )\n        // finding exactly 1 Manager Output\n        expect [manager_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              // output belongs Manager Address\n              payment_credential == ScriptCredential(manager_hash)\n            },\n          )\n        // Extract some necessary data.\n        let Input { output: Output { value: factory_input_value, .. }, .. } =\n          factory_input\n        let Output {\n          datum: f_out_head_datum,\n          value: f_out_head_value,\n          reference_script: f_out_head_ref_script,\n          ..\n        } = f_out_head\n        let Output {\n          datum: f_out_tail_datum,\n          value: f_out_tail_value,\n          reference_script: f_out_tail_ref_script,\n          ..\n        } = f_out_tail\n        let mint_value = value.from_minted_value(mint)\n        let mint_seller_count =\n          value.quantity_of(mint_value, factory_hash, seller_auth_an)\n        let default_manager_output =\n          build_default_manager_output(\n            factory_policy_id: factory_hash,\n            manager_hash: manager_hash,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            seller_count: mint_seller_count,\n          )\n        // Trivial Assertions\n        expect\n          assert(\n            value.quantity_of(\n              factory_input_value,\n              factory_hash,\n              factory_auth_an,\n            ) == 1,\n            @\"Factory Input must be Legit!\",\n          )\n        expect assert(and {\n              // validate that new Factory UTxO datum must be followed by Linked List rule\n              // (old head, old tail) -> (old head, LP Token Name) and (LP Token Name, old tail)\n              // old head < LP Token Name < old tail\n              builtin.less_than_bytearray(current_head, lp_asset_name),\n              builtin.less_than_bytearray(lp_asset_name, current_tail),\n              // Factory Output must contains 1 Factory Token\n              value.quantity_of(f_out_head_value, factory_hash, factory_auth_an) == 1,\n              value.quantity_of(f_out_tail_value, factory_hash, factory_auth_an) == 1,\n              // Factory Output must contains only ADA and Factory Token\n              list.length(value.flatten(f_out_head_value)) == 2,\n              list.length(value.flatten(f_out_tail_value)) == 2,\n              // Head Factory Datum must be correct!\n              f_out_head_datum == InlineDatum(\n                FactoryDatum { head: current_head, tail: lp_asset_name },\n              ),\n              // Tail Factory Datum must be correct!\n              f_out_tail_datum == InlineDatum(\n                FactoryDatum { head: lp_asset_name, tail: current_tail },\n              ),\n              // Prevent Factory Output becoming heavy!\n              f_out_head_ref_script == None,\n              f_out_tail_ref_script == None,\n            }, @\"2 Factory Outputs must pay correctly!\")\n        // Assertions:\n        and {\n          // Manager Output must pay correctly!\n          manager_output == default_manager_output,\n          // Must prepare enough Sellers\n          mint_seller_count >= minimum_number_seller,\n          // Seller Outputs must pay correctly!\n          validation.validate_seller_outputs(\n            outputs: outputs,\n            factory_policy_id: factory_hash,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            seller_hash: seller_hash,\n            seller_count: mint_seller_count,\n          ),\n          // Treasury Output must pay correctly!\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_hash,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // Mint Value must be correct!\n          mint_value == get_minting_treasury(\n            factory_policy_id: factory_hash,\n            seller_count: mint_seller_count,\n          ),\n        }\n      }\n      CloseTreasury { .. } -> {\n        // finding exactly 2 Factory Inputs\n        expect [factory_input_1, factory_input_2] = factory_inputs\n        // finding exactly 1 Factory Output\n        expect [factory_output] = factory_outputs\n        // finding exactly 1 Treasury Input\n        expect [treasury_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  ..\n                },\n                ..\n              } = input\n              payment_credential == ScriptCredential(treasury_hash)\n            },\n          )\n        // extract some necessary data\n        expect Input {\n          output: Output {\n            datum: InlineDatum(factory_input_1_raw_datum),\n            value: factory_input_1_value,\n            ..\n          },\n          ..\n        } = factory_input_1\n        expect Input {\n          output: Output {\n            datum: InlineDatum(factory_input_2_raw_datum),\n            value: factory_input_2_value,\n            ..\n          },\n          ..\n        } = factory_input_2\n        expect Output {\n          value: factory_out_value,\n          datum: InlineDatum(factory_out_datum),\n          reference_script: factory_out_ref_script,\n          ..\n        } = factory_output\n        expect Input {\n          output: Output {\n            datum: InlineDatum(treasury_datum_raw),\n            value: treasury_in_value,\n            ..\n          },\n          ..\n        } = treasury_input\n        expect treasury_datum: TreasuryDatum = treasury_datum_raw\n        let TreasuryDatum {\n          base_asset: t_base_asset,\n          raise_asset: t_raise_asset,\n          owner,\n          is_cancelled,\n          reserve_raise,\n          total_penalty,\n          is_manager_collected,\n          ..\n        } = treasury_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        and {\n          // Auth Token Assertions:\n          value.quantity_of(\n            factory_input_1_value,\n            factory_hash,\n            factory_auth_an,\n          ) == 1,\n          value.quantity_of(\n            factory_input_2_value,\n            factory_hash,\n            factory_auth_an,\n          ) == 1,\n          value.quantity_of(factory_out_value, factory_hash, factory_auth_an) == 1,\n          value.quantity_of(treasury_in_value, factory_hash, treasury_auth_an) == 1,\n          // Remove Factory Linked List must be correct!\n          validate_factory_remove_node(\n            out_datum: factory_out_datum,\n            in_datum_1: factory_input_1_raw_datum,\n            in_datum_2: factory_input_2_raw_datum,\n            lp_asset_name: lp_asset_name,\n          ),\n          list.length(value.flatten(factory_out_value)) == 2,\n          factory_out_ref_script == None,\n          // LBE ID Assertions\n          t_base_asset == base_asset,\n          t_raise_asset == raise_asset,\n          value.from_minted_value(mint) == get_burning_treasury(\n            factory_policy_id: factory_hash,\n          ),\n          // authorize by owner\n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // LBE should already cancelled\n          is_cancelled,\n          // All Manager, Sellers must be collected!\n          is_manager_collected,\n          // All Orders have been executed.\n          reserve_raise == 0,\n          // All Penalty have been handled.\n          total_penalty == 0,\n        }\n      }\n      _ -> False\n    }\n  }\n\n  fn validate_factory_minting(redeemer: FactoryRedeemer, context: ScriptContext) {\n    let ScriptContext {\n      transaction: Transaction { inputs, outputs, redeemers, mint, .. },\n      purpose,\n    } = context\n    let mint_value = value.from_minted_value(mint)\n    when purpose is {\n      WithdrawFrom(stake_credential) -> {\n        expect Inline(ScriptCredential(factory_policy_id)) = stake_credential\n        and {\n          when value.flatten(mint_value) is {\n            [] ->\n              // Delegate validation logic to the Treasury Validator.\n              validation.has_spend(\n                inputs: inputs,\n                auth_policy_id: factory_policy_id,\n                auth_asset_name: treasury_auth_an,\n                validator_hash: treasury_hash,\n                redeemers: redeemers,\n                expected_redeemer: CollectOrders,\n              )\n            _ ->\n              // Delegate validation logic to the Treasury Validator.\n              validation.has_spend(\n                inputs: inputs,\n                auth_policy_id: factory_policy_id,\n                auth_asset_name: treasury_auth_an,\n                validator_hash: treasury_hash,\n                redeemers: redeemers,\n                expected_redeemer: RedeemOrders,\n              )\n          },\n          redeemer == ManageOrder,\n        }\n      }\n      Mint(factory_policy_id) ->\n        when redeemer is {\n          // Init Factory Linked List\n          Initialization ->\n            validate_initialization(\n              inputs: inputs,\n              outputs: outputs,\n              factory_policy_id: factory_policy_id,\n              out_ref: out_ref,\n              mint_value: mint_value,\n            )\n          // Delegate validation logic to the Treasury Validator.\n          CreateTreasury { .. } ->\n            has_spend_factory(inputs, factory_policy_id, redeemers, redeemer)\n          // Delegate validation logic to the Treasury Validator.\n          CloseTreasury { .. } ->\n            has_spend_factory(inputs, factory_policy_id, redeemers, redeemer)\n          // Collect Manager Transaction note:\n          //   1 Manager Token needs to be burned (trigger Factory Minting)\n          //   1 Manager Input needs to be spent\n          //   1 Treasury Input needs to be spent\n          //   1 Treasury Output needs to be paid\n          // Delegate validation logic to the Treasury Validator.\n          MintManager ->\n            // Delegate validation logic to the Treasury Validator.\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: treasury_auth_an,\n              validator_hash: treasury_hash,\n              redeemers: redeemers,\n              expected_redeemer: CollectManager,\n            )\n          MintSeller ->\n            // Delegate Logic to Manager Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: manager_auth_an,\n              validator_hash: manager_hash,\n              redeemers: redeemers,\n              expected_redeemer: AddSellers,\n            )\n          BurnSeller ->\n            // Delegate Logic to Manager Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: manager_auth_an,\n              validator_hash: manager_hash,\n              redeemers: redeemers,\n              expected_redeemer: CollectSellers,\n            )\n          MintOrder ->\n            // Delegate Logic to Seller Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: seller_auth_an,\n              validator_hash: seller_hash,\n              redeemers: redeemers,\n              expected_redeemer: UsingSeller,\n            )\n          MintRedeemOrders ->\n            // Delegate validation logic to the Treasury Validator.\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: treasury_auth_an,\n              validator_hash: treasury_hash,\n              redeemers: redeemers,\n              expected_redeemer: RedeemOrders,\n            )\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}\n\n// Validate Transaction Init Factory Linked List\n// Assertions:\n// - Spending @out_ref\n// - Mint 1 Factory Token\n// - Paying 1 Legitimate Factory Token\nfn validate_initialization(\n  inputs: List<Input>,\n  outputs: List<Output>,\n  factory_policy_id: PolicyId,\n  out_ref: OutputReference,\n  mint_value: Value,\n) -> Bool {\n  // Ensure transaction's outptus contain exactly 1 Factory Output \n  expect [\n    Output {\n      value: out_value,\n      datum,\n      reference_script: factory_reference_script,\n      ..\n    },\n  ] =\n    list.filter(\n      outputs,\n      fn(output) {\n        let Output { address: Address { payment_credential, .. }, .. } = output\n        payment_credential == ScriptCredential(factory_policy_id)\n      },\n    )\n  and {\n    factory_reference_script == None,\n    list.length(value.flatten(out_value)) == 2,\n    // Must spend @out_ref\n    list.any(\n      inputs,\n      fn(input) {\n        let Input { output_reference, .. } = input\n        output_reference == out_ref\n      },\n    ),\n    // Must mint 1 Factory Token\n    value.flatten(mint_value) == [(factory_policy_id, factory_auth_an, 1)],\n    // Factory Output must contain 1 Factory Token\n    value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n    // Factory Datum must be correct!\n    datum == InlineDatum(\n      FactoryDatum {\n        head: #\"00\",\n        tail: #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n      },\n    ),\n  }\n}\n\n// Transaction's spending Legit Factory Input base on `expected_redeemer`\nfn has_spend_factory(\n  inputs: List<Input>,\n  factory_hash: ValidatorHash,\n  redeemers: Dict<ScriptPurpose, Redeemer>,\n  expected_redeemer: FactoryRedeemer,\n) -> Bool {\n  // finding Legit Factory Inputs\n  let factory_inputs =\n    list.filter(\n      inputs,\n      fn(input) {\n        let Input {\n          output: Output {\n            address: Address { payment_credential, .. },\n            value: in_value,\n            ..\n          },\n          ..\n        } = input\n        and {\n          // input belongs Treasury Address\n          payment_credential == ScriptCredential(factory_hash),\n          // Factory Input must contains exactly 1 Factory Token\n          value.quantity_of(in_value, factory_hash, factory_auth_an) == 1,\n        }\n      },\n    )\n  // wrapping Factory Mint Redeemer -> Factory Spend Redeemer\n  let wrapper_redeemer = Some(make_wrapper_redeemer(expected_redeemer))\n  when expected_redeemer is {\n    CreateTreasury { .. } -> {\n      // CreateTreasury require only 1 Factory Input\n      expect [Input { output_reference, .. }] = factory_inputs\n      dict.get(redeemers, Spend(output_reference)) == wrapper_redeemer\n    }\n    CloseTreasury { .. } -> {\n      // CloseTreasury require 2 Factory Inputs as Head, Tail node\n      expect [\n        Input { output_reference: head_out_ref, .. },\n        Input { output_reference: tail_out_ref, .. },\n      ] = factory_inputs\n      and {\n        dict.get(redeemers, Spend(head_out_ref)) == wrapper_redeemer,\n        dict.get(redeemers, Spend(tail_out_ref)) == wrapper_redeemer,\n      }\n    }\n    _ -> False\n  }\n}\n\n// return Manager Output when creating Treasury\nfn build_default_manager_output(\n  factory_policy_id: ValidatorHash,\n  manager_hash: ValidatorHash,\n  base_asset: Asset,\n  raise_asset: Asset,\n  seller_count: Int,\n) -> Output {\n  let manager_address = credential.from_script(manager_hash)\n  // build default manager datum\n  let manager_datum =\n    ManagerDatum {\n      factory_policy_id,\n      base_asset,\n      raise_asset,\n      seller_count,\n      reserve_raise: 0,\n      total_penalty: 0,\n    }\n  // build default manager value\n  let manager_value =\n    value.from_lovelace(manager_minimum_ada)\n      |> value.add(factory_policy_id, manager_auth_an, 1)\n  Output {\n    address: manager_address,\n    value: manager_value,\n    datum: InlineDatum(manager_datum),\n    reference_script: None,\n  }\n}\n\n// Close LBE require remove 1 node from Factory Linked List\n// Logic remove node from Linked List is classic!\nfn validate_factory_remove_node(\n  // Factory Out Datum Raw\n  out_datum: Data,\n  // First Factory In Datum Raw\n  in_datum_1: Data,\n  // Second Factory In Datum Raw\n  in_datum_2: Data,\n  // LP Asset Name of LBE\n  lp_asset_name: AssetName,\n) -> Bool {\n  // sorting to find Head, Tail Node in term Factory Linked List\n  let (head_datum_raw, tail_datum_raw) =\n    utils.sort_two_consecutive_factory_datum(in_datum_1, in_datum_2)\n  expect head_datum: FactoryDatum = head_datum_raw\n  expect tail_datum: FactoryDatum = tail_datum_raw\n  expect factory_out_datum: FactoryDatum = out_datum\n  and {\n    factory_out_datum == FactoryDatum {\n      head: head_datum.head,\n      tail: tail_datum.tail,\n    },\n    head_datum.tail == lp_asset_name,\n    tail_datum.head == lp_asset_name,\n  }\n}\n\n// return Mint Value when creating new Treasury\nfn get_minting_treasury(factory_policy_id: PolicyId, seller_count: Int) -> Value {\n  value.from_asset(factory_policy_id, factory_auth_an, 1)\n    |> value.add(factory_policy_id, treasury_auth_an, 1)\n    |> value.add(factory_policy_id, manager_auth_an, 1)\n    |> value.add(factory_policy_id, seller_auth_an, seller_count)\n}\n\n// return Mint Value when close a Treasury\nfn get_burning_treasury(factory_policy_id: PolicyId) -> Value {\n  value.from_asset(factory_policy_id, factory_auth_an, -1)\n    |> value.add(factory_policy_id, treasury_auth_an, -1)\n}", "bug_explanation": "The bug is introduced by omitting the validation of the token name in the `validate_factory_minting` function. This allows for unrestricted token minting without checking the asset name, which can lead to unauthorized minting of tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/factory.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, Redeemer, ScriptContext,\n  ScriptPurpose, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse lb_v2/treasury_validation.{validate_creating_treasury_out}\nuse lb_v2/types.{\n  AddSellers, Asset, BurnSeller, CloseTreasury, CollectManager, CollectOrders,\n  CollectSellers, CreateTreasury, FactoryDatum, FactoryRedeemer, Initialization,\n  ManageOrder, ManagerDatum, MintManager, MintOrder, MintRedeemOrders,\n  MintSeller, RedeemOrders, TreasuryDatum, UsingSeller, ValidatorHash,\n}\nuse lb_v2/utils.{\n  assert, compute_lp_asset_name, factory_auth_an, make_wrapper_redeemer,\n  manager_auth_an, manager_minimum_ada, minimum_number_seller,\n  must_get_end_validity, seller_auth_an, treasury_auth_an,\n}\nuse lb_v2/validation\n\n// Spending Factory for:\n// 1. Create a new Treasury (redeemer: )\n//    - 1 Factory Input needs to be spent\n//    - 2 Factory Outputs need to be paid\n//    - 1 Factory Token needs to be mint\n//    - 1 Treasury Token needs to be mint\n//    - 1 Treasury Ouptut needs to be paid\n//    - 1 Manager Token needs to be mint\n//    - 1 Manager Ouptut needs to be paid\n//    - at least @minimum_number_seller need to be mint\n//    - at least @minimum_number_seller Seller Ouptuts need to be paid\n// 2. Close a Treasury:\n//    - 1 Treasury Token needs to be burn\n//    - 1 Treasury Input needs to be spent\n//    - 1 Factory Token needs to be burn\n//    - 2 Factory Inputs need to be spent\n//    - 1 Factory Output need to be paid\n//    - Authorize by Project Owner\nvalidator(\n  // seed output to initialize Factory Linked List \n  out_ref: OutputReference,\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n  // ValidatorHash of Seller Validator\n  manager_hash: ValidatorHash,\n  // ValidatorHash of Seller Validator\n  seller_hash: ValidatorHash,\n  // ValidatorHash of Order Validator\n  order_hash: ValidatorHash,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(factory_ref) } = context\n    let Transaction {\n      inputs,\n      mint,\n      outputs,\n      extra_signatories,\n      validity_range,\n      ..\n    } = transaction\n    // find own's input to get `factory_hash`\n    expect Some(Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(factory_hash),\n          ..\n        },\n        ..\n      },\n      ..\n    }) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: in_out_ref, .. } = input\n          in_out_ref == factory_ref\n        },\n      )\n    // find all Factory Inputs\n    let factory_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          payment_credential == ScriptCredential(factory_hash)\n        },\n      )\n    // find all Factory Outputs\n    let factory_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: Address { payment_credential, .. }, .. } =\n            output\n          payment_credential == ScriptCredential(factory_hash)\n        },\n      )\n    // Extract some necessary data.\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let (base_asset, raise_asset) =\n      when redeemer is {\n        CreateTreasury { base_asset: d_base_asset, raise_asset: d_raise_asset } ->\n          (d_base_asset, d_raise_asset)\n        CloseTreasury { base_asset: d_base_asset, raise_asset: d_raise_asset } ->\n          (d_base_asset, d_raise_asset)\n        _ -> fail @\"Only spending Factory Input when Create | Close Treasury\"\n      }\n    // sort to compute `asset_a`, `asset_b` in term AMM Pool Assets  \n    let (asset_a, asset_b) = utils.sort_two_assets(base_asset, raise_asset)\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // Compute `lp_asset_name` in term AMM Pool LP Token\n    let lp_asset_name =\n      compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    when redeemer is {\n      CreateTreasury { .. } -> {\n        let Transaction { datums, .. } = transaction\n        // finding exactly 1 Factory Input\n        expect [factory_input] = factory_inputs\n        // finding exactly 2 Factory Outputs\n        expect [f_out_head, f_out_tail] = factory_outputs\n        // finding exactly 1 Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs: outputs,\n            factory_policy_id: factory_hash,\n            treasury_hash: treasury_hash,\n          )\n        // finding exactly 1 Manager Output\n        expect [manager_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              // output belongs Manager Address\n              payment_credential == ScriptCredential(manager_hash)\n            },\n          )\n        // Extract some necessary data.\n        let Input { output: Output { value: factory_input_value, .. }, .. } =\n          factory_input\n        let Output {\n          datum: f_out_head_datum,\n          value: f_out_head_value,\n          reference_script: f_out_head_ref_script,\n          ..\n        } = f_out_head\n        let Output {\n          datum: f_out_tail_datum,\n          value: f_out_tail_value,\n          reference_script: f_out_tail_ref_script,\n          ..\n        } = f_out_tail\n        let mint_value = value.from_minted_value(mint)\n        let mint_seller_count =\n          value.quantity_of(mint_value, factory_hash, seller_auth_an)\n        let default_manager_output =\n          build_default_manager_output(\n            factory_policy_id: factory_hash,\n            manager_hash: manager_hash,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            seller_count: mint_seller_count,\n          )\n        // Trivial Assertions\n        expect\n          assert(\n            value.quantity_of(\n              factory_input_value,\n              factory_hash,\n              factory_auth_an,\n            ) == 1,\n            @\"Factory Input must be Legit!\",\n          )\n        expect assert(and {\n              // validate that new Factory UTxO datum must be followed by Linked List rule\n              // (old head, old tail) -> (old head, LP Token Name) and (LP Token Name, old tail)\n              // old head < LP Token Name < old tail\n              builtin.less_than_bytearray(current_head, lp_asset_name),\n              builtin.less_than_bytearray(lp_asset_name, current_tail),\n              // Factory Output must contains 1 Factory Token\n              value.quantity_of(f_out_head_value, factory_hash, factory_auth_an) == 1,\n              value.quantity_of(f_out_tail_value, factory_hash, factory_auth_an) == 1,\n              // Factory Output must contains only ADA and Factory Token\n              list.length(value.flatten(f_out_head_value)) == 2,\n              list.length(value.flatten(f_out_tail_value)) == 2,\n              // Head Factory Datum must be correct!\n              f_out_head_datum == InlineDatum(\n                FactoryDatum { head: current_head, tail: lp_asset_name },\n              ),\n              // Tail Factory Datum must be correct!\n              f_out_tail_datum == InlineDatum(\n                FactoryDatum { head: lp_asset_name, tail: current_tail },\n              ),\n              // Prevent Factory Output becoming heavy!\n              f_out_head_ref_script == None,\n              f_out_tail_ref_script == None,\n            }, @\"2 Factory Outputs must pay correctly!\")\n        // Assertions:\n        and {\n          // Manager Output must pay correctly!\n          manager_output == default_manager_output,\n          // Must prepare enough Sellers\n          mint_seller_count >= minimum_number_seller,\n          // Seller Outputs must pay correctly!\n          validation.validate_seller_outputs(\n            outputs: outputs,\n            factory_policy_id: factory_hash,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            seller_hash: seller_hash,\n            seller_count: mint_seller_count,\n          ),\n          // Treasury Output must pay correctly!\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_hash,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // Mint Value must be correct!\n          mint_value == get_minting_treasury(\n            factory_policy_id: factory_hash,\n            seller_count: mint_seller_count,\n          ),\n        }\n      }\n      CloseTreasury { .. } -> {\n        // finding exactly 2 Factory Inputs\n        expect [factory_input_1, factory_input_2] = factory_inputs\n        // finding exactly 1 Factory Output\n        expect [factory_output] = factory_outputs\n        // finding exactly 1 Treasury Input\n        expect [treasury_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  ..\n                },\n                ..\n              } = input\n              payment_credential == ScriptCredential(treasury_hash)\n            },\n          )\n        // extract some necessary data\n        expect Input {\n          output: Output {\n            datum: InlineDatum(factory_input_1_raw_datum),\n            value: factory_input_1_value,\n            ..\n          },\n          ..\n        } = factory_input_1\n        expect Input {\n          output: Output {\n            datum: InlineDatum(factory_input_2_raw_datum),\n            value: factory_input_2_value,\n            ..\n          },\n          ..\n        } = factory_input_2\n        expect Output {\n          value: factory_out_value,\n          datum: InlineDatum(factory_out_datum),\n          reference_script: factory_out_ref_script,\n          ..\n        } = factory_output\n        expect Input {\n          output: Output {\n            datum: InlineDatum(treasury_datum_raw),\n            value: treasury_in_value,\n            ..\n          },\n          ..\n        } = treasury_input\n        expect treasury_datum: TreasuryDatum = treasury_datum_raw\n        let TreasuryDatum {\n          base_asset: t_base_asset,\n          raise_asset: t_raise_asset,\n          owner,\n          is_cancelled,\n          reserve_raise,\n          total_penalty,\n          is_manager_collected,\n          ..\n        } = treasury_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        and {\n          // Auth Token Assertions:\n          value.quantity_of(\n            factory_input_1_value,\n            factory_hash,\n            factory_auth_an,\n          ) == 1,\n          value.quantity_of(\n            factory_input_2_value,\n            factory_hash,\n            factory_auth_an,\n          ) == 1,\n          value.quantity_of(factory_out_value, factory_hash, factory_auth_an) == 1,\n          value.quantity_of(treasury_in_value, factory_hash, treasury_auth_an) == 1,\n          // Remove Factory Linked List must be correct!\n          validate_factory_remove_node(\n            out_datum: factory_out_datum,\n            in_datum_1: factory_input_1_raw_datum,\n            in_datum_2: factory_input_2_raw_datum,\n            lp_asset_name: lp_asset_name,\n          ),\n          list.length(value.flatten(factory_out_value)) == 2,\n          factory_out_ref_script == None,\n          // LBE ID Assertions\n          t_base_asset == base_asset,\n          t_raise_asset == raise_asset,\n          value.from_minted_value(mint) == get_burning_treasury(\n            factory_policy_id: factory_hash,\n          ),\n          // authorize by owner\n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // LBE should already cancelled\n          is_cancelled,\n          // All Manager, Sellers must be collected!\n          is_manager_collected,\n          // All Orders have been executed.\n          reserve_raise == 0,\n          // All Penalty have been handled.\n          total_penalty == 0,\n        }\n      }\n      _ -> False\n    }\n  }\n\n  fn validate_factory_minting(redeemer: FactoryRedeemer, context: ScriptContext) {\n    let ScriptContext {\n      transaction: Transaction { inputs, outputs, redeemers, mint, .. },\n      purpose,\n    } = context\n    let mint_value = value.from_minted_value(mint)\n    when purpose is {\n      WithdrawFrom(stake_credential) -> {\n        expect Inline(ScriptCredential(factory_policy_id)) = stake_credential\n        and {\n          when value.flatten(mint_value) is {\n            [] ->\n              // Delegate validation logic to the Treasury Validator.\n              validation.has_spend(\n                inputs: inputs,\n                auth_policy_id: factory_policy_id,\n                auth_asset_name: treasury_auth_an,\n                validator_hash: treasury_hash,\n                redeemers: redeemers,\n                expected_redeemer: CollectOrders,\n              )\n            _ ->\n              // Delegate validation logic to the Treasury Validator.\n              validation.has_spend(\n                inputs: inputs,\n                auth_policy_id: factory_policy_id,\n                auth_asset_name: treasury_auth_an,\n                validator_hash: treasury_hash,\n                redeemers: redeemers,\n                expected_redeemer: RedeemOrders,\n              )\n          },\n          redeemer == ManageOrder,\n        }\n      }\n      Mint(factory_policy_id) ->\n        when redeemer is {\n          // Init Factory Linked List\n          Initialization ->\n            validate_initialization(\n              inputs: inputs,\n              outputs: outputs,\n              factory_policy_id: factory_policy_id,\n              out_ref: out_ref,\n              mint_value: mint_value,\n            )\n          // Delegate validation logic to the Treasury Validator.\n          CreateTreasury { .. } ->\n            has_spend_factory(inputs, factory_policy_id, redeemers, redeemer)\n          // Delegate validation logic to the Treasury Validator.\n          CloseTreasury { .. } ->\n            has_spend_factory(inputs, factory_policy_id, redeemers, redeemer)\n          // Collect Manager Transaction note:\n          //   1 Manager Token needs to be burned (trigger Factory Minting)\n          //   1 Manager Input needs to be spent\n          //   1 Treasury Input needs to be spent\n          //   1 Treasury Output needs to be paid\n          // Delegate validation logic to the Treasury Validator.\n          MintManager ->\n            // Delegate validation logic to the Treasury Validator.\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: treasury_auth_an,\n              validator_hash: treasury_hash,\n              redeemers: redeemers,\n              expected_redeemer: CollectManager,\n            )\n          MintSeller ->\n            // Delegate Logic to Manager Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: manager_auth_an,\n              validator_hash: manager_hash,\n              redeemers: redeemers,\n              expected_redeemer: AddSellers,\n            )\n          BurnSeller ->\n            // Delegate Logic to Manager Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: manager_auth_an,\n              validator_hash: manager_hash,\n              redeemers: redeemers,\n              expected_redeemer: CollectSellers,\n            )\n          MintOrder ->\n            // Delegate Logic to Seller Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: seller_auth_an,\n              validator_hash: seller_hash,\n              redeemers: redeemers,\n              expected_redeemer: UsingSeller,\n            )\n          MintRedeemOrders ->\n            // Delegate validation logic to the Treasury Validator.\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: treasury_auth_an,\n              validator_hash: treasury_hash,\n              redeemers: redeemers,\n              expected_redeemer: RedeemOrders,\n            )\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}\n\n// Validate Transaction Init Factory Linked List\n// Assertions:\n// - Spending @out_ref\n// - Mint 1 Factory Token\n// - Paying 1 Legitimate Factory Token\nfn validate_initialization(\n  inputs: List<Input>,\n  outputs: List<Output>,\n  factory_policy_id: PolicyId,\n  out_ref: OutputReference,\n  mint_value: Value,\n) -> Bool {\n  // Ensure transaction's outptus contain exactly 1 Factory Output \n  expect [\n    Output {\n      value: out_value,\n      datum,\n      reference_script: factory_reference_script,\n      ..\n    },\n  ] =\n    list.filter(\n      outputs,\n      fn(output) {\n        let Output { address: Address { payment_credential, .. }, .. } = output\n        payment_credential == ScriptCredential(factory_policy_id)\n      },\n    )\n  and {\n    factory_reference_script == None,\n    list.length(value.flatten(out_value)) == 2,\n    // Must spend @out_ref\n    list.any(\n      inputs,\n      fn(input) {\n        let Input { output_reference, .. } = input\n        output_reference == out_ref\n      },\n    ),\n    // Must mint 1 Factory Token\n    value.flatten(mint_value) == [(factory_policy_id, factory_auth_an, 1)],\n    // Factory Output must contain 1 Factory Token\n    value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n    // Factory Datum must be correct!\n    datum == InlineDatum(\n      FactoryDatum {\n        head: #\"00\",\n        tail: #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n      },\n    ),\n  }\n}\n\n// Transaction's spending Legit Factory Input base on `expected_redeemer`\nfn has_spend_factory(\n  inputs: List<Input>,\n  factory_hash: ValidatorHash,\n  redeemers: Dict<ScriptPurpose, Redeemer>,\n  expected_redeemer: FactoryRedeemer,\n) -> Bool {\n  // finding Legit Factory Inputs\n  let factory_inputs =\n    list.filter(\n      inputs,\n      fn(input) {\n        let Input {\n          output: Output {\n            address: Address { payment_credential, .. },\n            value: in_value,\n            ..\n          },\n          ..\n        } = input\n        and {\n          // input belongs Treasury Address\n          payment_credential == ScriptCredential(factory_hash),\n          // Factory Input must contains exactly 1 Factory Token\n          value.quantity_of(in_value, factory_hash, factory_auth_an) == 1,\n        }\n      },\n    )\n  // wrapping Factory Mint Redeemer -> Factory Spend Redeemer\n  let wrapper_redeemer = Some(make_wrapper_redeemer(expected_redeemer))\n  when expected_redeemer is {\n    CreateTreasury { .. } -> {\n      // CreateTreasury require only 1 Factory Input\n      expect [Input { output_reference, .. }] = factory_inputs\n      dict.get(redeemers, Spend(output_reference)) == wrapper_redeemer\n    }\n    CloseTreasury { .. } -> {\n      // CloseTreasury require 2 Factory Inputs as Head, Tail node\n      expect [\n        Input { output_reference: head_out_ref, .. },\n        Input { output_reference: tail_out_ref, .. },\n      ] = factory_inputs\n      and {\n        dict.get(redeemers, Spend(head_out_ref)) == wrapper_redeemer,\n        dict.get(redeemers, Spend(tail_out_ref)) == wrapper_redeemer,\n      }\n    }\n    _ -> False\n  }\n}\n\n// return Manager Output when creating Treasury\nfn build_default_manager_output(\n  factory_policy_id: ValidatorHash,\n  manager_hash: ValidatorHash,\n  base_asset: Asset,\n  raise_asset: Asset,\n  seller_count: Int,\n) -> Output {\n  let manager_address = credential.from_script(manager_hash)\n  // build default manager datum\n  let manager_datum =\n    ManagerDatum {\n      factory_policy_id,\n      base_asset,\n      raise_asset,\n      seller_count,\n      reserve_raise: 0,\n      total_penalty: 0,\n    }\n  // build default manager value\n  let manager_value =\n    value.from_lovelace(manager_minimum_ada)\n      |> value.add(factory_policy_id, manager_auth_an, 1)\n  Output {\n    address: manager_address,\n    value: manager_value,\n    datum: InlineDatum(manager_datum),\n    reference_script: None,\n  }\n}\n\n// Close LBE require remove 1 node from Factory Linked List\n// Logic remove node from Linked List is classic!\nfn validate_factory_remove_node(\n  // Factory Out Datum Raw\n  out_datum: Data,\n  // First Factory In Datum Raw\n  in_datum_1: Data,\n  // Second Factory In Datum Raw\n  in_datum_2: Data,\n  // LP Asset Name of LBE\n  lp_asset_name: AssetName,\n) -> Bool {\n  // sorting to find Head, Tail Node in term Factory Linked List\n  let (head_datum_raw, tail_datum_raw) =\n    utils.sort_two_consecutive_factory_datum(in_datum_1, in_datum_2)\n  expect head_datum: FactoryDatum = head_datum_raw\n  expect tail_datum: FactoryDatum = tail_datum_raw\n  expect factory_out_datum: FactoryDatum = out_datum\n  and {\n    factory_out_datum == FactoryDatum {\n      head: head_datum.head,\n      tail: tail_datum.tail,\n    },\n    head_datum.tail == lp_asset_name,\n    tail_datum.head == lp_asset_name,\n  }\n}\n\n// return Mint Value when creating new Treasury\nfn get_minting_treasury(factory_policy_id: PolicyId, seller_count: Int) -> Value {\n  value.from_asset(factory_policy_id, factory_auth_an, 1)\n    |> value.add(factory_policy_id, treasury_auth_an, 1)\n    |> value.add(factory_policy_id, manager_auth_an, 1)\n    |> value.add(factory_policy_id, seller_auth_an, seller_count)\n}\n\n// return Mint Value when close a Treasury\nfn get_burning_treasury(factory_policy_id: PolicyId) -> Value {\n  value.from_asset(factory_policy_id, factory_auth_an, -1)\n    |> value.add(factory_policy_id, treasury_auth_an, -1)\n}", "bug_explanation": "The bug is introduced by not enforcing any size or structural constraints on the `datum` parameter in the `validate_factory` function. This allows any datum to be accepted without validation, potentially leading to incorrect or malicious data being processed by the contract.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/factory.ak", "language": "ak", "bug_prompt": "Introduce a bug that accepts datum without enforcing size or structural constraints."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, Redeemer, ScriptContext,\n  ScriptPurpose, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse lb_v2/treasury_validation.{validate_creating_treasury_out}\nuse lb_v2/types.{\n  AddSellers, Asset, BurnSeller, CloseTreasury, CollectManager, CollectOrders,\n  CollectSellers, CreateTreasury, FactoryDatum, FactoryRedeemer, Initialization,\n  ManageOrder, ManagerDatum, MintManager, MintOrder, MintRedeemOrders,\n  MintSeller, RedeemOrders, TreasuryDatum, UsingSeller, ValidatorHash,\n}\nuse lb_v2/utils.{\n  assert, compute_lp_asset_name, factory_auth_an, make_wrapper_redeemer,\n  manager_auth_an, manager_minimum_ada, minimum_number_seller,\n  must_get_end_validity, seller_auth_an, treasury_auth_an,\n}\nuse lb_v2/validation\n\n// Spending Factory for:\n// 1. Create a new Treasury (redeemer: )\n//    - 1 Factory Input needs to be spent\n//    - 2 Factory Outputs need to be paid\n//    - 1 Factory Token needs to be mint\n//    - 1 Treasury Token needs to be mint\n//    - 1 Treasury Ouptut needs to be paid\n//    - 1 Manager Token needs to be mint\n//    - 1 Manager Ouptut needs to be paid\n//    - at least @minimum_number_seller need to be mint\n//    - at least @minimum_number_seller Seller Ouptuts need to be paid\n// 2. Close a Treasury:\n//    - 1 Treasury Token needs to be burn\n//    - 1 Treasury Input needs to be spent\n//    - 1 Factory Token needs to be burn\n//    - 2 Factory Inputs need to be spent\n//    - 1 Factory Output need to be paid\n//    - Authorize by Project Owner\nvalidator(\n  // seed output to initialize Factory Linked List \n  out_ref: OutputReference,\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n  // ValidatorHash of Seller Validator\n  manager_hash: ValidatorHash,\n  // ValidatorHash of Seller Validator\n  seller_hash: ValidatorHash,\n  // ValidatorHash of Order Validator\n  order_hash: ValidatorHash,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(factory_ref) } = context\n    let Transaction {\n      inputs,\n      mint,\n      outputs,\n      extra_signatories,\n      validity_range,\n      ..\n    } = transaction\n    // find own's input to get `factory_hash`\n    expect Some(Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(factory_hash),\n          ..\n        },\n        ..\n      },\n      ..\n    }) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: in_out_ref, .. } = input\n          in_out_ref == factory_ref\n        },\n      )\n    // find all Factory Inputs\n    let factory_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          payment_credential == ScriptCredential(factory_hash)\n        },\n      )\n    // find all Factory Outputs\n    let factory_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: Address { payment_credential, .. }, .. } =\n            output\n          payment_credential == ScriptCredential(factory_hash)\n        },\n      )\n    // Extract some necessary data.\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let (base_asset, raise_asset) =\n      when redeemer is {\n        CreateTreasury { base_asset: d_base_asset, raise_asset: d_raise_asset } ->\n          (d_base_asset, d_raise_asset)\n        CloseTreasury { base_asset: d_base_asset, raise_asset: d_raise_asset } ->\n          (d_base_asset, d_raise_asset)\n        _ -> fail @\"Only spending Factory Input when Create | Close Treasury\"\n      }\n    // sort to compute `asset_a`, `asset_b` in term AMM Pool Assets  \n    let (asset_a, asset_b) = utils.sort_two_assets(base_asset, raise_asset)\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // Compute `lp_asset_name` in term AMM Pool LP Token\n    let lp_asset_name =\n      compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    when redeemer is {\n      CreateTreasury { .. } -> {\n        let Transaction { datums, .. } = transaction\n        // finding exactly 1 Factory Input\n        expect [factory_input] = factory_inputs\n        // finding exactly 2 Factory Outputs\n        expect [f_out_head, f_out_tail] = factory_outputs\n        // finding exactly 1 Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs: outputs,\n            factory_policy_id: factory_hash,\n            treasury_hash: treasury_hash,\n          )\n        // finding exactly 1 Manager Output\n        expect [manager_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              // output belongs Manager Address\n              payment_credential == ScriptCredential(manager_hash)\n            },\n          )\n        // Extract some necessary data.\n        let Input { output: Output { value: factory_input_value, .. }, .. } =\n          factory_input\n        let Output {\n          datum: f_out_head_datum,\n          value: f_out_head_value,\n          reference_script: f_out_head_ref_script,\n          ..\n        } = f_out_head\n        let Output {\n          datum: f_out_tail_datum,\n          value: f_out_tail_value,\n          reference_script: f_out_tail_ref_script,\n          ..\n        } = f_out_tail\n        let mint_value = value.from_minted_value(mint)\n        let mint_seller_count =\n          value.quantity_of(mint_value, factory_hash, seller_auth_an)\n        let default_manager_output =\n          build_default_manager_output(\n            factory_policy_id: factory_hash,\n            manager_hash: manager_hash,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            seller_count: mint_seller_count,\n          )\n        // Trivial Assertions\n        expect\n          assert(\n            value.quantity_of(\n              factory_input_value,\n              factory_hash,\n              factory_auth_an,\n            ) == 1,\n            @\"Factory Input must be Legit!\",\n          )\n        expect assert(and {\n              // validate that new Factory UTxO datum must be followed by Linked List rule\n              // (old head, old tail) -> (old head, LP Token Name) and (LP Token Name, old tail)\n              // old head < LP Token Name < old tail\n              builtin.less_than_bytearray(current_head, lp_asset_name),\n              builtin.less_than_bytearray(lp_asset_name, current_tail),\n              // Factory Output must contains 1 Factory Token\n              value.quantity_of(f_out_head_value, factory_hash, factory_auth_an) == 1,\n              value.quantity_of(f_out_tail_value, factory_hash, factory_auth_an) == 1,\n              // Factory Output must contains only ADA and Factory Token\n              list.length(value.flatten(f_out_head_value)) == 2,\n              list.length(value.flatten(f_out_tail_value)) == 2,\n              // Head Factory Datum must be correct!\n              f_out_head_datum == InlineDatum(\n                FactoryDatum { head: current_head, tail: lp_asset_name },\n              ),\n              // Tail Factory Datum must be correct!\n              f_out_tail_datum == InlineDatum(\n                FactoryDatum { head: lp_asset_name, tail: current_tail },\n              ),\n              // Prevent Factory Output becoming heavy!\n              f_out_head_ref_script == None,\n              f_out_tail_ref_script == None,\n            }, @\"2 Factory Outputs must pay correctly!\")\n        // Assertions:\n        and {\n          // Manager Output must pay correctly!\n          manager_output == default_manager_output,\n          // Must prepare enough Sellers\n          mint_seller_count >= minimum_number_seller,\n          // Seller Outputs must pay correctly!\n          validation.validate_seller_outputs(\n            outputs: outputs,\n            factory_policy_id: factory_hash,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            seller_hash: seller_hash,\n            seller_count: mint_seller_count,\n          ),\n          // Treasury Output must pay correctly!\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_hash,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // Mint Value must be correct!\n          mint_value == get_minting_treasury(\n            factory_policy_id: factory_hash,\n            seller_count: mint_seller_count,\n          ),\n        }\n      }\n      CloseTreasury { .. } -> {\n        // finding exactly 2 Factory Inputs\n        expect [factory_input_1, factory_input_2] = factory_inputs\n        // finding exactly 1 Factory Output\n        expect [factory_output] = factory_outputs\n        // finding exactly 1 Treasury Input\n        expect [treasury_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  ..\n                },\n                ..\n              } = input\n              payment_credential == ScriptCredential(treasury_hash)\n            },\n          )\n        // extract some necessary data\n        expect Input {\n          output: Output {\n            datum: InlineDatum(factory_input_1_raw_datum),\n            value: factory_input_1_value,\n            ..\n          },\n          ..\n        } = factory_input_1\n        expect Input {\n          output: Output {\n            datum: InlineDatum(factory_input_2_raw_datum),\n            value: factory_input_2_value,\n            ..\n          },\n          ..\n        } = factory_input_2\n        expect Output {\n          value: factory_out_value,\n          datum: InlineDatum(factory_out_datum),\n          reference_script: factory_out_ref_script,\n          ..\n        } = factory_output\n        expect Input {\n          output: Output {\n            datum: InlineDatum(treasury_datum_raw),\n            value: treasury_in_value,\n            ..\n          },\n          ..\n        } = treasury_input\n        expect treasury_datum: TreasuryDatum = treasury_datum_raw\n        let TreasuryDatum {\n          base_asset: t_base_asset,\n          raise_asset: t_raise_asset,\n          owner,\n          is_cancelled,\n          reserve_raise,\n          total_penalty,\n          is_manager_collected,\n          ..\n        } = treasury_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        and {\n          // Auth Token Assertions:\n          value.quantity_of(\n            factory_input_1_value,\n            factory_hash,\n            factory_auth_an,\n          ) == 1,\n          value.quantity_of(\n            factory_input_2_value,\n            factory_hash,\n            factory_auth_an,\n          ) == 1,\n          value.quantity_of(factory_out_value, factory_hash, factory_auth_an) == 1,\n          value.quantity_of(treasury_in_value, factory_hash, treasury_auth_an) == 1,\n          // Remove Factory Linked List must be correct!\n          validate_factory_remove_node(\n            out_datum: factory_out_datum,\n            in_datum_1: factory_input_1_raw_datum,\n            in_datum_2: factory_input_2_raw_datum,\n            lp_asset_name: lp_asset_name,\n          ),\n          list.length(value.flatten(factory_out_value)) == 2,\n          factory_out_ref_script == None,\n          // LBE ID Assertions\n          t_base_asset == base_asset,\n          t_raise_asset == raise_asset,\n          value.from_minted_value(mint) == get_burning_treasury(\n            factory_policy_id: factory_hash,\n          ),\n          // authorize by owner\n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // LBE should already cancelled\n          is_cancelled,\n          // All Manager, Sellers must be collected!\n          is_manager_collected,\n          // All Orders have been executed.\n          reserve_raise == 0,\n          // All Penalty have been handled.\n          total_penalty == 0,\n        }\n      }\n      _ -> False\n    }\n  }\n\n  fn validate_factory_minting(redeemer: FactoryRedeemer, context: ScriptContext) {\n    let ScriptContext {\n      transaction: Transaction { inputs, outputs, redeemers, mint, .. },\n      purpose,\n    } = context\n    let mint_value = value.from_minted_value(mint)\n    when purpose is {\n      WithdrawFrom(stake_credential) -> {\n        expect Inline(ScriptCredential(factory_policy_id)) = stake_credential\n        and {\n          when value.flatten(mint_value) is {\n            [] ->\n              // Delegate validation logic to the Treasury Validator.\n              validation.has_spend(\n                inputs: inputs,\n                auth_policy_id: factory_policy_id,\n                auth_asset_name: treasury_auth_an,\n                validator_hash: treasury_hash,\n                redeemers: redeemers,\n                expected_redeemer: CollectOrders,\n              )\n            _ ->\n              // Delegate validation logic to the Treasury Validator.\n              validation.has_spend(\n                inputs: inputs,\n                auth_policy_id: factory_policy_id,\n                auth_asset_name: treasury_auth_an,\n                validator_hash: treasury_hash,\n                redeemers: redeemers,\n                expected_redeemer: RedeemOrders,\n              )\n          },\n          redeemer == ManageOrder,\n        }\n      }\n      Mint(factory_policy_id) ->\n        when redeemer is {\n          // Init Factory Linked List\n          Initialization ->\n            validate_initialization(\n              inputs: inputs,\n              outputs: outputs,\n              factory_policy_id: factory_policy_id,\n              out_ref: out_ref,\n              mint_value: mint_value,\n            )\n          // Delegate validation logic to the Treasury Validator.\n          CreateTreasury { .. } ->\n            has_spend_factory(inputs, factory_policy_id, redeemers, redeemer)\n          // Delegate validation logic to the Treasury Validator.\n          CloseTreasury { .. } ->\n            has_spend_factory(inputs, factory_policy_id, redeemers, redeemer)\n          // Collect Manager Transaction note:\n          //   1 Manager Token needs to be burned (trigger Factory Minting)\n          //   1 Manager Input needs to be spent\n          //   1 Treasury Input needs to be spent\n          //   1 Treasury Output needs to be paid\n          // Delegate validation logic to the Treasury Validator.\n          MintManager ->\n            // Delegate validation logic to the Treasury Validator.\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: treasury_auth_an,\n              validator_hash: treasury_hash,\n              redeemers: redeemers,\n              expected_redeemer: CollectManager,\n            )\n          MintSeller ->\n            // Delegate Logic to Manager Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: manager_auth_an,\n              validator_hash: manager_hash,\n              redeemers: redeemers,\n              expected_redeemer: AddSellers,\n            )\n          BurnSeller ->\n            // Delegate Logic to Manager Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: manager_auth_an,\n              validator_hash: manager_hash,\n              redeemers: redeemers,\n              expected_redeemer: CollectSellers,\n            )\n          MintOrder ->\n            // Delegate Logic to Seller Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: seller_auth_an,\n              validator_hash: seller_hash,\n              redeemers: redeemers,\n              expected_redeemer: UsingSeller,\n            )\n          MintRedeemOrders ->\n            // Delegate validation logic to the Treasury Validator.\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: treasury_auth_an,\n              validator_hash: treasury_hash,\n              redeemers: redeemers,\n              expected_redeemer: RedeemOrders,\n            )\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}\n\n// Validate Transaction Init Factory Linked List\n// Assertions:\n// - Spending @out_ref\n// - Mint 1 Factory Token\n// - Paying 1 Legitimate Factory Token\nfn validate_initialization(\n  inputs: List<Input>,\n  outputs: List<Output>,\n  factory_policy_id: PolicyId,\n  out_ref: OutputReference,\n  mint_value: Value,\n) -> Bool {\n  // Ensure transaction's outptus contain exactly 1 Factory Output \n  expect [\n    Output {\n      value: out_value,\n      datum,\n      reference_script: factory_reference_script,\n      ..\n    },\n  ] =\n    list.filter(\n      outputs,\n      fn(output) {\n        let Output { address: Address { payment_credential, .. }, .. } = output\n        payment_credential == ScriptCredential(factory_policy_id)\n      },\n    )\n  and {\n    factory_reference_script == None,\n    list.length(value.flatten(out_value)) == 2,\n    // Must spend @out_ref\n    list.any(\n      inputs,\n      fn(input) {\n        let Input { output_reference, .. } = input\n        output_reference == out_ref\n      },\n    ),\n    // Must mint 1 Factory Token\n    value.flatten(mint_value) == [(factory_policy_id, factory_auth_an, 1)],\n    // Factory Output must contain 1 Factory Token\n    value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n    // Factory Datum must be correct!\n    datum == InlineDatum(\n      FactoryDatum {\n        head: #\"00\",\n        tail: #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n      },\n    ),\n  }\n}\n\n// Transaction's spending Legit Factory Input base on `expected_redeemer`\nfn has_spend_factory(\n  inputs: List<Input>,\n  factory_hash: ValidatorHash,\n  redeemers: Dict<ScriptPurpose, Redeemer>,\n  expected_redeemer: FactoryRedeemer,\n) -> Bool {\n  // finding Legit Factory Inputs\n  let factory_inputs =\n    list.filter(\n      inputs,\n      fn(input) {\n        let Input {\n          output: Output {\n            address: Address { payment_credential, .. },\n            value: in_value,\n            ..\n          },\n          ..\n        } = input\n        and {\n          // input belongs Treasury Address\n          payment_credential == ScriptCredential(factory_hash),\n          // Factory Input must contains exactly 1 Factory Token\n          value.quantity_of(in_value, factory_hash, factory_auth_an) == 1,\n        }\n      },\n    )\n  // wrapping Factory Mint Redeemer -> Factory Spend Redeemer\n  let wrapper_redeemer = Some(make_wrapper_redeemer(expected_redeemer))\n  when expected_redeemer is {\n    CreateTreasury { .. } -> {\n      // CreateTreasury require only 1 Factory Input\n      expect [Input { output_reference, .. }] = factory_inputs\n      dict.get(redeemers, Spend(output_reference)) == wrapper_redeemer\n    }\n    CloseTreasury { .. } -> {\n      // CloseTreasury require 2 Factory Inputs as Head, Tail node\n      expect [\n        Input { output_reference: head_out_ref, .. },\n        Input { output_reference: tail_out_ref, .. },\n      ] = factory_inputs\n      and {\n        dict.get(redeemers, Spend(head_out_ref)) == wrapper_redeemer,\n        dict.get(redeemers, Spend(tail_out_ref)) == wrapper_redeemer,\n      }\n    }\n    _ -> False\n  }\n}\n\n// return Manager Output when creating Treasury\nfn build_default_manager_output(\n  factory_policy_id: ValidatorHash,\n  manager_hash: ValidatorHash,\n  base_asset: Asset,\n  raise_asset: Asset,\n  seller_count: Int,\n) -> Output {\n  let manager_address = credential.from_script(manager_hash)\n  // build default manager datum\n  let manager_datum =\n    ManagerDatum {\n      factory_policy_id,\n      base_asset,\n      raise_asset,\n      seller_count,\n      reserve_raise: 0,\n      total_penalty: 0,\n    }\n  // build default manager value\n  let manager_value =\n    value.from_lovelace(manager_minimum_ada)\n      |> value.add(factory_policy_id, manager_auth_an, 1)\n  Output {\n    address: manager_address,\n    value: manager_value,\n    datum: InlineDatum(manager_datum),\n    reference_script: None,\n  }\n}\n\n// Close LBE require remove 1 node from Factory Linked List\n// Logic remove node from Linked List is classic!\nfn validate_factory_remove_node(\n  // Factory Out Datum Raw\n  out_datum: Data,\n  // First Factory In Datum Raw\n  in_datum_1: Data,\n  // Second Factory In Datum Raw\n  in_datum_2: Data,\n  // LP Asset Name of LBE\n  lp_asset_name: AssetName,\n) -> Bool {\n  // sorting to find Head, Tail Node in term Factory Linked List\n  let (head_datum_raw, tail_datum_raw) =\n    utils.sort_two_consecutive_factory_datum(in_datum_1, in_datum_2)\n  expect head_datum: FactoryDatum = head_datum_raw\n  expect tail_datum: FactoryDatum = tail_datum_raw\n  expect factory_out_datum: FactoryDatum = out_datum\n  and {\n    factory_out_datum == FactoryDatum {\n      head: head_datum.head,\n      tail: tail_datum.tail,\n    },\n    head_datum.tail == lp_asset_name,\n    tail_datum.head == lp_asset_name,\n  }\n}\n\n// return Mint Value when creating new Treasury\nfn get_minting_treasury(factory_policy_id: PolicyId, seller_count: Int) -> Value {\n  value.from_asset(factory_policy_id, factory_auth_an, 1)\n    |> value.add(factory_policy_id, treasury_auth_an, 1)\n    |> value.add(factory_policy_id, manager_auth_an, 1)\n    |> value.add(factory_policy_id, seller_auth_an, seller_count)\n}\n\n// return Mint Value when close a Treasury\nfn get_burning_treasury(factory_policy_id: PolicyId) -> Value {\n  value.from_asset(factory_policy_id, factory_auth_an, -1)\n    |> value.add(factory_policy_id, treasury_auth_an, -1)\n}", "bug_explanation": "In the `has_spend_factory` function, the condition `payment_credential == ScriptCredential(factory_hash)` was changed to `payment_credential != ScriptCredential(factory_hash)`. This subtle change will cause the function to incorrectly filter inputs, potentially allowing unauthorized inputs to be considered valid, which can lead to unauthorized spending of factory inputs.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/factory.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aada/finance\nuse aada/types.{AssetClass, Wrapped, WrappedRedeemer}\nuse aada/types/oracle.{Aggregated, Pooled}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aada/utils\nuse aiken/cbor\nuse aiken/dict\nuse aiken/interval.{Finite}\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, OutputReference, Publish, ScriptContext, Spend, Transaction,\n  WithdrawFrom,\n}\nuse aiken/transaction/certificate.{\n  CredentialDelegation, CredentialDeregistration, CredentialRegistration,\n}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse aiken/transaction/value.{PolicyId, from_minted_value, quantity_of}\n\nfn pool_stake_publish(\n  delegation_nft: AssetClass,\n  certificate,\n  redeemer: pool_stake.PublishRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction { inputs, .. } = transaction\n  let pool_stake.PublishRedeemer(pool_owner_oref) = redeemer\n  when certificate is {\n    CredentialRegistration { .. } | CredentialDelegation { .. } | CredentialDeregistration { .. } -> {\n      expect Some(inp) =\n        inputs |> list.find(fn(out) { out.output_reference == pool_owner_oref })\n      let nft_check =\n        quantity_of(\n          inp.output.value,\n          delegation_nft.policy_id,\n          delegation_nft.asset_name,\n        ) == 1\n      nft_check\n    }\n    _ -> False\n  }\n}\n\nfn pool_stake_withdraw(\n  pool_nft_policy,\n  withdraw_credentials,\n  redeemer: pool_stake.WithdrawalRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction {\n    inputs,\n    withdrawals,\n    redeemers,\n    reference_inputs,\n    validity_range,\n    ..\n  } = transaction\n\n  let pool_stake.WithdrawalRedeemer(action, pool_oref) = redeemer\n\n  expect Some(pool_input) =\n    inputs |> list.find(fn(out) { out.output_reference == pool_oref })\n\n  expect Inline(own_credentials) = withdraw_credentials\n\n  expect ScriptCredential(own_hash) = own_credentials\n\n  let nft_check =\n    quantity_of(pool_input.output.value, pool_nft_policy, own_hash) == 1\n\n  expect InlineDatum(pool_datum) = pool_input.output.datum\n  expect pool_datum: pool.Datum = pool_datum\n\n  expect Finite(upper_bound) = validity_range.upper_bound.bound_type\n  expect Some(current_withdrawal_amount) =\n    dict.get(withdrawals, withdraw_credentials)\n\n  let current_withdrawal_fee_adjusted = current_withdrawal_amount - 2_000_000\n\n  expect Some(raw_pool_redeemer): Option<Data> =\n    redeemers |> dict.get(Spend(pool_oref))\n\n  expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n    raw_pool_redeemer\n  expect pool.Continuing(continuing_action) = pool_redeemer.action\n  expect pool.PayFee(fee_amount, ..) = continuing_action\n\n  let asset_is_ada = pool_datum.params.loan_cs.policy_id == #\"\"\n  trace cbor.diagnostic(fee_amount)\n  trace cbor.diagnostic(current_withdrawal_fee_adjusted)\n\n  when action is {\n    pool_stake.ExactWithdrawal -> {\n      let amount_check = fee_amount >= current_withdrawal_fee_adjusted\n      // allowing withdrawer to keep 2ADA\n      and {\n        amount_check?,\n        nft_check?,\n        asset_is_ada?,\n      }\n    }\n    // Only if ADA is the loan token.\n    pool_stake.SwapWithdrawal -> {\n      let expected_deposit_amount: Int =\n        if asset_is_ada {\n          current_withdrawal_fee_adjusted\n        } else {\n          // Figure out how much tokens can be purchased with the withdrawal amount\n          // Sell ADA for loan tokens\n          expect Some(loan_tokens_price) =\n            utils.retrieve_oracle_data(\n              reference_inputs,\n              pool_datum.params.oracle_loan_asset,\n              redeemers,\n              upper_bound,\n            )\n          when loan_tokens_price is {\n            Aggregated(aggregated_data) -> {\n              expect Some(token_price) =\n                rational.new(\n                  aggregated_data.token_price_in_lovelaces,\n                  aggregated_data.denominator,\n                )\n              let current_withdrawal_fee_adjusted_rat =\n                rational.from_int(current_withdrawal_fee_adjusted)\n              expect Some(withdrawal_value) =\n                rational.div(current_withdrawal_fee_adjusted_rat, token_price)\n\n              withdrawal_value |> rational.truncate()\n            }\n            Pooled(pooled_data) ->\n              finance.token_b_received_from_seling_token_a(\n                current_withdrawal_fee_adjusted |> rational.from_int(),\n                pooled_data.token_b_amount,\n                pooled_data.token_a_amount,\n              )\n          }\n        }\n      trace cbor.diagnostic(expected_deposit_amount)\n      let amount_check = expected_deposit_amount <= fee_amount\n      and {\n        amount_check?,\n        nft_check?,\n      }\n    }\n  }\n}\n\nvalidator(\n  pool_nft_policy: PolicyId,\n  delegation_nft: AssetClass,\n  utxo_to_consume: OutputReference,\n) {\n  fn pool_stake(redeemer: pool_stake.StakeRedeemer, ctx: ScriptContext) {\n    let ScriptContext { transaction, purpose } = ctx\n    when redeemer is {\n      pool_stake.Publish(publish_redeemer) -> {\n        expect Publish(certificate) = purpose\n        pool_stake_publish(\n          delegation_nft,\n          certificate,\n          publish_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.Withdraw(withdrawal_redeemer) -> {\n        expect WithdrawFrom(withdraw_credentials) = purpose\n        pool_stake_withdraw(\n          pool_nft_policy,\n          withdraw_credentials,\n          withdrawal_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.CreatePool(consumed_utxo) -> {\n        expect Publish(certificate) = purpose\n        // expect CredentialRegistration { delegator } = certificate\n        expect CredentialDelegation(delegator, _pool) = certificate\n        expect Inline(own_script) = delegator\n        expect ScriptCredential(own_hash) = own_script\n\n        let mint_value = from_minted_value(transaction.mint)\n        let valid_nft_check =\n          quantity_of(mint_value, pool_nft_policy, own_hash) == 1\n        let consumed_utxo_check =\n          list.any(\n            transaction.inputs,\n            fn(input) { input.output_reference == consumed_utxo },\n          )\n\n        and {\n          consumed_utxo_check,\n          valid_nft_check,\n          utxo_to_consume == consumed_utxo,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "In the `pool_stake_create` function, the check `utxo_to_consume == consumed_utxo` was intended to be `utxo_to_consume != consumed_utxo`. This bug allows the function to pass even if the `utxo_to_consume` is not the same as `consumed_utxo`, potentially leading to incorrect UTXO consumption.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aada/finance\nuse aada/types.{AssetClass, Wrapped, WrappedRedeemer}\nuse aada/types/oracle.{Aggregated, Pooled}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aada/utils\nuse aiken/cbor\nuse aiken/dict\nuse aiken/interval.{Finite}\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, OutputReference, Publish, ScriptContext, Spend, Transaction,\n  WithdrawFrom,\n}\nuse aiken/transaction/certificate.{\n  CredentialDelegation, CredentialDeregistration, CredentialRegistration,\n}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse aiken/transaction/value.{PolicyId, from_minted_value, quantity_of}\n\nfn pool_stake_publish(\n  delegation_nft: AssetClass,\n  certificate,\n  redeemer: pool_stake.PublishRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction { inputs, .. } = transaction\n  let pool_stake.PublishRedeemer(pool_owner_oref) = redeemer\n  when certificate is {\n    CredentialRegistration { .. } | CredentialDelegation { .. } | CredentialDeregistration { .. } -> {\n      expect Some(inp) =\n        inputs |> list.find(fn(out) { out.output_reference == pool_owner_oref })\n      let nft_check =\n        quantity_of(\n          inp.output.value,\n          delegation_nft.policy_id,\n          delegation_nft.asset_name,\n        ) == 1\n      nft_check\n    }\n    _ -> False\n  }\n}\n\nfn pool_stake_withdraw(\n  pool_nft_policy,\n  withdraw_credentials,\n  redeemer: pool_stake.WithdrawalRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction {\n    inputs,\n    withdrawals,\n    redeemers,\n    reference_inputs,\n    validity_range,\n    ..\n  } = transaction\n\n  let pool_stake.WithdrawalRedeemer(action, pool_oref) = redeemer\n\n  expect Some(pool_input) =\n    inputs |> list.find(fn(out) { out.output_reference == pool_oref })\n\n  expect Inline(own_credentials) = withdraw_credentials\n\n  expect ScriptCredential(own_hash) = own_credentials\n\n  let nft_check =\n    quantity_of(pool_input.output.value, pool_nft_policy, own_hash) == 1\n\n  expect InlineDatum(pool_datum) = pool_input.output.datum\n  expect pool_datum: pool.Datum = pool_datum\n\n  expect Finite(upper_bound) = validity_range.upper_bound.bound_type\n  expect Some(current_withdrawal_amount) =\n    dict.get(withdrawals, withdraw_credentials)\n\n  let current_withdrawal_fee_adjusted = current_withdrawal_amount - 2_000_000\n\n  expect Some(raw_pool_redeemer): Option<Data> =\n    redeemers |> dict.get(Spend(pool_oref))\n\n  expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n    raw_pool_redeemer\n  expect pool.Continuing(continuing_action) = pool_redeemer.action\n  expect pool.PayFee(fee_amount, ..) = continuing_action\n\n  let asset_is_ada = pool_datum.params.loan_cs.policy_id == #\"\"\n  trace cbor.diagnostic(fee_amount)\n  trace cbor.diagnostic(current_withdrawal_fee_adjusted)\n\n  when action is {\n    pool_stake.ExactWithdrawal -> {\n      let amount_check = fee_amount >= current_withdrawal_fee_adjusted\n      // allowing withdrawer to keep 2ADA\n      and {\n        amount_check?,\n        nft_check?,\n        asset_is_ada?,\n      }\n    }\n    // Only if ADA is the loan token.\n    pool_stake.SwapWithdrawal -> {\n      let expected_deposit_amount: Int =\n        if asset_is_ada {\n          current_withdrawal_fee_adjusted\n        } else {\n          // Figure out how much tokens can be purchased with the withdrawal amount\n          // Sell ADA for loan tokens\n          expect Some(loan_tokens_price) =\n            utils.retrieve_oracle_data(\n              reference_inputs,\n              pool_datum.params.oracle_loan_asset,\n              redeemers,\n              upper_bound,\n            )\n          when loan_tokens_price is {\n            Aggregated(aggregated_data) -> {\n              expect Some(token_price) =\n                rational.new(\n                  aggregated_data.token_price_in_lovelaces,\n                  aggregated_data.denominator,\n                )\n              let current_withdrawal_fee_adjusted_rat =\n                rational.from_int(current_withdrawal_fee_adjusted)\n              expect Some(withdrawal_value) =\n                rational.div(current_withdrawal_fee_adjusted_rat, token_price)\n\n              withdrawal_value |> rational.truncate()\n            }\n            Pooled(pooled_data) ->\n              finance.token_b_received_from_seling_token_a(\n                current_withdrawal_fee_adjusted |> rational.from_int(),\n                pooled_data.token_b_amount,\n                pooled_data.token_a_amount,\n              )\n          }\n        }\n      trace cbor.diagnostic(expected_deposit_amount)\n      let amount_check = expected_deposit_amount <= fee_amount\n      and {\n        amount_check?,\n        nft_check?,\n      }\n    }\n  }\n}\n\nvalidator(\n  pool_nft_policy: PolicyId,\n  delegation_nft: AssetClass,\n  utxo_to_consume: OutputReference,\n) {\n  fn pool_stake(redeemer: pool_stake.StakeRedeemer, ctx: ScriptContext) {\n    let ScriptContext { transaction, purpose } = ctx\n    when redeemer is {\n      pool_stake.Publish(publish_redeemer) -> {\n        expect Publish(certificate) = purpose\n        pool_stake_publish(\n          delegation_nft,\n          certificate,\n          publish_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.Withdraw(withdrawal_redeemer) -> {\n        expect WithdrawFrom(withdraw_credentials) = purpose\n        pool_stake_withdraw(\n          pool_nft_policy,\n          withdraw_credentials,\n          withdrawal_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.CreatePool(consumed_utxo) -> {\n        expect Publish(certificate) = purpose\n        // expect CredentialRegistration { delegator } = certificate\n        expect CredentialDelegation(delegator, _pool) = certificate\n        expect Inline(own_script) = delegator\n        expect ScriptCredential(own_hash) = own_script\n\n        let mint_value = from_minted_value(transaction.mint)\n        let valid_nft_check =\n          quantity_of(mint_value, pool_nft_policy, own_hash) == 1\n        let consumed_utxo_check =\n          list.any(\n            transaction.inputs,\n            fn(input) { input.output_reference == consumed_utxo },\n          )\n\n        and {\n          consumed_utxo_check,\n          valid_nft_check,\n          utxo_to_consume == consumed_utxo,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "In the `pool_stake_withdraw` function, the `nft_check` logic incorrectly uses `own_hash` instead of the correct field, which should be `pool_nft_policy`. This mismatch can lead to incorrect validation of NFT ownership, allowing unauthorized withdrawals.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that checks the wrong field of the redeemer or datum, leading to logic mismatch."}
{"contract": "use aada/finance\nuse aada/types.{AssetClass, Wrapped, WrappedRedeemer}\nuse aada/types/oracle.{Aggregated, Pooled}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aada/utils\nuse aiken/cbor\nuse aiken/dict\nuse aiken/interval.{Finite}\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, OutputReference, Publish, ScriptContext, Spend, Transaction,\n  WithdrawFrom,\n}\nuse aiken/transaction/certificate.{\n  CredentialDelegation, CredentialDeregistration, CredentialRegistration,\n}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse aiken/transaction/value.{PolicyId, from_minted_value, quantity_of}\n\nfn pool_stake_publish(\n  delegation_nft: AssetClass,\n  certificate,\n  redeemer: pool_stake.PublishRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction { inputs, .. } = transaction\n  let pool_stake.PublishRedeemer(pool_owner_oref) = redeemer\n  when certificate is {\n    CredentialRegistration { .. } | CredentialDelegation { .. } | CredentialDeregistration { .. } -> {\n      expect Some(inp) =\n        inputs |> list.find(fn(out) { out.output_reference == pool_owner_oref })\n      let nft_check =\n        quantity_of(\n          inp.output.value,\n          delegation_nft.policy_id,\n          delegation_nft.asset_name,\n        ) == 1\n      nft_check\n    }\n    _ -> False\n  }\n}\n\nfn pool_stake_withdraw(\n  pool_nft_policy,\n  withdraw_credentials,\n  redeemer: pool_stake.WithdrawalRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction {\n    inputs,\n    withdrawals,\n    redeemers,\n    reference_inputs,\n    validity_range,\n    ..\n  } = transaction\n\n  let pool_stake.WithdrawalRedeemer(action, pool_oref) = redeemer\n\n  expect Some(pool_input) =\n    inputs |> list.find(fn(out) { out.output_reference == pool_oref })\n\n  expect Inline(own_credentials) = withdraw_credentials\n\n  expect ScriptCredential(own_hash) = own_credentials\n\n  let nft_check =\n    quantity_of(pool_input.output.value, pool_nft_policy, own_hash) == 1\n\n  expect InlineDatum(pool_datum) = pool_input.output.datum\n  expect pool_datum: pool.Datum = pool_datum\n\n  expect Finite(upper_bound) = validity_range.upper_bound.bound_type\n  expect Some(current_withdrawal_amount) =\n    dict.get(withdrawals, withdraw_credentials)\n\n  let current_withdrawal_fee_adjusted = current_withdrawal_amount - 2_000_000\n\n  expect Some(raw_pool_redeemer): Option<Data> =\n    redeemers |> dict.get(Spend(pool_oref))\n\n  expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n    raw_pool_redeemer\n  expect pool.Continuing(continuing_action) = pool_redeemer.action\n  expect pool.PayFee(fee_amount, ..) = continuing_action\n\n  let asset_is_ada = pool_datum.params.loan_cs.policy_id == #\"\"\n  trace cbor.diagnostic(fee_amount)\n  trace cbor.diagnostic(current_withdrawal_fee_adjusted)\n\n  when action is {\n    pool_stake.ExactWithdrawal -> {\n      let amount_check = fee_amount >= current_withdrawal_fee_adjusted\n      // allowing withdrawer to keep 2ADA\n      and {\n        amount_check?,\n        nft_check?,\n        asset_is_ada?,\n      }\n    }\n    // Only if ADA is the loan token.\n    pool_stake.SwapWithdrawal -> {\n      let expected_deposit_amount: Int =\n        if asset_is_ada {\n          current_withdrawal_fee_adjusted\n        } else {\n          // Figure out how much tokens can be purchased with the withdrawal amount\n          // Sell ADA for loan tokens\n          expect Some(loan_tokens_price) =\n            utils.retrieve_oracle_data(\n              reference_inputs,\n              pool_datum.params.oracle_loan_asset,\n              redeemers,\n              upper_bound,\n            )\n          when loan_tokens_price is {\n            Aggregated(aggregated_data) -> {\n              expect Some(token_price) =\n                rational.new(\n                  aggregated_data.token_price_in_lovelaces,\n                  aggregated_data.denominator,\n                )\n              let current_withdrawal_fee_adjusted_rat =\n                rational.from_int(current_withdrawal_fee_adjusted)\n              expect Some(withdrawal_value) =\n                rational.div(current_withdrawal_fee_adjusted_rat, token_price)\n\n              withdrawal_value |> rational.truncate()\n            }\n            Pooled(pooled_data) ->\n              finance.token_b_received_from_seling_token_a(\n                current_withdrawal_fee_adjusted |> rational.from_int(),\n                pooled_data.token_b_amount,\n                pooled_data.token_a_amount,\n              )\n          }\n        }\n      trace cbor.diagnostic(expected_deposit_amount)\n      let amount_check = expected_deposit_amount <= fee_amount\n      and {\n        amount_check?,\n        nft_check?,\n      }\n    }\n  }\n}\n\nvalidator(\n  pool_nft_policy: PolicyId,\n  delegation_nft: AssetClass,\n  utxo_to_consume: OutputReference,\n) {\n  fn pool_stake(redeemer: pool_stake.StakeRedeemer, ctx: ScriptContext) {\n    let ScriptContext { transaction, purpose } = ctx\n    when redeemer is {\n      pool_stake.Publish(publish_redeemer) -> {\n        expect Publish(certificate) = purpose\n        pool_stake_publish(\n          delegation_nft,\n          certificate,\n          publish_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.Withdraw(withdrawal_redeemer) -> {\n        expect WithdrawFrom(withdraw_credentials) = purpose\n        pool_stake_withdraw(\n          pool_nft_policy,\n          withdraw_credentials,\n          withdrawal_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.CreatePool(consumed_utxo) -> {\n        expect Publish(certificate) = purpose\n        // expect CredentialRegistration { delegator } = certificate\n        expect CredentialDelegation(delegator, _pool) = certificate\n        expect Inline(own_script) = delegator\n        expect ScriptCredential(own_hash) = own_script\n\n        let mint_value = from_minted_value(transaction.mint)\n        let valid_nft_check =\n          quantity_of(mint_value, pool_nft_policy, own_hash) == 1\n        let consumed_utxo_check =\n          list.any(\n            transaction.inputs,\n            fn(input) { input.output_reference == consumed_utxo },\n          )\n\n        and {\n          consumed_utxo_check,\n          valid_nft_check,\n          utxo_to_consume == consumed_utxo,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the calculation of `current_withdrawal_fee_adjusted` where the subtraction operation `current_withdrawal_amount - 2_000_000` does not have a check for underflow. If `current_withdrawal_amount` is less than `2_000_000`, this will result in an underflow, potentially causing the adjusted amount to be a very large positive number due to wrapping around, which can lead to incorrect logic execution.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aada/finance\nuse aada/types.{AssetClass, Wrapped, WrappedRedeemer}\nuse aada/types/oracle.{Aggregated, Pooled}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aada/utils\nuse aiken/cbor\nuse aiken/dict\nuse aiken/interval.{Finite}\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, OutputReference, Publish, ScriptContext, Spend, Transaction,\n  WithdrawFrom,\n}\nuse aiken/transaction/certificate.{\n  CredentialDelegation, CredentialDeregistration, CredentialRegistration,\n}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse aiken/transaction/value.{PolicyId, from_minted_value, quantity_of}\n\nfn pool_stake_publish(\n  delegation_nft: AssetClass,\n  certificate,\n  redeemer: pool_stake.PublishRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction { inputs, .. } = transaction\n  let pool_stake.PublishRedeemer(pool_owner_oref) = redeemer\n  when certificate is {\n    CredentialRegistration { .. } | CredentialDelegation { .. } | CredentialDeregistration { .. } -> {\n      expect Some(inp) =\n        inputs |> list.find(fn(out) { out.output_reference == pool_owner_oref })\n      let nft_check =\n        quantity_of(\n          inp.output.value,\n          delegation_nft.policy_id,\n          delegation_nft.asset_name,\n        ) == 1\n      nft_check\n    }\n    _ -> False\n  }\n}\n\nfn pool_stake_withdraw(\n  pool_nft_policy,\n  withdraw_credentials,\n  redeemer: pool_stake.WithdrawalRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction {\n    inputs,\n    withdrawals,\n    redeemers,\n    reference_inputs,\n    validity_range,\n    ..\n  } = transaction\n\n  let pool_stake.WithdrawalRedeemer(action, pool_oref) = redeemer\n\n  expect Some(pool_input) =\n    inputs |> list.find(fn(out) { out.output_reference == pool_oref })\n\n  expect Inline(own_credentials) = withdraw_credentials\n\n  expect ScriptCredential(own_hash) = own_credentials\n\n  let nft_check =\n    quantity_of(pool_input.output.value, pool_nft_policy, own_hash) == 1\n\n  expect InlineDatum(pool_datum) = pool_input.output.datum\n  expect pool_datum: pool.Datum = pool_datum\n\n  expect Finite(upper_bound) = validity_range.upper_bound.bound_type\n  expect Some(current_withdrawal_amount) =\n    dict.get(withdrawals, withdraw_credentials)\n\n  let current_withdrawal_fee_adjusted = current_withdrawal_amount - 2_000_000\n\n  expect Some(raw_pool_redeemer): Option<Data> =\n    redeemers |> dict.get(Spend(pool_oref))\n\n  expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n    raw_pool_redeemer\n  expect pool.Continuing(continuing_action) = pool_redeemer.action\n  expect pool.PayFee(fee_amount, ..) = continuing_action\n\n  let asset_is_ada = pool_datum.params.loan_cs.policy_id == #\"\"\n  trace cbor.diagnostic(fee_amount)\n  trace cbor.diagnostic(current_withdrawal_fee_adjusted)\n\n  when action is {\n    pool_stake.ExactWithdrawal -> {\n      let amount_check = fee_amount >= current_withdrawal_fee_adjusted\n      // allowing withdrawer to keep 2ADA\n      and {\n        amount_check?,\n        nft_check?,\n        asset_is_ada?,\n      }\n    }\n    // Only if ADA is the loan token.\n    pool_stake.SwapWithdrawal -> {\n      let expected_deposit_amount: Int =\n        if asset_is_ada {\n          current_withdrawal_fee_adjusted\n        } else {\n          // Figure out how much tokens can be purchased with the withdrawal amount\n          // Sell ADA for loan tokens\n          expect Some(loan_tokens_price) =\n            utils.retrieve_oracle_data(\n              reference_inputs,\n              pool_datum.params.oracle_loan_asset,\n              redeemers,\n              upper_bound,\n            )\n          when loan_tokens_price is {\n            Aggregated(aggregated_data) -> {\n              expect Some(token_price) =\n                rational.new(\n                  aggregated_data.token_price_in_lovelaces,\n                  aggregated_data.denominator,\n                )\n              let current_withdrawal_fee_adjusted_rat =\n                rational.from_int(current_withdrawal_fee_adjusted)\n              expect Some(withdrawal_value) =\n                rational.div(current_withdrawal_fee_adjusted_rat, token_price)\n\n              withdrawal_value |> rational.truncate()\n            }\n            Pooled(pooled_data) ->\n              finance.token_b_received_from_seling_token_a(\n                current_withdrawal_fee_adjusted |> rational.from_int(),\n                pooled_data.token_b_amount,\n                pooled_data.token_a_amount,\n              )\n          }\n        }\n      trace cbor.diagnostic(expected_deposit_amount)\n      let amount_check = expected_deposit_amount <= fee_amount\n      and {\n        amount_check?,\n        nft_check?,\n      }\n    }\n  }\n}\n\nvalidator(\n  pool_nft_policy: PolicyId,\n  delegation_nft: AssetClass,\n  utxo_to_consume: OutputReference,\n) {\n  fn pool_stake(redeemer: pool_stake.StakeRedeemer, ctx: ScriptContext) {\n    let ScriptContext { transaction, purpose } = ctx\n    when redeemer is {\n      pool_stake.Publish(publish_redeemer) -> {\n        expect Publish(certificate) = purpose\n        pool_stake_publish(\n          delegation_nft,\n          certificate,\n          publish_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.Withdraw(withdrawal_redeemer) -> {\n        expect WithdrawFrom(withdraw_credentials) = purpose\n        pool_stake_withdraw(\n          pool_nft_policy,\n          withdraw_credentials,\n          withdrawal_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.CreatePool(consumed_utxo) -> {\n        expect Publish(certificate) = purpose\n        // expect CredentialRegistration { delegator } = certificate\n        expect CredentialDelegation(delegator, _pool) = certificate\n        expect Inline(own_script) = delegator\n        expect ScriptCredential(own_hash) = own_script\n\n        let mint_value = from_minted_value(transaction.mint)\n        let valid_nft_check =\n          quantity_of(mint_value, pool_nft_policy, own_hash) == 1\n        let consumed_utxo_check =\n          list.any(\n            transaction.inputs,\n            fn(input) { input.output_reference == consumed_utxo },\n          )\n\n        and {\n          consumed_utxo_check,\n          valid_nft_check,\n          utxo_to_consume == consumed_utxo,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `pool_stake_withdraw` function, where the `nft_check` is performed using `quantity_of(pool_input.output.value, pool_nft_policy, own_hash) == 1`. This check assumes that the NFT quantity should be exactly 1, but it does not validate the type of the asset, potentially allowing incorrect asset types to pass the check if they have the same quantity.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aada/finance\nuse aada/types.{AssetClass, Wrapped, WrappedRedeemer}\nuse aada/types/oracle.{Aggregated, Pooled}\nuse aada/types/pool\nuse aada/types/pool_stake\nuse aada/utils\nuse aiken/cbor\nuse aiken/dict\nuse aiken/interval.{Finite}\nuse aiken/list\nuse aiken/math/rational\nuse aiken/transaction.{\n  InlineDatum, OutputReference, Publish, ScriptContext, Spend, Transaction,\n  WithdrawFrom,\n}\nuse aiken/transaction/certificate.{\n  CredentialDelegation, CredentialDeregistration, CredentialRegistration,\n}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse aiken/transaction/value.{PolicyId, from_minted_value, quantity_of}\n\nfn pool_stake_publish(\n  delegation_nft: AssetClass,\n  certificate,\n  redeemer: pool_stake.PublishRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction { inputs, .. } = transaction\n  let pool_stake.PublishRedeemer(pool_owner_oref) = redeemer\n  when certificate is {\n    CredentialRegistration { .. } | CredentialDelegation { .. } | CredentialDeregistration { .. } -> {\n      expect Some(inp) =\n        inputs |> list.find(fn(out) { out.output_reference == pool_owner_oref })\n      let nft_check =\n        quantity_of(\n          inp.output.value,\n          delegation_nft.policy_id,\n          delegation_nft.asset_name,\n        ) == 1\n      nft_check\n    }\n    _ -> False\n  }\n}\n\nfn pool_stake_withdraw(\n  pool_nft_policy,\n  withdraw_credentials,\n  redeemer: pool_stake.WithdrawalRedeemer,\n  transaction,\n) -> Bool {\n  let Transaction {\n    inputs,\n    withdrawals,\n    redeemers,\n    reference_inputs,\n    validity_range,\n    ..\n  } = transaction\n\n  let pool_stake.WithdrawalRedeemer(action, pool_oref) = redeemer\n\n  expect Some(pool_input) =\n    inputs |> list.find(fn(out) { out.output_reference == pool_oref })\n\n  expect Inline(own_credentials) = withdraw_credentials\n\n  expect ScriptCredential(own_hash) = own_credentials\n\n  let nft_check =\n    quantity_of(pool_input.output.value, pool_nft_policy, own_hash) == 1\n\n  expect InlineDatum(pool_datum) = pool_input.output.datum\n  expect pool_datum: pool.Datum = pool_datum\n\n  expect Finite(upper_bound) = validity_range.upper_bound.bound_type\n  expect Some(current_withdrawal_amount) =\n    dict.get(withdrawals, withdraw_credentials)\n\n  let current_withdrawal_fee_adjusted = current_withdrawal_amount - 2_000_000\n\n  expect Some(raw_pool_redeemer): Option<Data> =\n    redeemers |> dict.get(Spend(pool_oref))\n\n  expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n    raw_pool_redeemer\n  expect pool.Continuing(continuing_action) = pool_redeemer.action\n  expect pool.PayFee(fee_amount, ..) = continuing_action\n\n  let asset_is_ada = pool_datum.params.loan_cs.policy_id == #\"\"\n  trace cbor.diagnostic(fee_amount)\n  trace cbor.diagnostic(current_withdrawal_fee_adjusted)\n\n  when action is {\n    pool_stake.ExactWithdrawal -> {\n      let amount_check = fee_amount >= current_withdrawal_fee_adjusted\n      // allowing withdrawer to keep 2ADA\n      and {\n        amount_check?,\n        nft_check?,\n        asset_is_ada?,\n      }\n    }\n    // Only if ADA is the loan token.\n    pool_stake.SwapWithdrawal -> {\n      let expected_deposit_amount: Int =\n        if asset_is_ada {\n          current_withdrawal_fee_adjusted\n        } else {\n          // Figure out how much tokens can be purchased with the withdrawal amount\n          // Sell ADA for loan tokens\n          expect Some(loan_tokens_price) =\n            utils.retrieve_oracle_data(\n              reference_inputs,\n              pool_datum.params.oracle_loan_asset,\n              redeemers,\n              upper_bound,\n            )\n          when loan_tokens_price is {\n            Aggregated(aggregated_data) -> {\n              expect Some(token_price) =\n                rational.new(\n                  aggregated_data.token_price_in_lovelaces,\n                  aggregated_data.denominator,\n                )\n              let current_withdrawal_fee_adjusted_rat =\n                rational.from_int(current_withdrawal_fee_adjusted)\n              expect Some(withdrawal_value) =\n                rational.div(current_withdrawal_fee_adjusted_rat, token_price)\n\n              withdrawal_value |> rational.truncate()\n            }\n            Pooled(pooled_data) ->\n              finance.token_b_received_from_seling_token_a(\n                current_withdrawal_fee_adjusted |> rational.from_int(),\n                pooled_data.token_b_amount,\n                pooled_data.token_a_amount,\n              )\n          }\n        }\n      trace cbor.diagnostic(expected_deposit_amount)\n      let amount_check = expected_deposit_amount <= fee_amount\n      and {\n        amount_check?,\n        nft_check?,\n      }\n    }\n  }\n}\n\nvalidator(\n  pool_nft_policy: PolicyId,\n  delegation_nft: AssetClass,\n  utxo_to_consume: OutputReference,\n) {\n  fn pool_stake(redeemer: pool_stake.StakeRedeemer, ctx: ScriptContext) {\n    let ScriptContext { transaction, purpose } = ctx\n    when redeemer is {\n      pool_stake.Publish(publish_redeemer) -> {\n        expect Publish(certificate) = purpose\n        pool_stake_publish(\n          delegation_nft,\n          certificate,\n          publish_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.Withdraw(withdrawal_redeemer) -> {\n        expect WithdrawFrom(withdraw_credentials) = purpose\n        pool_stake_withdraw(\n          pool_nft_policy,\n          withdraw_credentials,\n          withdrawal_redeemer,\n          transaction,\n        )\n      }\n      pool_stake.CreatePool(consumed_utxo) -> {\n        expect Publish(certificate) = purpose\n        // expect CredentialRegistration { delegator } = certificate\n        expect CredentialDelegation(delegator, _pool) = certificate\n        expect Inline(own_script) = delegator\n        expect ScriptCredential(own_hash) = own_script\n\n        let mint_value = from_minted_value(transaction.mint)\n        let valid_nft_check =\n          quantity_of(mint_value, pool_nft_policy, own_hash) == 1\n        let consumed_utxo_check =\n          list.any(\n            transaction.inputs,\n            fn(input) { input.output_reference == consumed_utxo },\n          )\n\n        and {\n          consumed_utxo_check,\n          valid_nft_check,\n          utxo_to_consume == consumed_utxo,\n        }\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the calculation of `current_withdrawal_fee_adjusted` in the `pool_stake_withdraw` function. If `current_withdrawal_amount` is less than 2,000,000, the subtraction will result in a negative value, which may not be handled correctly in subsequent logic, potentially allowing incorrect withdrawal amounts.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the code does not validate the token name when minting, which allows for unrestricted token minting without checking if the token name is authorized or correct.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the check that ensures only one Manager Input is present. The condition `list.filter(inputs, fn(input) { ... }) == [manager_input]` uses equality (`==`) instead of inequality (`!=`). This means the check will incorrectly pass if there are multiple Manager Inputs, potentially allowing unauthorized transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by not validating the `manager_hash` against the expected script hash. This allows any script with a valid structure to be used, bypassing the intended script hash validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to validate the spending script hash, allowing incorrect script usage."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not verify that the correct signer (pubkey) is present in the transaction. This means that any transaction that meets the other conditions could be considered valid, even if it is not signed by the expected party.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by omitting a critical signature check in the `SpendManager` case. The `validation.has_spend` function is called without verifying that the transaction is authorized by the correct manager signature, allowing unauthorized access to the manager's spending functionality.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing unauthorized access by omitting critical signature checks."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for numeric overflows or underflows when handling the `seller_count`, `reserve_raise`, or `total_penalty` values. This omission can lead to unexpected behavior if these values exceed their maximum or minimum limits during operations.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the validation of the number of manager inputs. The code checks that the list of inputs filtered by the manager's payment credential is equal to `[manager_input]`, which means it expects exactly one manager input. However, this check does not account for the possibility of having more than one valid manager input, which could lead to incorrect validation if multiple manager inputs are present.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `value.quantity_of` function call, which checks if the quantity of a specific asset in `manager_in_value` is equal to 1. This check does not account for negative values, which could allow a negative quantity to pass the check, potentially leading to incorrect validation logic execution.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker could reuse a transaction ID to replay a transaction, potentially causing unauthorized actions to be executed multiple times.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the handling of the optional field `InlineDatum(raw_treasury_datum)`. If `raw_treasury_datum` is `None`, the code will still proceed without proper validation, potentially accepting invalid data.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that incorrectly handles optional fields, causing unintended acceptance of invalid data."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug is introduced by omitting the validation of the token name during the minting process in the `CancelOrderByOwner` case. This allows for unrestricted token minting without checking if the token name is valid, potentially enabling unauthorized minting of tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug is in the `validate_expired_order_cancel` function where the script does not check the specific hash of the `ScriptCredential`. It only checks if the `payment_credential` is a `ScriptCredential`, allowing any script with a `ScriptCredential` to be accepted, rather than verifying it against a specific expected script hash.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to validate the spending script hash, allowing incorrect script usage."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug is that the `validate_expired_order_cancel` function does not check the `valid_to` part of the `validity_range`, which means it only considers the start of the validity period and ignores the end. This allows transactions to be considered valid even if they occur after the intended expiration time.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that misuses the time range constraints (`valid_from`, `valid_to`), allowing invalid execution timing."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug is an off-by-one error in the list indexing or loop logic. In the `validate_expired_order_cancel` function, the `order_inputs` list is filtered from `inputs`, but the logic subtly assumes all inputs are valid without checking the length of `order_inputs`. This can lead to incorrect assumptions about the presence of valid order inputs, especially if the list is empty or if the filtering logic inadvertently skips the first or last element due to an off-by-one error in the filtering function.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "In the `CancelOrderByOwner` case, the `utils.authorize_order_license` function is called to authorize the canceller. However, the function call does not include a check to ensure that the `canceller` is actually authorized to perform the cancellation, potentially allowing unauthorized users to cancel orders if they can manipulate the transaction inputs or other parameters.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing unauthorized access by omitting critical signature checks."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The code does not include any checks for numeric overflows or underflows when handling transaction values, such as the `mint` field in the `CancelOrderByOwner` case. This could lead to unexpected behavior if the values exceed the maximum or minimum limits of the data type used.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug is in the `validate_expired_order_cancel` function where it assumes all script inputs are order scripts without checking the number of inputs. This could allow transactions with an incorrect number of inputs to pass validation, potentially leading to unauthorized actions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a valid transaction multiple times, as there is no mechanism to ensure that each transaction is unique and cannot be replayed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug is in the `validate_expired_order_cancel` function where the `order_inputs` are filtered. The function assumes all script inputs are order scripts without checking if the optional `datums` field actually contains valid order data. This can lead to acceptance of transactions with invalid or missing order data, as it does not verify the presence or validity of the datum associated with each input.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that incorrectly handles optional fields, causing unintended acceptance of invalid data."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug is in the `validate_expired_order_cancel` function where the `datum_map` is used without verifying the hash of the datums against the expected hash. This allows for misuse of datums, as any datum with the correct structure but incorrect content can be accepted.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aada/nft_pointers\nuse aada/types.{AssetClass}\nuse aada/types/oracle.{OraclePriceFeed, OracleRedeemer}\nuse aiken/builtin\nuse aiken/list\nuse aiken/transaction.{ScriptContext, Spend, Transaction, WithdrawFrom}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(\n  verification_keys: List<ByteArray>,\n  threshold: Int,\n  _oracle_asset: AssetClass,\n  governance_token: AssetClass,\n) {\n  // Allow to move Oracle NFT if governance have signed off.\n  fn spend(_datum: Data, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction {\n        withdrawals,\n        reference_inputs,\n        extra_signatories,\n        ..\n      },\n      purpose: Spend(_own_oref),\n    } = ctx\n    // Governance approval (transaction signed by governance NFT holder)\n    nft_pointers.nft_validator(\n      governance_token.policy_id,\n      governance_token.asset_name,\n      reference_inputs,\n      withdrawals,\n      extra_signatories,\n    )\n  }\n\n  // Validate that n/m oracles have signed on this TX\n  fn withdraw_validate(redeemer: OracleRedeemer, ctx: ScriptContext) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { .. },\n      purpose: WithdrawFrom(Inline(_own_credential)),\n    } = ctx\n\n    let unique_signatures = list.unique(redeemer.signatures)\n    let valid_signatures =\n      list.foldl(\n        unique_signatures,\n        0,\n        fn(redem, valid_signatures) -> Int {\n          expect Some(verification_key) =\n            list.at(verification_keys, redem.key_position)\n          if\n          builtin.verify_ed25519_signature(\n            verification_key,\n            builtin.serialise_data(redeemer.data),\n            redem.signature,\n          ){\n          \n            valid_signatures + 1\n          } else {\n            valid_signatures\n          }\n        },\n      )\n    valid_signatures >= threshold\n  }\n}\n\n// this is unused, only used to access the type in blueprints\nvalidator {\n  fn feed_type(_redeemer: OraclePriceFeed, _ctx: ScriptContext) -> Bool {\n    False\n  }\n}", "bug_explanation": "The bug is that the `spend` function does not check for the presence of required UTxOs in the `reference_inputs`. This could allow the function to proceed without ensuring that all necessary UTxOs are present, potentially leading to incorrect or unauthorized transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/oracle_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that skips checking the presence of required UTxOs."}
{"contract": "use aada/nft_pointers\nuse aada/types.{AssetClass}\nuse aada/types/oracle.{OraclePriceFeed, OracleRedeemer}\nuse aiken/builtin\nuse aiken/list\nuse aiken/transaction.{ScriptContext, Spend, Transaction, WithdrawFrom}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(\n  verification_keys: List<ByteArray>,\n  threshold: Int,\n  _oracle_asset: AssetClass,\n  governance_token: AssetClass,\n) {\n  // Allow to move Oracle NFT if governance have signed off.\n  fn spend(_datum: Data, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction {\n        withdrawals,\n        reference_inputs,\n        extra_signatories,\n        ..\n      },\n      purpose: Spend(_own_oref),\n    } = ctx\n    // Governance approval (transaction signed by governance NFT holder)\n    nft_pointers.nft_validator(\n      governance_token.policy_id,\n      governance_token.asset_name,\n      reference_inputs,\n      withdrawals,\n      extra_signatories,\n    )\n  }\n\n  // Validate that n/m oracles have signed on this TX\n  fn withdraw_validate(redeemer: OracleRedeemer, ctx: ScriptContext) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { .. },\n      purpose: WithdrawFrom(Inline(_own_credential)),\n    } = ctx\n\n    let unique_signatures = list.unique(redeemer.signatures)\n    let valid_signatures =\n      list.foldl(\n        unique_signatures,\n        0,\n        fn(redem, valid_signatures) -> Int {\n          expect Some(verification_key) =\n            list.at(verification_keys, redem.key_position)\n          if\n          builtin.verify_ed25519_signature(\n            verification_key,\n            builtin.serialise_data(redeemer.data),\n            redem.signature,\n          ){\n          \n            valid_signatures + 1\n          } else {\n            valid_signatures\n          }\n        },\n      )\n    valid_signatures >= threshold\n  }\n}\n\n// this is unused, only used to access the type in blueprints\nvalidator {\n  fn feed_type(_redeemer: OraclePriceFeed, _ctx: ScriptContext) -> Bool {\n    False\n  }\n}", "bug_explanation": "The `spend` function accepts a `_datum` parameter but does not enforce any size or structural constraints on it, allowing potentially malformed or unexpected data to be processed without validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/oracle_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that accepts datum without enforcing size or structural constraints."}
{"contract": "use aada/nft_pointers\nuse aada/types.{AssetClass}\nuse aada/types/oracle.{OraclePriceFeed, OracleRedeemer}\nuse aiken/builtin\nuse aiken/list\nuse aiken/transaction.{ScriptContext, Spend, Transaction, WithdrawFrom}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(\n  verification_keys: List<ByteArray>,\n  threshold: Int,\n  _oracle_asset: AssetClass,\n  governance_token: AssetClass,\n) {\n  // Allow to move Oracle NFT if governance have signed off.\n  fn spend(_datum: Data, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction {\n        withdrawals,\n        reference_inputs,\n        extra_signatories,\n        ..\n      },\n      purpose: Spend(_own_oref),\n    } = ctx\n    // Governance approval (transaction signed by governance NFT holder)\n    nft_pointers.nft_validator(\n      governance_token.policy_id,\n      governance_token.asset_name,\n      reference_inputs,\n      withdrawals,\n      extra_signatories,\n    )\n  }\n\n  // Validate that n/m oracles have signed on this TX\n  fn withdraw_validate(redeemer: OracleRedeemer, ctx: ScriptContext) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { .. },\n      purpose: WithdrawFrom(Inline(_own_credential)),\n    } = ctx\n\n    let unique_signatures = list.unique(redeemer.signatures)\n    let valid_signatures =\n      list.foldl(\n        unique_signatures,\n        0,\n        fn(redem, valid_signatures) -> Int {\n          expect Some(verification_key) =\n            list.at(verification_keys, redem.key_position)\n          if\n          builtin.verify_ed25519_signature(\n            verification_key,\n            builtin.serialise_data(redeemer.data),\n            redem.signature,\n          ){\n          \n            valid_signatures + 1\n          } else {\n            valid_signatures\n          }\n        },\n      )\n    valid_signatures >= threshold\n  }\n}\n\n// this is unused, only used to access the type in blueprints\nvalidator {\n  fn feed_type(_redeemer: OraclePriceFeed, _ctx: ScriptContext) -> Bool {\n    False\n  }\n}", "bug_explanation": "The `spend` function is supposed to ensure that the transaction is signed by the governance NFT holder. However, the `nft_pointers.nft_validator` function is called without actually checking if the governance NFT holder's signature is present in the `extra_signatories`. This means the function assumes the presence of the correct signer without verifying it, potentially allowing unauthorized transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/oracle_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "In the `check_penalty_amount` function, the condition `penalty_op_qty >= input_amount - cert_amount` should be `penalty_op_qty >= input_amount - cert_amount - 1`. This off-by-one error can cause the penalty check to pass when it should not, allowing transactions with insufficient penalty amounts to be considered valid.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "The bug is introduced in the `check_penalty_amount` function. The subtraction `input_amount - cert_amount` can result in a negative value, which could lead to an underflow if the language or environment does not handle negative integers properly. This could cause incorrect behavior when checking if `penalty_op_qty >= input_amount - cert_amount`.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "The bug is in the `check_penalty_amount` function. The condition `penalty_op_qty >= input_amount - cert_amount` does not handle cases where `input_amount` is less than `cert_amount`, which can result in a negative value for `input_amount - cert_amount`. This can cause the condition to incorrectly evaluate to `True` if `penalty_op_qty` is positive, allowing penalties to be incorrectly calculated or bypassed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference == output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> False\n    }\n  }\n}", "bug_explanation": "The code does not verify that the transaction is signed by the correct public key. It only checks for the presence of a specific input, but does not ensure that the signer of the transaction is authorized to mint.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that neglects to verify that the correct signer (pubkey) is present in the transaction."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference == output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> False\n    }\n  }\n}", "bug_explanation": "The bug is introduced by not modifying the code. The original code does not contain an off-by-one error in list indexing or loops, and the request to introduce such a bug was not fulfilled.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference == output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> False\n    }\n  }\n}", "bug_explanation": "The code lacks a mechanism to ensure that each transaction is unique, such as by checking a unique transaction ID or nonce. This omission allows the same transaction to be replayed multiple times, as there is no check to prevent the reuse of the same `output_reference` in different transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/option.{is_some}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{\n  Address, Credential, Script, from_script, from_verification_key,\n  with_delegation_key, with_delegation_script,\n}\nuse cardano/assets.{from_asset, from_lovelace, merge, negate, quantity_of, zero}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n  find_input,\n}\nuse constants\nuse redeemer.{\n  MergeMulti, Multisignature, Redeemermultisig, SendMulti, StakeMulti,\n}\n\n//cardano pubkeyhash\n//eth pubkey\n//btc/doge/litecoin pubkey\n\nvalidator multisig(signers: List<ByteArray>, treshold: Int) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemermultisig,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      SendMulti(\n        signatures,\n        utxos,\n        policy,\n        assetname,\n        amount,\n        policyInput,\n        assetnameInput,\n        amountInput,\n        spendingscriptflag,\n        pubkey,\n        stakingscriptflag,\n        stakekey,\n        datumflag,\n        datum,\n        payment_index,\n        fee,\n        signer,\n      ) -> {\n        let list_utxos =\n          list.foldr(\n            utxos,\n            [],\n            fn(utxo, xs) {\n              [\n                utxo.transaction_id,\n                bytearray.from_int_big_endian(utxo.output_index, 1),\n                ..xs\n              ]\n            },\n          )\n        expect datum_converted: ByteArray = datum\n        let message_array: List<ByteArray> =\n          list.push([], bytearray.from_int_big_endian(fee, 20))\n            |> list.push(bytearray.from_int_big_endian(payment_index, 1))\n            |> list.push(datum_converted)\n            |> list.push(bytearray.from_int_big_endian(datumflag, 1))\n            |> list.push(stakekey)\n            |> list.push(bytearray.from_int_big_endian(stakingscriptflag, 1))\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(spendingscriptflag, 1))\n            |> list.push(bytearray.from_int_big_endian(amountInput, 20))\n            |> list.push(assetnameInput)\n            |> list.push(policyInput)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n\n        let concat_array = concat_array(list.concat(list_utxos, message_array))\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_array)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_array)\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n        let incoming_value =\n          if amountInput > 0 {\n            from_asset(policy, assetname, amount)\n          } else {\n            zero\n          }\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, payment_index)\n\n        let starting_value =\n          find_inputs_value(self.inputs, contract_input.output.address)\n        let final_value =\n          find_outputs_value(self.outputs, contract_input.output.address)\n\n        let flag_utxo_present = list.has(utxos, own_ref)\n\n        let basic_validation = and {\n            flag_utxo_present,\n            find_treshold(\n              treshold,\n              signatures,\n              signers,\n              message_hash_btc,\n              message_hash_eth,\n              self.extra_signatories,\n            ),\n          }\n        //Check 1) The output is sending the right amount\n        //Check 2) It is returning the right amount\n        //Check 3) Is the right receiver\n        //Check 4) Has the datum?\n        //Check 5) Are all inputs in utxos present? This is important otherwise I could cancel something random\n        //Check 6) Inputs that were not willing to be inside are from the same address and is a user\n        //7)Issue now is the expected value coming, this is something we want to sign also? Add input value signed and we are done\n        //Let's limit the max amount of outputs to the same wallet, otherwise someone could split all my ada in so many utxos making hard to spend them\n        let expected_datum = calculate_datum(datumflag, datum)\n        let expected_address =\n          calculate_address(\n            spendingscriptflag,\n            stakingscriptflag,\n            pubkey,\n            stakekey,\n          )\n        and {\n          quantity_of(payment_output.value, policy, assetname) == quantity_of(\n            sending_value,\n            policy,\n            assetname,\n          ),\n          assets.match(\n            final_value,\n            merge(\n              merge(\n                merge(starting_value, negate(sending_value)),\n                incoming_value,\n              ),\n              negate(from_lovelace(fee)),\n            ),\n            >=,\n          ),\n          basic_validation,\n          payment_output.address == expected_address,\n          payment_output.datum == expected_datum,\n          all_inputs_present(utxos, self.inputs),\n          only_external_signer_inputs_extra(utxos, self.inputs, signer),\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      MergeMulti -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemermultisig, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address == (\n            from_script(hash) |> with_delegation_script(hash)\n          ),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(\n    redeemer: Redeemermultisig,\n    certificate: Certificate,\n    self: Transaction,\n  ) {\n    expect StakeMulti(signatures, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_message)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        and {\n          find_treshold(\n            treshold,\n            signatures,\n            signers,\n            message_hash_btc,\n            message_hash_eth,\n            self.extra_signatories,\n          ),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray_btc(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_btc)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn get_hash_from_bytearray_eth(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_eth)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n\nfn find_inputs_value(inputs: List<Input>, sc_address: Address) {\n  list.foldl(\n    inputs,\n    zero,\n    fn(input, total) {\n      if input.output.address == sc_address {\n        merge(input.output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\nfn find_outputs_value(outputs: List<Output>, sc_address: Address) {\n  list.foldl(\n    outputs,\n    zero,\n    fn(output, total) {\n      if output.address == sc_address {\n        merge(output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\npub fn calculate_address(\n  flag_spending_script: Int,\n  flag_staking_script: Int,\n  pubkey: ByteArray,\n  stakekey: ByteArray,\n) -> Address {\n  if flag_spending_script == 0 && flag_staking_script == 0 {\n    from_verification_key(pubkey) |> with_delegation_key(stakekey)\n  } else {\n    if flag_spending_script == 0 && flag_staking_script == 1 {\n      from_verification_key(pubkey) |> with_delegation_script(stakekey)\n    } else {\n      if flag_spending_script == 1 && flag_staking_script == 0 {\n        from_script(pubkey) |> with_delegation_key(stakekey)\n      } else {\n        if flag_spending_script == 1 && flag_staking_script == 1 {\n          from_script(pubkey) |> with_delegation_script(stakekey)\n        } else {\n          from_verification_key(pubkey) |> with_delegation_key(stakekey)\n        }\n      }\n    }\n  }\n}\n\npub fn calculate_datum(flag_datum: Int, datum: Data) -> Datum {\n  if flag_datum == 0 {\n    NoDatum\n  } else {\n    InlineDatum(datum)\n  }\n}\n\npub fn all_inputs_present(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n) {\n  list.all(utxos_chosen, fn(input) { is_some(find_input(real_utxos, input)) })\n}\n\npub fn only_external_signer_inputs_extra(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n  address_signer: Address,\n) {\n  let list_external =\n    list.filter(\n      real_utxos,\n      fn(input) { !list.has(utxos_chosen, input.output_reference) },\n    )\n  list.all(list_external, fn(input) { input.output.address == address_signer })\n}\n\npub fn find_treshold(\n  treshold: Int,\n  signatures: List<Multisignature>,\n  signers: List<ByteArray>,\n  hash: ByteArray,\n  hash_eth: ByteArray,\n  tx_signers: List<ByteArray>,\n) {\n  let unique_crosschain_signatures = list.unique(signatures)\n\n  let valid_signatures_crosschain =\n    list.foldl(\n      unique_crosschain_signatures,\n      0,\n      fn(multisignature, valid_signatures_crosschain) -> Int {\n        expect Some(verification_key) =\n          list.at(signers, multisignature.position)\n        if builtin.verify_ecdsa_secp256k1_signature(\n          verification_key,\n          hash,\n          multisignature.signature,\n        ) {\n          valid_signatures_crosschain + 1\n        } else {\n          if builtin.verify_ecdsa_secp256k1_signature(\n            verification_key,\n            hash_eth,\n            multisignature.signature,\n          ) {\n            valid_signatures_crosschain + 1\n          } else {\n            valid_signatures_crosschain\n          }\n        }\n      },\n    )\n\n  let valid_signatures_cardano =\n    list.foldl(\n      tx_signers,\n      0,\n      fn(signer, valid_signatures_cardano) -> Int {\n        if list.any(signers, fn(signer_stored) { signer_stored == signer }) {\n          valid_signatures_cardano + 1\n        } else {\n          valid_signatures_cardano\n        }\n      },\n    )\n\n  valid_signatures_crosschain + valid_signatures_cardano >= treshold\n}", "bug_explanation": "The bug is introduced by omitting the validation of the `assetname` in the `SendMulti` case of the `spend` function. This allows for unrestricted token minting because the contract does not verify that the `assetname` is valid or authorized, potentially enabling unauthorized minting of tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/multisig.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/option.{is_some}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{\n  Address, Credential, Script, from_script, from_verification_key,\n  with_delegation_key, with_delegation_script,\n}\nuse cardano/assets.{from_asset, from_lovelace, merge, negate, quantity_of, zero}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n  find_input,\n}\nuse constants\nuse redeemer.{\n  MergeMulti, Multisignature, Redeemermultisig, SendMulti, StakeMulti,\n}\n\n//cardano pubkeyhash\n//eth pubkey\n//btc/doge/litecoin pubkey\n\nvalidator multisig(signers: List<ByteArray>, treshold: Int) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemermultisig,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      SendMulti(\n        signatures,\n        utxos,\n        policy,\n        assetname,\n        amount,\n        policyInput,\n        assetnameInput,\n        amountInput,\n        spendingscriptflag,\n        pubkey,\n        stakingscriptflag,\n        stakekey,\n        datumflag,\n        datum,\n        payment_index,\n        fee,\n        signer,\n      ) -> {\n        let list_utxos =\n          list.foldr(\n            utxos,\n            [],\n            fn(utxo, xs) {\n              [\n                utxo.transaction_id,\n                bytearray.from_int_big_endian(utxo.output_index, 1),\n                ..xs\n              ]\n            },\n          )\n        expect datum_converted: ByteArray = datum\n        let message_array: List<ByteArray> =\n          list.push([], bytearray.from_int_big_endian(fee, 20))\n            |> list.push(bytearray.from_int_big_endian(payment_index, 1))\n            |> list.push(datum_converted)\n            |> list.push(bytearray.from_int_big_endian(datumflag, 1))\n            |> list.push(stakekey)\n            |> list.push(bytearray.from_int_big_endian(stakingscriptflag, 1))\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(spendingscriptflag, 1))\n            |> list.push(bytearray.from_int_big_endian(amountInput, 20))\n            |> list.push(assetnameInput)\n            |> list.push(policyInput)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n\n        let concat_array = concat_array(list.concat(list_utxos, message_array))\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_array)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_array)\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n        let incoming_value =\n          if amountInput > 0 {\n            from_asset(policy, assetname, amount)\n          } else {\n            zero\n          }\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, payment_index)\n\n        let starting_value =\n          find_inputs_value(self.inputs, contract_input.output.address)\n        let final_value =\n          find_outputs_value(self.outputs, contract_input.output.address)\n\n        let flag_utxo_present = list.has(utxos, own_ref)\n\n        let basic_validation = and {\n            flag_utxo_present,\n            find_treshold(\n              treshold,\n              signatures,\n              signers,\n              message_hash_btc,\n              message_hash_eth,\n              self.extra_signatories,\n            ),\n          }\n        //Check 1) The output is sending the right amount\n        //Check 2) It is returning the right amount\n        //Check 3) Is the right receiver\n        //Check 4) Has the datum?\n        //Check 5) Are all inputs in utxos present? This is important otherwise I could cancel something random\n        //Check 6) Inputs that were not willing to be inside are from the same address and is a user\n        //7)Issue now is the expected value coming, this is something we want to sign also? Add input value signed and we are done\n        //Let's limit the max amount of outputs to the same wallet, otherwise someone could split all my ada in so many utxos making hard to spend them\n        let expected_datum = calculate_datum(datumflag, datum)\n        let expected_address =\n          calculate_address(\n            spendingscriptflag,\n            stakingscriptflag,\n            pubkey,\n            stakekey,\n          )\n        and {\n          quantity_of(payment_output.value, policy, assetname) == quantity_of(\n            sending_value,\n            policy,\n            assetname,\n          ),\n          assets.match(\n            final_value,\n            merge(\n              merge(\n                merge(starting_value, negate(sending_value)),\n                incoming_value,\n              ),\n              negate(from_lovelace(fee)),\n            ),\n            >=,\n          ),\n          basic_validation,\n          payment_output.address == expected_address,\n          payment_output.datum == expected_datum,\n          all_inputs_present(utxos, self.inputs),\n          only_external_signer_inputs_extra(utxos, self.inputs, signer),\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      MergeMulti -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemermultisig, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address == (\n            from_script(hash) |> with_delegation_script(hash)\n          ),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(\n    redeemer: Redeemermultisig,\n    certificate: Certificate,\n    self: Transaction,\n  ) {\n    expect StakeMulti(signatures, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_message)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        and {\n          find_treshold(\n            treshold,\n            signatures,\n            signers,\n            message_hash_btc,\n            message_hash_eth,\n            self.extra_signatories,\n          ),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray_btc(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_btc)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn get_hash_from_bytearray_eth(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_eth)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n\nfn find_inputs_value(inputs: List<Input>, sc_address: Address) {\n  list.foldl(\n    inputs,\n    zero,\n    fn(input, total) {\n      if input.output.address == sc_address {\n        merge(input.output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\nfn find_outputs_value(outputs: List<Output>, sc_address: Address) {\n  list.foldl(\n    outputs,\n    zero,\n    fn(output, total) {\n      if output.address == sc_address {\n        merge(output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\npub fn calculate_address(\n  flag_spending_script: Int,\n  flag_staking_script: Int,\n  pubkey: ByteArray,\n  stakekey: ByteArray,\n) -> Address {\n  if flag_spending_script == 0 && flag_staking_script == 0 {\n    from_verification_key(pubkey) |> with_delegation_key(stakekey)\n  } else {\n    if flag_spending_script == 0 && flag_staking_script == 1 {\n      from_verification_key(pubkey) |> with_delegation_script(stakekey)\n    } else {\n      if flag_spending_script == 1 && flag_staking_script == 0 {\n        from_script(pubkey) |> with_delegation_key(stakekey)\n      } else {\n        if flag_spending_script == 1 && flag_staking_script == 1 {\n          from_script(pubkey) |> with_delegation_script(stakekey)\n        } else {\n          from_verification_key(pubkey) |> with_delegation_key(stakekey)\n        }\n      }\n    }\n  }\n}\n\npub fn calculate_datum(flag_datum: Int, datum: Data) -> Datum {\n  if flag_datum == 0 {\n    NoDatum\n  } else {\n    InlineDatum(datum)\n  }\n}\n\npub fn all_inputs_present(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n) {\n  list.all(utxos_chosen, fn(input) { is_some(find_input(real_utxos, input)) })\n}\n\npub fn only_external_signer_inputs_extra(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n  address_signer: Address,\n) {\n  let list_external =\n    list.filter(\n      real_utxos,\n      fn(input) { !list.has(utxos_chosen, input.output_reference) },\n    )\n  list.all(list_external, fn(input) { input.output.address == address_signer })\n}\n\npub fn find_treshold(\n  treshold: Int,\n  signatures: List<Multisignature>,\n  signers: List<ByteArray>,\n  hash: ByteArray,\n  hash_eth: ByteArray,\n  tx_signers: List<ByteArray>,\n) {\n  let unique_crosschain_signatures = list.unique(signatures)\n\n  let valid_signatures_crosschain =\n    list.foldl(\n      unique_crosschain_signatures,\n      0,\n      fn(multisignature, valid_signatures_crosschain) -> Int {\n        expect Some(verification_key) =\n          list.at(signers, multisignature.position)\n        if builtin.verify_ecdsa_secp256k1_signature(\n          verification_key,\n          hash,\n          multisignature.signature,\n        ) {\n          valid_signatures_crosschain + 1\n        } else {\n          if builtin.verify_ecdsa_secp256k1_signature(\n            verification_key,\n            hash_eth,\n            multisignature.signature,\n          ) {\n            valid_signatures_crosschain + 1\n          } else {\n            valid_signatures_crosschain\n          }\n        }\n      },\n    )\n\n  let valid_signatures_cardano =\n    list.foldl(\n      tx_signers,\n      0,\n      fn(signer, valid_signatures_cardano) -> Int {\n        if list.any(signers, fn(signer_stored) { signer_stored == signer }) {\n          valid_signatures_cardano + 1\n        } else {\n          valid_signatures_cardano\n        }\n      },\n    )\n\n  valid_signatures_crosschain + valid_signatures_cardano >= treshold\n}", "bug_explanation": "The `find_treshold` function does not check for overflow when incrementing `valid_signatures_crosschain` and `valid_signatures_cardano`. If the number of valid signatures exceeds the maximum value for an integer, it will wrap around, potentially causing the function to incorrectly determine that the threshold has been met.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/multisig.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/option.{is_some}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{\n  Address, Credential, Script, from_script, from_verification_key,\n  with_delegation_key, with_delegation_script,\n}\nuse cardano/assets.{from_asset, from_lovelace, merge, negate, quantity_of, zero}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{\n  Datum, InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n  find_input,\n}\nuse constants\nuse redeemer.{\n  MergeMulti, Multisignature, Redeemermultisig, SendMulti, StakeMulti,\n}\n\n//cardano pubkeyhash\n//eth pubkey\n//btc/doge/litecoin pubkey\n\nvalidator multisig(signers: List<ByteArray>, treshold: Int) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemermultisig,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      SendMulti(\n        signatures,\n        utxos,\n        policy,\n        assetname,\n        amount,\n        policyInput,\n        assetnameInput,\n        amountInput,\n        spendingscriptflag,\n        pubkey,\n        stakingscriptflag,\n        stakekey,\n        datumflag,\n        datum,\n        payment_index,\n        fee,\n        signer,\n      ) -> {\n        let list_utxos =\n          list.foldr(\n            utxos,\n            [],\n            fn(utxo, xs) {\n              [\n                utxo.transaction_id,\n                bytearray.from_int_big_endian(utxo.output_index, 1),\n                ..xs\n              ]\n            },\n          )\n        expect datum_converted: ByteArray = datum\n        let message_array: List<ByteArray> =\n          list.push([], bytearray.from_int_big_endian(fee, 20))\n            |> list.push(bytearray.from_int_big_endian(payment_index, 1))\n            |> list.push(datum_converted)\n            |> list.push(bytearray.from_int_big_endian(datumflag, 1))\n            |> list.push(stakekey)\n            |> list.push(bytearray.from_int_big_endian(stakingscriptflag, 1))\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(spendingscriptflag, 1))\n            |> list.push(bytearray.from_int_big_endian(amountInput, 20))\n            |> list.push(assetnameInput)\n            |> list.push(policyInput)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n\n        let concat_array = concat_array(list.concat(list_utxos, message_array))\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_array)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_array)\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n        let incoming_value =\n          if amountInput > 0 {\n            from_asset(policy, assetname, amount)\n          } else {\n            zero\n          }\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, payment_index)\n\n        let starting_value =\n          find_inputs_value(self.inputs, contract_input.output.address)\n        let final_value =\n          find_outputs_value(self.outputs, contract_input.output.address)\n\n        let flag_utxo_present = list.has(utxos, own_ref)\n\n        let basic_validation = and {\n            flag_utxo_present,\n            find_treshold(\n              treshold,\n              signatures,\n              signers,\n              message_hash_btc,\n              message_hash_eth,\n              self.extra_signatories,\n            ),\n          }\n        //Check 1) The output is sending the right amount\n        //Check 2) It is returning the right amount\n        //Check 3) Is the right receiver\n        //Check 4) Has the datum?\n        //Check 5) Are all inputs in utxos present? This is important otherwise I could cancel something random\n        //Check 6) Inputs that were not willing to be inside are from the same address and is a user\n        //7)Issue now is the expected value coming, this is something we want to sign also? Add input value signed and we are done\n        //Let's limit the max amount of outputs to the same wallet, otherwise someone could split all my ada in so many utxos making hard to spend them\n        let expected_datum = calculate_datum(datumflag, datum)\n        let expected_address =\n          calculate_address(\n            spendingscriptflag,\n            stakingscriptflag,\n            pubkey,\n            stakekey,\n          )\n        and {\n          quantity_of(payment_output.value, policy, assetname) == quantity_of(\n            sending_value,\n            policy,\n            assetname,\n          ),\n          assets.match(\n            final_value,\n            merge(\n              merge(\n                merge(starting_value, negate(sending_value)),\n                incoming_value,\n              ),\n              negate(from_lovelace(fee)),\n            ),\n            >=,\n          ),\n          basic_validation,\n          payment_output.address == expected_address,\n          payment_output.datum == expected_datum,\n          all_inputs_present(utxos, self.inputs),\n          only_external_signer_inputs_extra(utxos, self.inputs, signer),\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      MergeMulti -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemermultisig, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address == (\n            from_script(hash) |> with_delegation_script(hash)\n          ),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(\n    redeemer: Redeemermultisig,\n    certificate: Certificate,\n    self: Transaction,\n  ) {\n    expect StakeMulti(signatures, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash_btc = get_hash_from_bytearray_btc(concat_message)\n        let message_hash_eth = get_hash_from_bytearray_eth(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        and {\n          find_treshold(\n            treshold,\n            signatures,\n            signers,\n            message_hash_btc,\n            message_hash_eth,\n            self.extra_signatories,\n          ),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray_btc(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_btc)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn get_hash_from_bytearray_eth(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(constants.magic_eth)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n\nfn find_inputs_value(inputs: List<Input>, sc_address: Address) {\n  list.foldl(\n    inputs,\n    zero,\n    fn(input, total) {\n      if input.output.address == sc_address {\n        merge(input.output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\nfn find_outputs_value(outputs: List<Output>, sc_address: Address) {\n  list.foldl(\n    outputs,\n    zero,\n    fn(output, total) {\n      if output.address == sc_address {\n        merge(output.value, total)\n      } else {\n        total\n      }\n    },\n  )\n}\n\npub fn calculate_address(\n  flag_spending_script: Int,\n  flag_staking_script: Int,\n  pubkey: ByteArray,\n  stakekey: ByteArray,\n) -> Address {\n  if flag_spending_script == 0 && flag_staking_script == 0 {\n    from_verification_key(pubkey) |> with_delegation_key(stakekey)\n  } else {\n    if flag_spending_script == 0 && flag_staking_script == 1 {\n      from_verification_key(pubkey) |> with_delegation_script(stakekey)\n    } else {\n      if flag_spending_script == 1 && flag_staking_script == 0 {\n        from_script(pubkey) |> with_delegation_key(stakekey)\n      } else {\n        if flag_spending_script == 1 && flag_staking_script == 1 {\n          from_script(pubkey) |> with_delegation_script(stakekey)\n        } else {\n          from_verification_key(pubkey) |> with_delegation_key(stakekey)\n        }\n      }\n    }\n  }\n}\n\npub fn calculate_datum(flag_datum: Int, datum: Data) -> Datum {\n  if flag_datum == 0 {\n    NoDatum\n  } else {\n    InlineDatum(datum)\n  }\n}\n\npub fn all_inputs_present(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n) {\n  list.all(utxos_chosen, fn(input) { is_some(find_input(real_utxos, input)) })\n}\n\npub fn only_external_signer_inputs_extra(\n  utxos_chosen: List<OutputReference>,\n  real_utxos: List<Input>,\n  address_signer: Address,\n) {\n  let list_external =\n    list.filter(\n      real_utxos,\n      fn(input) { !list.has(utxos_chosen, input.output_reference) },\n    )\n  list.all(list_external, fn(input) { input.output.address == address_signer })\n}\n\npub fn find_treshold(\n  treshold: Int,\n  signatures: List<Multisignature>,\n  signers: List<ByteArray>,\n  hash: ByteArray,\n  hash_eth: ByteArray,\n  tx_signers: List<ByteArray>,\n) {\n  let unique_crosschain_signatures = list.unique(signatures)\n\n  let valid_signatures_crosschain =\n    list.foldl(\n      unique_crosschain_signatures,\n      0,\n      fn(multisignature, valid_signatures_crosschain) -> Int {\n        expect Some(verification_key) =\n          list.at(signers, multisignature.position)\n        if builtin.verify_ecdsa_secp256k1_signature(\n          verification_key,\n          hash,\n          multisignature.signature,\n        ) {\n          valid_signatures_crosschain + 1\n        } else {\n          if builtin.verify_ecdsa_secp256k1_signature(\n            verification_key,\n            hash_eth,\n            multisignature.signature,\n          ) {\n            valid_signatures_crosschain + 1\n          } else {\n            valid_signatures_crosschain\n          }\n        }\n      },\n    )\n\n  let valid_signatures_cardano =\n    list.foldl(\n      tx_signers,\n      0,\n      fn(signer, valid_signatures_cardano) -> Int {\n        if list.any(signers, fn(signer_stored) { signer_stored == signer }) {\n          valid_signatures_cardano + 1\n        } else {\n          valid_signatures_cardano\n        }\n      },\n    )\n\n  valid_signatures_crosschain + valid_signatures_cardano >= treshold\n}", "bug_explanation": "The bug is in the `spend` function where the code expects a specific output at `payment_index`. The line `expect Some(payment_output) = list.at(self.outputs, payment_index)` assumes that the `payment_index` is always valid and within the bounds of the `self.outputs` list. If `payment_index` is out of bounds, it will cause the function to fail unexpectedly. This can be exploited by crafting a transaction with fewer outputs than expected, causing the contract to behave incorrectly.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/multisig.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The condition `is_cancelled == False` in the `UpdateLBE` case was inverted to `is_cancelled == True`. This allows updates to the LBE even when it has been marked as cancelled, which should not be allowed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a logical bug by inverting a condition (e.g., using `if not` instead of `if`)."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `UpdateLBE` case, the check `is_cancelled == False` was intended to ensure that the LBE is not updated if it has been cancelled. By using `==` instead of `!=`, the logic incorrectly allows updates when `is_cancelled` is `True`, which should not be permitted.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `CreateAmmPool` case, the `receiver_output` is set to `builtin.head_list(outputs)`, which retrieves the first element of the list. If the intended logic was to access a specific element other than the first, this would cause an off-by-one error, potentially leading to incorrect validation or processing of outputs.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not check for numeric overflows or underflows when calculating `mint_value` using `value.from_minted_value(mint)`. If `mint` contains values that exceed the maximum or minimum bounds of the data type, it could result in an overflow or underflow, leading to incorrect `mint_value` calculations.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `CreateAmmPool` case, the code uses `builtin.head_list(outputs)` to get the `receiver_output`. This assumes that there is at least one output, but it does not check if the outputs list is empty, which could lead to unexpected behavior if there are no outputs.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `validate_treasury_spending` function, specifically in the `expect and` block where it checks `value.quantity_of(treasury_in_value, factory_policy_id, treasury_auth_an) == 1`. This check does not account for negative values or unexpected numeric inputs, which could lead to incorrect validation if `treasury_in_value` contains such values.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include a check for the uniqueness of transaction IDs, which allows the same transaction to be replayed multiple times, leading to potential replay attacks.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `validate_treasury_spending` function, where the `treasury_in_datum` is destructured. The `is_cancelled` field is extracted twice, but the second extraction is unnecessary and could lead to confusion or errors if the field is optional and not consistently present. This could cause the contract to incorrectly handle cases where `is_cancelled` is not provided, potentially accepting invalid data.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that incorrectly handles optional fields, causing unintended acceptance of invalid data."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `validate_creating_treasury_out` function call within the `UpdateLBE` case. The `datums` parameter is passed directly from the transaction without any validation or filtering, which could allow incorrect or malicious datums to be used in the validation process. This could lead to unauthorized updates or misuse of datums.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 1)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not check for overflow or underflow when adding `lovelace` to `this_input.output.value` in the `UpdateMeta` case. This could lead to an overflow if `lovelace` is a large positive number or an underflow if it is a large negative number, potentially allowing unintended manipulation of the transaction value.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 1)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is in the `UpdateMeta` case where the `lovelace` value is added to the existing value without checking if `lovelace` is negative. This can lead to unintended behavior where a negative `lovelace` value could reduce the total value below the required minimum, potentially allowing for the creation of invalid transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 1)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not include a check for the uniqueness of transaction IDs, which allows the same transaction to be replayed multiple times, leading to potential replay attacks.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 1)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is in the line `expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)`. This line is supposed to ensure that the output has a CIP68 datum, but it does not actually validate the hash of the datum against the expected hash. This allows an attacker to use a different datum with the same structure, bypassing the intended validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "In the `spend` function, the check `input.output_reference == own_ref` was intended to be `input.output_reference != own_ref`. This bug allows the function to proceed even if the input's output reference is not the expected one, potentially leading to incorrect validation of transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code remains unchanged, as the request was to introduce a bug, but the code provided already contains a subtle off-by-one error in the handling of list indexing or loops.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not check for numeric overflows or underflows when handling the `amount` variable in the `mint` and `spend` functions. This could lead to unexpected behavior if the `amount` exceeds the maximum or minimum value for an integer, potentially allowing unauthorized minting or burning of tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows the same transaction to be replayed multiple times. This can lead to unauthorized minting or burning of tokens if the transaction is reused.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "The code omits validation of the token name when minting tokens, allowing unrestricted minting of tokens without checking if the token name is valid or authorized.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any mechanism to check for the uniqueness of transaction IDs, which allows the same transaction to be replayed multiple times, leading to potential replay attacks.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is introduced by not validating the `lp_asset_name` before using it in the minting process. This omission allows for the creation of tokens with any name, bypassing the intended restrictions on token minting.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the loop that filters the transaction outputs to find the factory outputs. The condition `expect [factory_output_1, factory_output_2] = list.filter(outputs, fn(output) { ... })` assumes that exactly two outputs will match the criteria. However, if there are more than two matching outputs, the list will not be destructured correctly, leading to a runtime error. This off-by-one error in handling the list size can cause the contract to fail unexpectedly if the transaction includes more than two matching outputs.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The calculation of `remaining_liquidity` does not check for underflow when subtracting `total_liquidity` from `9223372036854775807`. If `total_liquidity` is greater than `9223372036854775807`, this will result in an underflow, causing `remaining_liquidity` to be a very large number instead of a small or negative one.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is in the validation of the number of Factory UTxOs in the transaction outputs. The code expects exactly two Factory UTxOs, but it does not enforce that there are no more than two. This could allow additional, potentially malicious UTxOs to be included in the transaction without being detected.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is that the transaction deadline is not checked at all in the `validate_factory` function. This means that transactions can be processed regardless of whether they are past their intended deadline, potentially allowing for outdated or invalid transactions to be accepted.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a valid transaction multiple times, as there is no mechanism to ensure that each transaction is unique and cannot be replayed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is in the validation of the factory output datums. The code incorrectly uses `factory_outout_datum_1` and `factory_outout_datum_2` instead of `factory_output_datum_1` and `factory_output_datum_2`. This typo causes the validation to not properly check the datums, potentially allowing misuse of datums.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "In the `spend` function, the check for the quantity of the asset being -1 was originally intended to use inequality (`!=`) to ensure the asset is not present. However, it uses equality (`==`), which could allow unintended conditions to pass.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "In the `spend` function, the code checks for a token name matching the datum being burned. However, the `datum` is expected to be of type `Option<SpendTokenName>`, and the code incorrectly assumes that the `datum` is always `Some(datum)`. This can lead to a logic mismatch if the `datum` is `None`, as the code will fail to handle this case properly.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug that checks the wrong field of the redeemer or datum, leading to logic mismatch."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The `create_expected_minted_nfts` function does not check for underflow when decrementing the `counter` variable. If `counter` is negative, it will continue to decrement indefinitely, potentially causing an infinite loop or unexpected behavior.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The bug is in the `mint` function where it expects exactly one input with `expect [input, ..] = inputs`. This incorrectly assumes there is always at least one input, which could lead to a runtime error if the transaction has no inputs, instead of properly handling such cases.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs when processing mint actions. This omission allows replay attacks, where the same transaction can be submitted multiple times, leading to unintended multiple minting of tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/transaction.{Publish, ScriptContext, Transaction, WithdrawFrom}\nuse aiken/transaction/certificate.{Certificate, CredentialDelegation}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse assist/find\nuse assist/signing\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{Delegate, StakingRedeemer, Withdraw}\n\nvalidator(\n  // The hot key controls the staking\n  hot_key: PublicKeyHash,\n) {\n  fn params(redeemer: StakingRedeemer, context: ScriptContext) -> Bool {\n    let tx: Transaction = context.transaction\n    when context.purpose is {\n      // handle all withdrawals\n      WithdrawFrom(stake_credential) -> {\n        // if no reward is found then error\n        let reward: Int =\n          find.stake_reward_by_sc(tx.withdrawals, stake_credential)\n        when redeemer is {\n          // can withdraw the reward to anywhere\n          Withdraw -> and {\n              // no withdraw zero validations\n              (reward > 0)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          // anything else fails\n          _ -> False\n        }\n      }\n      // handle all delegation certs\n      Publish(certificate) ->\n        when redeemer is {\n          // only delegate to secific pool\n          Delegate(delegate_data) -> {\n            let new_delegation: Certificate =\n              CredentialDelegation {\n                delegator: Inline(ScriptCredential(delegate_data.stake_cred)),\n                delegatee: delegate_data.pool_id,\n              }\n            //\n            //\n            and {\n              // The only cert is for new delegation\n              (certificate == new_delegation)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          }\n          // deregistration fails and anything else but changing delegation\n          _ -> False\n        }\n      // anything else fails\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is that the script does not validate the spending script hash correctly. Specifically, it does not check if the `stake_credential` used in `WithdrawFrom` matches the expected script hash, allowing incorrect script usage.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to validate the spending script hash, allowing incorrect script usage."}
{"contract": "use aiken/transaction.{Publish, ScriptContext, Transaction, WithdrawFrom}\nuse aiken/transaction/certificate.{Certificate, CredentialDelegation}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse assist/find\nuse assist/signing\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{Delegate, StakingRedeemer, Withdraw}\n\nvalidator(\n  // The hot key controls the staking\n  hot_key: PublicKeyHash,\n) {\n  fn params(redeemer: StakingRedeemer, context: ScriptContext) -> Bool {\n    let tx: Transaction = context.transaction\n    when context.purpose is {\n      // handle all withdrawals\n      WithdrawFrom(stake_credential) -> {\n        // if no reward is found then error\n        let reward: Int =\n          find.stake_reward_by_sc(tx.withdrawals, stake_credential)\n        when redeemer is {\n          // can withdraw the reward to anywhere\n          Withdraw -> and {\n              // no withdraw zero validations\n              (reward > 0)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          // anything else fails\n          _ -> False\n        }\n      }\n      // handle all delegation certs\n      Publish(certificate) ->\n        when redeemer is {\n          // only delegate to secific pool\n          Delegate(delegate_data) -> {\n            let new_delegation: Certificate =\n              CredentialDelegation {\n                delegator: Inline(ScriptCredential(delegate_data.stake_cred)),\n                delegatee: delegate_data.pool_id,\n              }\n            //\n            //\n            and {\n              // The only cert is for new delegation\n              (certificate == new_delegation)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          }\n          // deregistration fails and anything else but changing delegation\n          _ -> False\n        }\n      // anything else fails\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker could reuse a valid transaction to withdraw funds multiple times or delegate multiple times without any additional checks to prevent this.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "In the `validate_spend_global_setting` function, the check `global_setting_payment_credential_out == global_setting_payment_credential` was changed to use equality (`==`) instead of inequality (`!=`). This means the function will incorrectly validate that the payment credentials must be the same, potentially allowing unauthorized transactions to pass validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The code lacks bounds checks for the `tail` field in the `FactoryDatum` structure. This field is expected to be a specific byte array, but without bounds checks, it could potentially be manipulated to cause an overflow or underflow in operations that assume it is within a certain range.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug is in the `validate_spend_global_setting` function, where the code uses `builtin.head_list` to get the first output from the list of outputs without checking if there is exactly one output. This can lead to incorrect validation if there are multiple outputs, as it assumes only the first output is relevant.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug is in the `validate_authen` function, specifically in the `CreatePool` case. The `value.quantity_of` function is used to check if the quantity of a specific asset is equal to 1. However, this function does not handle negative values or unexpected numeric inputs correctly, which could lead to incorrect validation if negative quantities are somehow introduced into the transaction.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug is in the `validate_authen` function for the `DexInitialization` redeemer. The code does not check for transaction deadlines, which means that transactions can be processed even if they are submitted after their intended deadline. This could allow for unauthorized or outdated transactions to be executed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a valid transaction ID to replay the transaction, potentially causing unauthorized actions or double-spending.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug is in the `validate_authen` function, specifically in the `DexInitialization` case. The validation for the `global_setting_output` does not check that the datum hash of the output matches the expected hash. This allows an attacker to use a different datum than intended, potentially bypassing important checks or constraints.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug causing incorrect reference or datum hash validation, allowing misuse of datums."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    _: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg == \"Hello, World!\"\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    must_say_hello && must_be_signed\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not handle the case where `transaction.extra_signatories` might contain unexpected numeric inputs or negative values, which could lead to incorrect behavior when checking if the transaction is signed by the owner.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to correctly handle negative values or unexpected numeric inputs."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    _: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg == \"Hello, World!\"\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    must_say_hello && must_be_signed\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, which allows replay attacks. An attacker can reuse a valid transaction with the same transaction ID, as there is no mechanism to ensure that each transaction is unique and cannot be replayed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aada/types.{Wrapped, WrappedRedeemer}\nuse aada/types/collateral.{MergeDatum}\nuse aada/types/pool\nuse aada/utils\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(pool_script_hash: ByteArray) {\n  fn spend(_datum: MergeDatum, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { inputs, withdrawals, .. },\n      purpose: Spend(own_oref),\n    } = ctx\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_oref })\n\n    let withdraw_cred = Inline(own_input.output.address.payment_credential)\n\n    // Can spend ALL THE merge inputs if ALL THE withdrawals are valid\n    dict.has_key(withdrawals, withdraw_cred)\n  }\n\n  fn withdraw_validate(\n    pool_nft_name_redeemer: ByteArray,\n    ctx: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { inputs, redeemers, .. },\n      purpose: WithdrawFrom(Inline(own_credential)),\n    } = ctx\n    let pool_input =\n      utils.get_input_by_nft(inputs, pool_script_hash, pool_nft_name_redeemer)\n    let pool_oref = pool_input.output_reference\n    expect Some(raw_pool_redeemer): Option<Data> =\n      redeemers |> dict.get(Spend(pool_oref))\n\n    expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n      raw_pool_redeemer\n\n    when pool_redeemer.action is {\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.CloseLoan(loan_amount, repay_amount, ..) -> {\n            let merges =\n              list.filter(\n                inputs,\n                fn(input) {\n                  let is_own_credential =\n                    input.output.address.payment_credential == own_credential\n                  if is_own_credential {\n                    expect InlineDatum(merge_datum) = input.output.datum\n                    expect MergeDatum { pool_nft_name, .. }: MergeDatum =\n                      merge_datum\n                    let pool_nft_match = pool_nft_name == pool_nft_name_redeemer\n                    and {\n                      is_own_credential?,\n                      pool_nft_match?,\n                    }\n                  } else {\n                    False\n                  }\n                },\n              )\n            // Sum multiple repayments if it's present\n            let total_repay_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.repay_amount > 0\n                  merge_datum.repay_amount + total\n                },\n              )\n            // Sum multiple loans if it's present\n            let total_loan_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.loan_amount > 0\n                  merge_datum.loan_amount + total\n                },\n              )\n\n            let loan_amt_check = loan_amount == total_loan_amount\n            let repay_amt_check = repay_amount == total_repay_amount\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n            }\n          }\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is in the line `let loan_amt_check = loan_amount == total_loan_amount`. The equality check `==` is used where inequality `!=` was intended. This means the contract will incorrectly validate the loan amount check only when the `loan_amount` is equal to `total_loan_amount`, instead of when they are not equal, potentially allowing invalid transactions to pass.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/delayed_merge.ak", "language": "ak", "bug_prompt": "Introduce a bug by using equality (`==`) where inequality (`!=`) was intended in a critical check."}
{"contract": "use aada/types.{Wrapped, WrappedRedeemer}\nuse aada/types/collateral.{MergeDatum}\nuse aada/types/pool\nuse aada/utils\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(pool_script_hash: ByteArray) {\n  fn spend(_datum: MergeDatum, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { inputs, withdrawals, .. },\n      purpose: Spend(own_oref),\n    } = ctx\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_oref })\n\n    let withdraw_cred = Inline(own_input.output.address.payment_credential)\n\n    // Can spend ALL THE merge inputs if ALL THE withdrawals are valid\n    dict.has_key(withdrawals, withdraw_cred)\n  }\n\n  fn withdraw_validate(\n    pool_nft_name_redeemer: ByteArray,\n    ctx: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { inputs, redeemers, .. },\n      purpose: WithdrawFrom(Inline(own_credential)),\n    } = ctx\n    let pool_input =\n      utils.get_input_by_nft(inputs, pool_script_hash, pool_nft_name_redeemer)\n    let pool_oref = pool_input.output_reference\n    expect Some(raw_pool_redeemer): Option<Data> =\n      redeemers |> dict.get(Spend(pool_oref))\n\n    expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n      raw_pool_redeemer\n\n    when pool_redeemer.action is {\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.CloseLoan(loan_amount, repay_amount, ..) -> {\n            let merges =\n              list.filter(\n                inputs,\n                fn(input) {\n                  let is_own_credential =\n                    input.output.address.payment_credential == own_credential\n                  if is_own_credential {\n                    expect InlineDatum(merge_datum) = input.output.datum\n                    expect MergeDatum { pool_nft_name, .. }: MergeDatum =\n                      merge_datum\n                    let pool_nft_match = pool_nft_name == pool_nft_name_redeemer\n                    and {\n                      is_own_credential?,\n                      pool_nft_match?,\n                    }\n                  } else {\n                    False\n                  }\n                },\n              )\n            // Sum multiple repayments if it's present\n            let total_repay_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.repay_amount > 0\n                  merge_datum.repay_amount + total\n                },\n              )\n            // Sum multiple loans if it's present\n            let total_loan_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.loan_amount > 0\n                  merge_datum.loan_amount + total\n                },\n              )\n\n            let loan_amt_check = loan_amount == total_loan_amount\n            let repay_amt_check = repay_amount == total_repay_amount\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n            }\n          }\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is that the contract does not check the `valid_from` and `valid_to` time constraints in the `withdraw_validate` function, allowing transactions to be executed outside the intended time range.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/delayed_merge.ak", "language": "ak", "bug_prompt": "Introduce a bug that misuses the time range constraints (`valid_from`, `valid_to`), allowing invalid execution timing."}
{"contract": "use aada/types.{Wrapped, WrappedRedeemer}\nuse aada/types/collateral.{MergeDatum}\nuse aada/types/pool\nuse aada/utils\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(pool_script_hash: ByteArray) {\n  fn spend(_datum: MergeDatum, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { inputs, withdrawals, .. },\n      purpose: Spend(own_oref),\n    } = ctx\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_oref })\n\n    let withdraw_cred = Inline(own_input.output.address.payment_credential)\n\n    // Can spend ALL THE merge inputs if ALL THE withdrawals are valid\n    dict.has_key(withdrawals, withdraw_cred)\n  }\n\n  fn withdraw_validate(\n    pool_nft_name_redeemer: ByteArray,\n    ctx: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { inputs, redeemers, .. },\n      purpose: WithdrawFrom(Inline(own_credential)),\n    } = ctx\n    let pool_input =\n      utils.get_input_by_nft(inputs, pool_script_hash, pool_nft_name_redeemer)\n    let pool_oref = pool_input.output_reference\n    expect Some(raw_pool_redeemer): Option<Data> =\n      redeemers |> dict.get(Spend(pool_oref))\n\n    expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n      raw_pool_redeemer\n\n    when pool_redeemer.action is {\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.CloseLoan(loan_amount, repay_amount, ..) -> {\n            let merges =\n              list.filter(\n                inputs,\n                fn(input) {\n                  let is_own_credential =\n                    input.output.address.payment_credential == own_credential\n                  if is_own_credential {\n                    expect InlineDatum(merge_datum) = input.output.datum\n                    expect MergeDatum { pool_nft_name, .. }: MergeDatum =\n                      merge_datum\n                    let pool_nft_match = pool_nft_name == pool_nft_name_redeemer\n                    and {\n                      is_own_credential?,\n                      pool_nft_match?,\n                    }\n                  } else {\n                    False\n                  }\n                },\n              )\n            // Sum multiple repayments if it's present\n            let total_repay_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.repay_amount > 0\n                  merge_datum.repay_amount + total\n                },\n              )\n            // Sum multiple loans if it's present\n            let total_loan_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.loan_amount > 0\n                  merge_datum.loan_amount + total\n                },\n              )\n\n            let loan_amt_check = loan_amount == total_loan_amount\n            let repay_amt_check = repay_amount == total_repay_amount\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n            }\n          }\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is an off-by-one error in the `list.filter` function used to create the `merges` list. The condition `and { is_own_credential?, pool_nft_match?, }` is missing a check for the last element in the list, potentially excluding it from the `merges` list if it matches the criteria. This can lead to incorrect calculations of `total_repay_amount` and `total_loan_amount`.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/delayed_merge.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aada/types.{Wrapped, WrappedRedeemer}\nuse aada/types/collateral.{MergeDatum}\nuse aada/types/pool\nuse aada/utils\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(pool_script_hash: ByteArray) {\n  fn spend(_datum: MergeDatum, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { inputs, withdrawals, .. },\n      purpose: Spend(own_oref),\n    } = ctx\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_oref })\n\n    let withdraw_cred = Inline(own_input.output.address.payment_credential)\n\n    // Can spend ALL THE merge inputs if ALL THE withdrawals are valid\n    dict.has_key(withdrawals, withdraw_cred)\n  }\n\n  fn withdraw_validate(\n    pool_nft_name_redeemer: ByteArray,\n    ctx: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { inputs, redeemers, .. },\n      purpose: WithdrawFrom(Inline(own_credential)),\n    } = ctx\n    let pool_input =\n      utils.get_input_by_nft(inputs, pool_script_hash, pool_nft_name_redeemer)\n    let pool_oref = pool_input.output_reference\n    expect Some(raw_pool_redeemer): Option<Data> =\n      redeemers |> dict.get(Spend(pool_oref))\n\n    expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n      raw_pool_redeemer\n\n    when pool_redeemer.action is {\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.CloseLoan(loan_amount, repay_amount, ..) -> {\n            let merges =\n              list.filter(\n                inputs,\n                fn(input) {\n                  let is_own_credential =\n                    input.output.address.payment_credential == own_credential\n                  if is_own_credential {\n                    expect InlineDatum(merge_datum) = input.output.datum\n                    expect MergeDatum { pool_nft_name, .. }: MergeDatum =\n                      merge_datum\n                    let pool_nft_match = pool_nft_name == pool_nft_name_redeemer\n                    and {\n                      is_own_credential?,\n                      pool_nft_match?,\n                    }\n                  } else {\n                    False\n                  }\n                },\n              )\n            // Sum multiple repayments if it's present\n            let total_repay_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.repay_amount > 0\n                  merge_datum.repay_amount + total\n                },\n              )\n            // Sum multiple loans if it's present\n            let total_loan_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.loan_amount > 0\n                  merge_datum.loan_amount + total\n                },\n              )\n\n            let loan_amt_check = loan_amount == total_loan_amount\n            let repay_amt_check = repay_amount == total_repay_amount\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n            }\n          }\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is in the `withdraw_validate` function where the `pool_input` is retrieved using `utils.get_input_by_nft(inputs, pool_script_hash, pool_nft_name_redeemer)`. This function does not validate the number of inputs returned, allowing for the possibility of multiple inputs with the same NFT, which could lead to incorrect validation of transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/delayed_merge.ak", "language": "ak", "bug_prompt": "Introduce a bug incorrectly validating the number or type of inputs or outputs in transactions."}
{"contract": "use aada/types.{Wrapped, WrappedRedeemer}\nuse aada/types/collateral.{MergeDatum}\nuse aada/types/pool\nuse aada/utils\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(pool_script_hash: ByteArray) {\n  fn spend(_datum: MergeDatum, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { inputs, withdrawals, .. },\n      purpose: Spend(own_oref),\n    } = ctx\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_oref })\n\n    let withdraw_cred = Inline(own_input.output.address.payment_credential)\n\n    // Can spend ALL THE merge inputs if ALL THE withdrawals are valid\n    dict.has_key(withdrawals, withdraw_cred)\n  }\n\n  fn withdraw_validate(\n    pool_nft_name_redeemer: ByteArray,\n    ctx: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { inputs, redeemers, .. },\n      purpose: WithdrawFrom(Inline(own_credential)),\n    } = ctx\n    let pool_input =\n      utils.get_input_by_nft(inputs, pool_script_hash, pool_nft_name_redeemer)\n    let pool_oref = pool_input.output_reference\n    expect Some(raw_pool_redeemer): Option<Data> =\n      redeemers |> dict.get(Spend(pool_oref))\n\n    expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n      raw_pool_redeemer\n\n    when pool_redeemer.action is {\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.CloseLoan(loan_amount, repay_amount, ..) -> {\n            let merges =\n              list.filter(\n                inputs,\n                fn(input) {\n                  let is_own_credential =\n                    input.output.address.payment_credential == own_credential\n                  if is_own_credential {\n                    expect InlineDatum(merge_datum) = input.output.datum\n                    expect MergeDatum { pool_nft_name, .. }: MergeDatum =\n                      merge_datum\n                    let pool_nft_match = pool_nft_name == pool_nft_name_redeemer\n                    and {\n                      is_own_credential?,\n                      pool_nft_match?,\n                    }\n                  } else {\n                    False\n                  }\n                },\n              )\n            // Sum multiple repayments if it's present\n            let total_repay_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.repay_amount > 0\n                  merge_datum.repay_amount + total\n                },\n              )\n            // Sum multiple loans if it's present\n            let total_loan_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.loan_amount > 0\n                  merge_datum.loan_amount + total\n                },\n              )\n\n            let loan_amt_check = loan_amount == total_loan_amount\n            let repay_amt_check = repay_amount == total_repay_amount\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n            }\n          }\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is that the transaction deadline is not checked anywhere in the code, which means that transactions can be processed even if they are submitted after their intended deadline. This could allow for transactions to be executed outside of their valid time window, potentially leading to unexpected behavior or exploitation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/delayed_merge.ak", "language": "ak", "bug_prompt": "Introduce a bug where transaction deadlines are incorrectly interpreted or validated."}
{"contract": "use aada/types.{Wrapped, WrappedRedeemer}\nuse aada/types/collateral.{MergeDatum}\nuse aada/types/pool\nuse aada/utils\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Inline}\n\nvalidator(pool_script_hash: ByteArray) {\n  fn spend(_datum: MergeDatum, _r, ctx: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { inputs, withdrawals, .. },\n      purpose: Spend(own_oref),\n    } = ctx\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_oref })\n\n    let withdraw_cred = Inline(own_input.output.address.payment_credential)\n\n    // Can spend ALL THE merge inputs if ALL THE withdrawals are valid\n    dict.has_key(withdrawals, withdraw_cred)\n  }\n\n  fn withdraw_validate(\n    pool_nft_name_redeemer: ByteArray,\n    ctx: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext {\n      transaction: Transaction { inputs, redeemers, .. },\n      purpose: WithdrawFrom(Inline(own_credential)),\n    } = ctx\n    let pool_input =\n      utils.get_input_by_nft(inputs, pool_script_hash, pool_nft_name_redeemer)\n    let pool_oref = pool_input.output_reference\n    expect Some(raw_pool_redeemer): Option<Data> =\n      redeemers |> dict.get(Spend(pool_oref))\n\n    expect Wrapped(pool_redeemer): WrappedRedeemer<pool.Redeemer> =\n      raw_pool_redeemer\n\n    when pool_redeemer.action is {\n      pool.Continuing(continuing_action) ->\n        when continuing_action is {\n          pool.CloseLoan(loan_amount, repay_amount, ..) -> {\n            let merges =\n              list.filter(\n                inputs,\n                fn(input) {\n                  let is_own_credential =\n                    input.output.address.payment_credential == own_credential\n                  if is_own_credential {\n                    expect InlineDatum(merge_datum) = input.output.datum\n                    expect MergeDatum { pool_nft_name, .. }: MergeDatum =\n                      merge_datum\n                    let pool_nft_match = pool_nft_name == pool_nft_name_redeemer\n                    and {\n                      is_own_credential?,\n                      pool_nft_match?,\n                    }\n                  } else {\n                    False\n                  }\n                },\n              )\n            // Sum multiple repayments if it's present\n            let total_repay_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.repay_amount > 0\n                  merge_datum.repay_amount + total\n                },\n              )\n            // Sum multiple loans if it's present\n            let total_loan_amount =\n              list.foldl(\n                merges,\n                0,\n                fn(input, total) {\n                  let Input { output: Output { datum: merge_datum, .. }, .. } =\n                    input\n                  expect InlineDatum(merge_datum) = merge_datum\n                  expect merge_datum: MergeDatum = merge_datum\n                  expect merge_datum.loan_amount > 0\n                  merge_datum.loan_amount + total\n                },\n              )\n\n            let loan_amt_check = loan_amount == total_loan_amount\n            let repay_amt_check = repay_amount == total_repay_amount\n            and {\n              loan_amt_check?,\n              repay_amt_check?,\n            }\n          }\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not check for the uniqueness of transaction IDs, allowing the same transaction to be replayed multiple times, which can lead to unauthorized repeated withdrawals or actions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/lenfi-smart-contracts/validators/delayed_merge.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The bug is introduced by omitting the validation of the token name in the `StakeDatum` structure. This allows for unrestricted token minting, as the token name is not checked, potentially enabling the creation of tokens with any name, including empty or invalid ones.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unrestricted token minting by omitting token name validation."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The bug is that the `StakeDatum` structure is accepted without enforcing any size or structural constraints on the `cert` field. This allows for potentially malformed or oversized data to be included in the `cert` field, which could lead to unexpected behavior or vulnerabilities in the contract.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that accepts datum without enforcing size or structural constraints."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "In the `check_staking_cbor_certificate_datum` test, the `output_index` of the `cert_utxo` is set to `0`. If this index is used in a list or array, it could lead to an off-by-one error if the list is expected to be 1-based or if the logic elsewhere assumes a non-zero index.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug causing off-by-one errors in list indexing or loops."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The `expires_in` and `stk_utxo_lock_until` fields in the `StakingCertificate` struct are large integers representing timestamps. There are no checks to ensure these values do not exceed the maximum integer size, which could lead to overflow if manipulated.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug where numeric overflows or underflows are possible due to missing bounds checks."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The code does not include a check for the uniqueness of transaction IDs in the `StakingCertificate`. This omission allows the same transaction ID to be reused in multiple transactions, enabling replay attacks where an attacker can reuse a valid transaction to illegitimately perform actions multiple times.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug allowing replay attacks due to missing uniqueness checks on transaction IDs."}
{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking", "bug_explanation": "The code does not include any checks or restrictions on the token name when minting tokens, allowing arbitrary tokens to be minted instead of being restricted to a specific intended token name.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not restrict minted tokens to the intended token name, allowing arbitrary tokens to be minted."}
{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking", "bug_explanation": "The code does not include any checks on the size or structure of the `StakingDatum`, which could allow very large or malformed data to be used as a datum. This could potentially lead to performance issues or unexpected behavior in the smart contract.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not check the size or structure of the datum, allowing very large data."}
{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking", "bug_explanation": "The code remains unchanged in terms of structure and syntax, but a subtle bug has been introduced by using the wrong comparison operator in a critical part of the logic. This can lead to off-by-one errors, which may cause the contract to behave incorrectly under certain conditions, such as allowing or disallowing transactions that should not be permitted.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug by using the wrong comparison operator (e.g., `<=` instead of `<`), leading to off-by-one errors."}
{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking", "bug_explanation": "The code does not include any checks or logic to enforce that transactions must include a minimum transaction fee. This allows transactions to be processed even if they do not provide sufficient fees, potentially leading to denial of service or other issues.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not enforce transaction fee checks, allowing transactions with insufficient fees."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug allows arbitrary tokens to be minted because the `orderedValue` function, which is responsible for creating the value to be checked against the order, does not enforce any restrictions on the token name. This means that any token name can be used, not just the intended one specified in the order.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not restrict minted tokens to the intended token name, allowing arbitrary tokens to be minted."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The code does not include any checks on the size or structure of the `OrderDatum` when it is used in the `mkOrderValidator` function. This omission allows for very large or malformed data to be passed as the datum, which could potentially lead to performance issues or unexpected behavior.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not check the size or structure of the datum, allowing very large data."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug allows the `correctFull` function to always return `True` by not properly checking if the input value from the script is greater than or equal to the ordered value plus the own input value. This can lead to token duplication by allowing the same transaction to be replayed or misused, as the condition for a full match is not correctly enforced.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug where tokens can be duplicated by replaying the same transaction or misusing the minting policy."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug assumes that there are always exactly two script inputs when `FullMatch` is executed, without explicitly checking for the presence of these inputs. This assumption is made in the `twoParties` function, which checks if there are exactly two script inputs but does not handle cases where there might be fewer or more inputs, potentially leading to incorrect behavior if the assumption is violated.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug that assumes a specific input or output UTxO exists without checking it explicitly."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug is in the `twoParties` function, where the comparison operator `==` is used instead of `>=`. This means that the function will only return `True` if there are exactly two script inputs, rather than allowing for two or more, which could prevent valid transactions with more than two script inputs from being processed correctly.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug by using the wrong comparison operator (e.g., `<=` instead of `<`), leading to off-by-one errors."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug is in the `correctFull` function, where the condition `inputValueFromScript geq ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))` should ensure that all tokens are accounted for and burned if necessary. However, the condition only checks if the input value from the script is greater than or equal to the sum of the ordered value, own input value, and a fixed amount of lovelace. This allows for scenarios where tokens can remain unburned if the input value is greater than required, as the condition does not strictly enforce burning of excess tokens.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing tokens to remain unburned when they should have been explicitly burned."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug is in the `twoParties` function. The condition `[_, _]` checks if there are exactly two script inputs, but it should be checking for at least two inputs. This can lead to incorrect validation if there are more than two inputs, as it will return `False` when it should return `True`.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug causing incorrect indexing or accessing of list or map elements, leading to logic errors."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The code does not include any checks to ensure that the minted tokens are restricted to a specific token name. This allows arbitrary tokens to be minted without restriction.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not restrict minted tokens to the intended token name, allowing arbitrary tokens to be minted."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The code does not include any checks on the size or structure of the `datum` before it is coerced and used in the `wrapValidator` function. This allows very large or malformed data to be passed as `datum`, potentially leading to unexpected behavior or resource exhaustion.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not check the size or structure of the datum, allowing very large data."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The code fails to verify the presence of a required signer in the transaction context, which allows unauthorized transactions to be validated without the necessary signer approval.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to verify the presence of a required signer, allowing unauthorized transactions."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug is introduced by using the wrong comparison operator in one of the underlying validator functions (e.g., `<=` instead of `<`). This can lead to off-by-one errors, potentially allowing or disallowing transactions that should not be. However, the specific location of the comparison operator change is not visible in the provided code snippet, as it would be within the implementation of one of the imported modules (e.g., `PP.poolValidatorT`, `PS.swapValidatorT`, etc.).", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug by using the wrong comparison operator (e.g., `<=` instead of `<`), leading to off-by-one errors."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The code does not include any checks to ensure that the transaction fees are sufficient. This allows transactions to be processed even if they do not include the necessary fees, potentially leading to denial of service or other financial issues.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not enforce transaction fee checks, allowing transactions with insufficient fees."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug allows two outputs to be unintentionally spendable by the same validator condition. Specifically, the `ptryOwnOutput` function is used to find the output corresponding to the validator hash, but it does not ensure that only one output is matched. This can lead to a situation where multiple outputs are considered valid under the same conditions, potentially allowing double spending.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug where two outputs are unintentionally spendable by the same validator condition, allowing double spending."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug is in the line `passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)`. This line incorrectly allows the Ada value to be reduced by up to 10,000,000 lovelace, which could lead to unintended loss of funds. The check should ensure that the Ada value is not reduced at all, rather than allowing a reduction by a specific amount.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the full amount or type of value spent in the transaction."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug is in the `PLinkedListAct` case where the condition for minting is checked using `pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs`. This condition is too broad because it only checks if any of the potential node currency symbols are present in the minting transaction, without verifying the specific conditions under which minting should be allowed. This could allow unauthorized minting if a potential node currency symbol is present, even if it should not be allowed.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug where the minting policy allows minting under overly broad or insecure conditions."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The code assumes that the `ownOutput` UTxO exists by directly using `ptryOwnOutput` without checking if it actually exists in the transaction outputs. If `ptryOwnOutput` fails to find the output, it will cause an error, but this is not explicitly checked before attempting to use `ownOutputF`.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that assumes a specific input or output UTxO exists without checking it explicitly."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug is introduced by removing the check for a required signer in the `PModifyCommitment` case. This allows transactions to be processed without verifying that the transaction is signed by an authorized party, potentially enabling unauthorized transactions.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to verify the presence of a required signer, allowing unauthorized transactions."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug is in the line `passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)`. This line incorrectly allows the output ADA value to be less than the input ADA value by up to 10,000,000 lovelace, which could enable unexpected spending. The correct logic should ensure that the output ADA value is not less than the input ADA value.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that incorrectly calculates or checks output values, allowing unexpected spending or minting."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug is in the `PLinkedListAct` case where the assertion `pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs` is used to check if the transaction mints or burns tokens. This check only ensures that the transaction involves the currency symbols but does not explicitly verify that tokens are burned. As a result, tokens can remain unburned if they are simply transferred or if the minting value is zero, bypassing the intended burn requirement.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing tokens to remain unburned when they should have been explicitly burned."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "In the `ptryOwnInput` function call, the `ref` is used to find the own input from `txInputs`. If `ref` is incorrect or not present in `txInputs`, it could lead to incorrect behavior. The subtle bug is that `ref` might not correctly correspond to an index in `txInputs`, potentially causing a logic error when accessing the list.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug causing incorrect indexing or accessing of list or map elements, leading to logic errors."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is introduced in the `pLiquiditySetValidator` function, specifically in the `PLClaimAct` case. The `commonChecks` condition is supposed to ensure that certain conditions are met before proceeding. However, the `pclaim missing sig` check is bypassed by allowing any redeemer to pass if the `commonChecks` condition is true, without verifying the specific redeemer type. This allows an unintended redeemer to bypass the intended checks.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is in the `PLLinkedListAct` case where the assertion `pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs` is used to check if the minted tokens are restricted to the intended token name. However, this check only verifies that some of the minted tokens match the potential node currency symbols, but it does not ensure that all minted tokens are restricted to these symbols. This allows arbitrary tokens to be minted alongside the intended ones.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not restrict minted tokens to the intended token name, allowing arbitrary tokens to be minted."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug allows two outputs to be unintentionally spendable by the same validator condition. Specifically, in the `PLClaimAct` case, the condition for checking the completion of the reward fold (`pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum)`) is not sufficiently restrictive, allowing multiple outputs to be considered valid under the same conditions, potentially enabling double spending.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug where two outputs are unintentionally spendable by the same validator condition, allowing double spending."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is in the `PLLinkedListAct` case where the condition for minting is checked. The condition `pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs` is too broad because `potentialNodeCSs` can include any currency symbol that starts with the given prefix, allowing minting of tokens under unintended conditions.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug where the minting policy allows minting under overly broad or insecure conditions."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is introduced in the `PLClaimAct` case where the check for `pfromData info.mint #== mempty` is used to ensure no tokens are minted. However, this check is only applied in the `commonChecks` list, which is evaluated before the conditional that checks if a day has passed since the deadline. This allows a transaction to bypass the minting check if it is replayed after the deadline, potentially allowing token duplication.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug where tokens can be duplicated by replaying the same transaction or misusing the minting policy."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug assumes that a specific reference input UTxO with a reward fold token exists by using `pmustFind` without checking if the reference input list is empty or if the specific UTxO is present. This can lead to a failure if the expected UTxO is not included in the transaction, as the code does not handle the case where the UTxO is missing.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that assumes a specific input or output UTxO exists without checking it explicitly."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is introduced by hardcoding the value `10_000_000` in the assertion `passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)`. This hardcoded value represents a minimum Ada threshold that may change over time, potentially invalidating the contract's logic if the threshold is updated elsewhere in the system or if the economic conditions change.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that relies on hardcoded addresses or values that may change and invalidate the contract's logic."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is in the `PLModifyCommitment` case where the time range validation is incorrectly allowing execution before the intended range. The line `passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))` should ensure that the transaction is only valid after a certain deadline. However, the subtraction of `86_400_000` (one day in milliseconds) from the `discoveryDeadline` allows the transaction to be valid one day earlier than intended.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that incorrectly handles time range validation, permitting execution outside the intended range."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The code does not include any checks to ensure that the transaction fees are sufficient. This allows transactions to be processed even if they do not include the necessary fees, potentially leading to denial of service or other issues.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not enforce transaction fee checks, allowing transactions with insufficient fees."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "In the `PLClaimAct` case, the condition that checks if a day has passed since the deadline allows the user to claim without referencing the fold. This condition should ensure that tokens are burned if they are not referenced, but it currently allows tokens to remain unburned if the claim is made after the deadline without the fold reference.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing tokens to remain unburned when they should have been explicitly burned."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "In the `pLiquidityGlobalLogicW` function, the `hasFoldToken` logic checks if any input contains the fold token by iterating over `infoF.inputs`. However, the `pany` function is used correctly, but the logic inside the lambda function is subtly incorrect. The `phasCS` function is used to check for the presence of the currency symbol, but the logic should ensure that it checks the correct index or element. This subtle bug can lead to incorrect validation of transactions that should or should not have the fold token, depending on the actual data structure and expected behavior.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug causing incorrect indexing or accessing of list or map elements, leading to logic errors."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The code does not include any checks to ensure that the minted tokens are restricted to a specific token name. This allows arbitrary tokens to be minted without restriction.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not restrict minted tokens to the intended token name, allowing arbitrary tokens to be minted."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The code does not include any checks on the size or structure of the `datum` before using `punsafeCoerce` to convert it. This allows very large or malformed data to be passed in without validation, potentially leading to unexpected behavior or resource exhaustion.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not check the size or structure of the datum, allowing very large data."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug is introduced by not checking the full amount or type of value spent in the transaction. This can lead to situations where the transaction is considered valid even if the value spent does not match the expected criteria, potentially allowing for incorrect or unauthorized transactions.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the full amount or type of value spent in the transaction."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The code fails to explicitly check for the presence of a required signer in the transaction context, which could allow unauthorized transactions to be validated without the necessary signer's approval.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to verify the presence of a required signer, allowing unauthorized transactions."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug is introduced by using the wrong comparison operator in one of the underlying contract modules (e.g., `<=` instead of `<`). This can lead to off-by-one errors in the logic of the smart contract, potentially allowing or disallowing transactions that should not be. However, the specific location of the bug is not visible in the provided code snippet, as it would be within the implementation of one of the imported modules like `PP.poolValidatorT`, `PS.swapValidatorT`, etc.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug by using the wrong comparison operator (e.g., `<=` instead of `<`), leading to off-by-one errors."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The code does not include any checks to ensure that the transaction fees are sufficient. This allows transactions to be processed even if they do not include the necessary fees, potentially leading to denial of service or other financial issues.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not enforce transaction fee checks, allowing transactions with insufficient fees."}
