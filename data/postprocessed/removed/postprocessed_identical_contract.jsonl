{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking", "bug_explanation": "The code fails to include a check for the size or structure of the `StakingDatum` in the `mkValidatorStaking` function. This omission can lead to an 'unbounded-datum' vulnerability, where excessively large or malformed data can be passed as a datum, potentially causing performance issues or unexpected behavior.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug allows arbitrary token names to be minted because the `orderedValue` function does not properly restrict the token name to the intended one. This can lead to unintended tokens being minted if the token name is not correctly validated elsewhere in the contract.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug is introduced by not enforcing any specific type or structure for the datum in the `mkOrderValidator` function. This allows arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability. This can lead to unexpected behavior or security issues, as the contract may process transactions with unintended or malicious data.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The code fails to check the size or structure of the `OrderDatum` when it is used in the `mkOrderValidator` function. This omission can lead to an 'unbounded-datum' vulnerability, where a malicious user could potentially provide a datum of unexpected size or structure, leading to unexpected behavior or resource exhaustion.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug is in the `PLinkedListAct` case where the assertion `pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs` is supposed to restrict minting to specific token names. However, the logic only checks if any of the potential node currency symbols are present, without ensuring that the minted tokens have the correct token name. This allows arbitrary token names to be minted as long as they share the same currency symbol, bypassing the intended restriction.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug allows arbitrary token names to be minted by not properly restricting the token name in the validation logic. This could lead to unauthorized minting of tokens with unintended names, potentially compromising the integrity of the token system.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug is introduced by failing to check the size or structure of the `datum` before using `punsafeCoerce` to convert it. This can lead to an 'unbounded-datum' vulnerability where an attacker could potentially pass a datum of unexpected size or structure, causing the contract to behave incorrectly or inefficiently.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug allows the `PLClaimAct` redeemer to bypass the check for the reward fold UTXO reference input if the `commonChecks` condition is satisfied. This means that a user can claim without referencing the fold, even if the deadline has not passed, by using a different redeemer that satisfies the `commonChecks`.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is introduced in the `PLLinkedListAct` case where the assertion `pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs` is used to check if the minted tokens contain the expected currency symbols. However, this check only ensures that at least one of the potential node currency symbols is present, but it does not restrict the minting to only those symbols. This allows arbitrary token names to be minted alongside the expected ones.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module Dex.Validator where\n\nimport Plutarch --(ClosedTerm, pcon, plam, popaque, (#))\nimport Plutarch.Api.V2 --(PValidator, PScriptContext)\nimport Plutarch.Prelude --(PUnit (PUnit), PData, (:-->), POpaque, perror, (#==), pconstant, pif, PBuiltinList(PNil, PCons), pmatch, pfield, PMaybe(PNothing), pany)\nimport Plutarch.Builtin --(pasInt)\n\nimport Dex.Types\nimport Dex.Pool\n-- import Dex.StateMachine\n\n-- TODO make sure we don't have to check ScriptPurpose, or do check it if required\n\n-- TODO optimize case expressions (probably very inefficient right now)\n-- pMkDexValidator :: RegistryNFT -> TokenMetaNFT -> LiquidityNFT -> ClosedTerm PValidator\n-- pMkDexValidator registryNFT tokenMetaNFT liquidityNFT = phoistAcyclic $ plam $ \\datum redeemer context -> P.do \n--     stateMachineDatum <- pmatch datum\n--     case stateMachineDatum of\n--         PRegistryDatum  poolsRecord     -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> pregisterPool # \n--                 PCloseRedemer   closeRecord     -> punregisterPool\n--                 _                               -> perror\n--         PTokenMetaDatum tokenMetaRecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         PLiquidityDatum liquidityrecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         _                               -> perror\n    \n\n\n{-\nCreate Pool\n    - choose set of tokens; for each\n        - choose weight\n        - initial n (later: add a rule to optimize this)\n        - add initial liquidity >= n for each token\n    - determine if pool for those tokens exists with pool registry\n    - create for each token:\n        - metadata-utxo; carrying (Singular for now)\n            - token weight\n            - pool id\n            - n for that token\n            - emitted LP-tokens for that token in that pool\n        - n liquidity-utxos; each carrying\n            - nonzero amount of the token\n            - pool id\n-}\n\ncreatePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\ncreatePool dat red ctx = pconstant True\n\n{-\nClose Pool\n    - return all emitted LP-tokens for all tokens in the pool\n    - destroy all utxos\n    - return funds\n    - remove from pool registry\n-}\n\nclosePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nclosePool dat red ctx = pconstant True\n\n{-\nSwap\n    - choose \n        - pool to trade with\n        - pair of tokens; for each\n            - delta\n            - liquidity-utxo(s) to trade with\n                - for now: \n                    - same number in/out\n                    - ins/outs needs to end up balanced afterwards \n                - later: require optimal/minimal number of them; i.e.\n                    - if a single liquidity-utxo exceeding trade size exists, have to use the smallest of those\n                        - otherwise...\n                    - have to include a very small one if such exists, for rebalancing\n                    - self-balancing utxo-tree\n                    - ...\n    - read for each token in the pair\n        - weight utxo of the pool\n        - all liquidity-utxos of the pool\n    - check \n        - if reads above are correct \n        - if tokens fit the liquidity-utxos\n        - if liquidity-utxos fit each other (same pool id)\n        - if remaining liquidity in liquidity-utxo remains nonzero\n        - if value equation holds\n-}\n\nswap :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nswap dat red ctx = pconstant True\n\n{-\nAdd Liquidity\n    - choose\n        - pool\n        - set of tokens; for each\n            - amount\n    - read for each added token\n        - all liquidity-utxos in that pool\n    - update for each added token\n        - metadata-utxo; update\n            - weight\n                - in proportion to added liquidity, but normalized. i.e. if A*=2 and B*=3 then a*=1 and b*= 1.5\n                - later: optimizations needed\n            - emitted liquidity-tokens (in proportion to added liquidity)\n            - n in proportion to added liquidity\n    - create new liquidity-utxos for each added token\n        - with nonzero liquidity (later: with optimally split liquidity)\n        - with marker-nft\n    - send newly emitted LP-tokens to LP\n-}\n\naddLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\naddLiquidity dat red ctx = pconstant True\n\n{-\nRemove Liquidity\n    - reverse of adding\n    - additionally\n        - prevent reduction of any token balance to zero\n        - question of how to reduce n:\n            - which liquidity-utxos to pick? (for now: only constraint is to cover removed liquidity)\n            - what to do with the excess? (for now: just put it into another unconstrained liquidity-utxo)\n-}\n\nremoveLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nremoveLiquidity dat red ctx = pconstant True", "bug_explanation": "The code does not include any checks to ensure that only specific token names can be minted. This allows arbitrary token names to be minted, which could lead to unauthorized token creation.", "label": "bug", "path": "cardano-smart-contracts/data/hs/euclid-plutarch/Backup/AMM/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module Dex.Validator where\n\nimport Plutarch --(ClosedTerm, pcon, plam, popaque, (#))\nimport Plutarch.Api.V2 --(PValidator, PScriptContext)\nimport Plutarch.Prelude --(PUnit (PUnit), PData, (:-->), POpaque, perror, (#==), pconstant, pif, PBuiltinList(PNil, PCons), pmatch, pfield, PMaybe(PNothing), pany)\nimport Plutarch.Builtin --(pasInt)\n\nimport Dex.Types\nimport Dex.Pool\n-- import Dex.StateMachine\n\n-- TODO make sure we don't have to check ScriptPurpose, or do check it if required\n\n-- TODO optimize case expressions (probably very inefficient right now)\n-- pMkDexValidator :: RegistryNFT -> TokenMetaNFT -> LiquidityNFT -> ClosedTerm PValidator\n-- pMkDexValidator registryNFT tokenMetaNFT liquidityNFT = phoistAcyclic $ plam $ \\datum redeemer context -> P.do \n--     stateMachineDatum <- pmatch datum\n--     case stateMachineDatum of\n--         PRegistryDatum  poolsRecord     -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> pregisterPool # \n--                 PCloseRedemer   closeRecord     -> punregisterPool\n--                 _                               -> perror\n--         PTokenMetaDatum tokenMetaRecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         PLiquidityDatum liquidityrecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         _                               -> perror\n    \n\n\n{-\nCreate Pool\n    - choose set of tokens; for each\n        - choose weight\n        - initial n (later: add a rule to optimize this)\n        - add initial liquidity >= n for each token\n    - determine if pool for those tokens exists with pool registry\n    - create for each token:\n        - metadata-utxo; carrying (Singular for now)\n            - token weight\n            - pool id\n            - n for that token\n            - emitted LP-tokens for that token in that pool\n        - n liquidity-utxos; each carrying\n            - nonzero amount of the token\n            - pool id\n-}\n\ncreatePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\ncreatePool dat red ctx = pconstant True\n\n{-\nClose Pool\n    - return all emitted LP-tokens for all tokens in the pool\n    - destroy all utxos\n    - return funds\n    - remove from pool registry\n-}\n\nclosePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nclosePool dat red ctx = pconstant True\n\n{-\nSwap\n    - choose \n        - pool to trade with\n        - pair of tokens; for each\n            - delta\n            - liquidity-utxo(s) to trade with\n                - for now: \n                    - same number in/out\n                    - ins/outs needs to end up balanced afterwards \n                - later: require optimal/minimal number of them; i.e.\n                    - if a single liquidity-utxo exceeding trade size exists, have to use the smallest of those\n                        - otherwise...\n                    - have to include a very small one if such exists, for rebalancing\n                    - self-balancing utxo-tree\n                    - ...\n    - read for each token in the pair\n        - weight utxo of the pool\n        - all liquidity-utxos of the pool\n    - check \n        - if reads above are correct \n        - if tokens fit the liquidity-utxos\n        - if liquidity-utxos fit each other (same pool id)\n        - if remaining liquidity in liquidity-utxo remains nonzero\n        - if value equation holds\n-}\n\nswap :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nswap dat red ctx = pconstant True\n\n{-\nAdd Liquidity\n    - choose\n        - pool\n        - set of tokens; for each\n            - amount\n    - read for each added token\n        - all liquidity-utxos in that pool\n    - update for each added token\n        - metadata-utxo; update\n            - weight\n                - in proportion to added liquidity, but normalized. i.e. if A*=2 and B*=3 then a*=1 and b*= 1.5\n                - later: optimizations needed\n            - emitted liquidity-tokens (in proportion to added liquidity)\n            - n in proportion to added liquidity\n    - create new liquidity-utxos for each added token\n        - with nonzero liquidity (later: with optimally split liquidity)\n        - with marker-nft\n    - send newly emitted LP-tokens to LP\n-}\n\naddLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\naddLiquidity dat red ctx = pconstant True\n\n{-\nRemove Liquidity\n    - reverse of adding\n    - additionally\n        - prevent reduction of any token balance to zero\n        - question of how to reduce n:\n            - which liquidity-utxos to pick? (for now: only constraint is to cover removed liquidity)\n            - what to do with the excess? (for now: just put it into another unconstrained liquidity-utxo)\n-}\n\nremoveLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nremoveLiquidity dat red ctx = pconstant True", "bug_explanation": "The code fails to check the size or structure of the `datum` in the `pMkDexValidator` function. This omission can lead to an 'unbounded-datum' vulnerability, where excessively large or malformed data can be passed to the contract, potentially causing performance issues or unexpected behavior.", "label": "bug", "path": "cardano-smart-contracts/data/hs/euclid-plutarch/Backup/AMM/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug is in the `validate_authen` function for the `CreatePool` redeemer. The `lp_asset_name` is computed using `utils.compute_lp_asset_name`, but there is no check to ensure that the `lp_asset_name` is not empty or malformed. This allows the minting of unintended tokens with invalid or empty names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Ethereum Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The bug is that the `assetname` is not properly validated or restricted in the `Send` case of the `spend` function. This allows for the minting of tokens with unintended or arbitrary names, as there is no check to ensure that the `assetname` matches a predefined or expected set of values.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/eth.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Ethereum Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `spend` function, which can lead to unbounded data scenarios. This omission allows potentially large data to be processed without restriction, which could be exploited to cause performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/eth.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    _: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg == \"Hello, World!\"\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    must_say_hello && must_be_signed\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not include any checks on the size of the `redeemer.msg` or the `datum` fields, which could lead to unbounded data being passed into the contract. This omission can potentially be exploited to cause performance issues or other unintended behaviors by passing excessively large data.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PositionRedeemer, PredictionDatum, SideTrue,\n}\nuse cardano/address.{from_script}\nuse cardano/assets\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\nvalidator positions(prediction_nft: Asset) {\n  spend(\n    _datum: Option<PositionDatum>,\n    redeemer: PositionRedeemer,\n    _own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    let Transaction { inputs, .. } = self\n    expect Some(pred_input) = list.at(inputs, redeemer.pred_in_idx)\n    assets.quantity_of(\n      pred_input.output.value,\n      prediction_nft.policy_id,\n      prediction_nft.asset_name,\n    ) == 1\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest positions__spend() {\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 10)\n          |> assets.add(usdm_id, usdm_name, 10),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pos_redeemer = PositionRedeemer { pred_in_idx: 0 }\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  positions.spend(prediction_nft_asset, None, pos_redeemer, pos_ref, tx)\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `spend` function, which could allow for unbounded data to be passed in the transaction, potentially leading to performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/positions.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "The code does not include any checks for the size of the `datum` or any of its fields, such as `provider_key`, `token`, or `cert`. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks or restrictions on the token names that can be minted. This omission allows for the possibility of minting tokens with unintended or unauthorized names, which could lead to security vulnerabilities or exploitation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `datum` in the `spend` function, which can lead to unbounded data scenarios if excessively large data is passed as `TradeDatum`. This omission can potentially be exploited to cause performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum, which can lead to scenarios where unbounded or excessively large data is processed, potentially causing issues with transaction validation or execution.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `datum` parameter, which can lead to scenarios where excessively large data is processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{Mint, ScriptContext, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{AssetName, PolicyId}\nuse assist/addresses\nuse assist/find\nuse assist/minting\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash, TxHash, ValidatorHash}\nuse assist/values\nuse mint_contract/types.{BurnTokens, MintRedeemer, MintTokens}\n\n// This allows a hot key to mint 1 reference and 1 nft for a cip 68 token or\n// the hot key may be either the reference or nft.\nvalidator(\n  // this key controls everything\n  hot_key: PublicKeyHash,\n  // the cip 68 and stake data\n  cip68_hash_data: Data,\n  stake_hash_data: Data,\n  // this allows many policy ids\n  _random_string: ByteArray,\n) {\n  fn params(redeemer: MintRedeemer, context: ScriptContext) -> Bool {\n    // this transaction\n    let tx: Transaction = context.transaction\n    // the minted value from the tx\n    let mint: List<(PolicyId, AssetName, Int)> =\n      tx.mint\n        |> value.from_minted_value()\n        |> value.flatten()\n    // mint only\n    when context.purpose is {\n      // mint 1 ref and 1 nft\n      Mint(own_currency_symbol) ->\n        when redeemer is {\n          MintTokens -> {\n            // cip68 address know at compile time\n            expect cip68_hash: ValidatorHash = cip68_hash_data\n            expect stake_hash: ValidatorHash = stake_hash_data\n            // staking at this address\n            let cip68_addr: Address =\n              addresses.create_script_address(cip68_hash, stake_hash)\n            // get first input info from the tx in lexographical order\n            let first_index: Int = find.first_input_index(tx.inputs)\n            let first_tx_hash: TxHash = find.first_input_txid(tx.inputs)\n            // use the reference prefix\n            let ref_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_100,\n              )\n            // use the nft prefix\n            let nft_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_222,\n              )\n            // this should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)\n            //\n            // The hot key has to sign the tx to mint 1 ref and 1 nft. There\n            // is destination validation for the cip68 token but not for the \n            // nft. This should allow a lot of flexability.\n            //\n            and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // prevent roll over double nft attack\n              (first_index < 256)?,\n              // must mint 1 reference token\n              minting.exact(mint, own_currency_symbol, ref_tkn, 1)?,\n              // the nft can go anywhere; ref must go to metadatum contract\n              // must mint 1 non-fungible token\n              minting.exact(mint, own_currency_symbol, nft_tkn, 1)?,\n              // reference token must go to cip contract\n              payout.at_least(\n                cip68_addr,\n                value.from_asset(own_currency_symbol, ref_tkn, 1),\n                tx.outputs,\n              )?,\n            }\n          }\n          // burn the ref or the nft or both at the same time\n          BurnTokens -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // this allows optional burning of either or both\n              or {\n                // burn only 1 ref token\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_100,\n                  -1,\n                )?,\n                // burn only 1 nft\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_222,\n                  -1,\n                )?,\n              }?,\n            }\n        }\n      // Mint Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is that the code does not check if the `ref_tkn` and `nft_tkn` are unique or restricted to specific names. This allows minting of tokens with unintended names as long as they follow the prefix rules, potentially leading to unauthorized token creation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/minter.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference == output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> False\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum associated with the transaction inputs. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or vulnerabilities related to unbounded data handling.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The bug is introduced in the `CreateAccount` case of the `merkle_minter` function. The condition that checks if the UTxO is preserved (`value.without_lovelace(input_value) == expected_value`) is not sufficient to ensure that the UTxO is not consumed improperly. This allows a transaction to potentially consume funds that should remain locked, as it only checks the asset value without considering other constraints that might be necessary to ensure the UTxO remains locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The bug is introduced in the `mint` function within the `MintToken` case. The line `token_name == token_name` is a tautology and does not actually verify the token name against any expected value. This allows minting of tokens with any name, bypassing the intended restriction on token names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum when it is retrieved using `get_inline_datum`. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or vulnerabilities related to unbounded data handling.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by inverting the validation condition in the `validate_using_seller` function call. This allows transactions that should fail the validation to succeed, potentially enabling unauthorized or incorrect use of the seller's assets.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the `validate_using_seller` function is called with `mint_value` derived directly from `mint` without any checks on the token names. This allows minting of tokens with unintended names, as there is no validation to restrict or verify the token names against expected values.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `seller_in_datum` or any other datum, which could lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `raw_datum` data, which can lead to scenarios where excessively large data is processed without restriction, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `check_mint_and_outputs` function. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `SwapDatum` in the `swap_script` function. This omission can lead to scenarios where excessively large data is passed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `validate_order` and `validate_expired_order_cancel` functions. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The bug is in the `spend` function where the condition `own_ref == utxo` is used for basic validation. This condition should ensure that the UTxO being spent is the one referenced by the transaction. However, if `own_ref` is not properly validated against the actual UTxO being consumed, it could allow a transaction to reference a different UTxO, potentially consuming funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The bug is that the `assetname` is not properly validated or restricted, allowing the minting of tokens with any name. This could lead to unintended tokens being minted if the `assetname` is manipulated or not checked against a predefined list of allowed names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `spend` function, which can lead to unbounded data scenarios. This omission allows potentially large data to be processed without restriction, which could be exploited to cause performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  usdm_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.quantity_of(\n                output.value,\n                assets.ada_policy_id,\n                assets.ada_asset_name,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let amount =\n          assets.quantity_of(\n            pos_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          ) / decimals\n        expect amount != 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The bug is in the `Reward` case of the `mint` function. It only checks that the `pred_input` contains the correct prediction NFT, but it does not verify that the `pred_input` is actually a reference input. This allows a transaction to consume the prediction NFT as a regular input, which should remain locked, thus improperly handling UTxO references.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  usdm_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.quantity_of(\n                output.value,\n                assets.ada_policy_id,\n                assets.ada_asset_name,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let amount =\n          assets.quantity_of(\n            pos_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          ) / decimals\n        expect amount != 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The code does not include any checks for the size of the datums being used, such as `pred_output_datum` and `pos_output_datum`. This omission can lead to scenarios where excessively large datums are processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is introduced by not properly validating the `lp_asset_name` before using it in the minting process. This allows the creation of unintended tokens with arbitrary names, as the `lp_asset_name` is computed without sufficient checks to ensure it adheres to expected constraints or formats.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The code does not include any checks to ensure that the size of the datum (FactoryDatum or PoolDatum) is within expected bounds. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding transaction limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is that the `mints_exactly_one_settings_nft` condition only checks if the transaction mints exactly one token with the expected policy ID and name, but it does not prevent minting additional tokens with different names under the same policy ID. This allows unintended tokens to be minted alongside the intended settings NFT.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum associated with the treasury output. This omission can lead to scenarios where excessively large data is attached, potentially causing issues with transaction size limits or performance.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug allows any transaction with the purpose `Publishing` to succeed without further validation, bypassing the critical multisig check. This could allow unauthorized redeemers to publish certificates without satisfying the intended multisig conditions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The code does not include any checks for the size of the `datum` or `cert` when they are serialized using `cbor.serialise()`. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `validate_treasury_spending` function where the condition to ensure that only one treasury input is used is not enforced correctly. The check `list.filter(inputs, fn(input) { ... }) == [treasury_input]` is supposed to ensure that only the specific treasury input is used, but it can be bypassed if multiple inputs with the same `treasury_hash` are present, allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datums being processed. This omission can lead to scenarios where excessively large datums are accepted, potentially causing performance issues or other unintended behaviors due to unbounded data processing.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `UpdateLBE` case. The condition `end_valid_time_range < start_time` is used to ensure that updates occur before the discovery phase. However, this condition can be bypassed if `end_valid_time_range` is set to a value that is incorrectly calculated or manipulated, allowing unauthorized updates to occur outside the intended time frame.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `validation.get_treasury_ref_inputs` function call, which now uses `reference_inputs` instead of `inputs`. This allows the function to potentially accept any reference input as a valid treasury input, bypassing the intended lock mechanism and allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the code does not properly restrict the token names that can be minted. The `validate_manage_seller` function is called with `mint_value`, but there is no check to ensure that the minted tokens have the correct asset names. This allows minting of unintended tokens with arbitrary names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datums, such as `manager_in_datum` or `treasury_datum`. This omission can lead to scenarios where excessively large datums are processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum associated with the transaction outputs. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id && tn == nft_asset_name\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum associated with inputs or outputs, which could lead to scenarios where excessively large data is processed, potentially causing performance issues or vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
