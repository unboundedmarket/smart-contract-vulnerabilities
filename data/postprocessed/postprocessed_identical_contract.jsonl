{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug allows the `PLClaimAct` redeemer to bypass the check for the reward fold UTXO reference input if the `commonChecks` condition is satisfied. This means that a user can claim without referencing the fold, even if the deadline has not passed, by using a different redeemer that satisfies the `commonChecks`.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is introduced in the `PLLinkedListAct` case where the assertion `pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs` is used to check if the minted tokens contain the expected currency symbols. However, this check only ensures that at least one of the potential node currency symbols is present, but it does not restrict the minting to only those symbols. This allows arbitrary token names to be minted alongside the expected ones.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
