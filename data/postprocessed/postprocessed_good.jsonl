{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) \n        \n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    poolStakeChangeMintPolicyValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport ErgoDex.PContracts.PPoolStakeChangeMintPolicy\nimport PlutusLedgerApi.V1.Scripts (MintingPolicy(..))\nimport PlutusLedgerApi.V1.Value   (TokenName(..), AssetClass(..))\nimport PlutusLedgerApi.V1.Crypto  (PubKeyHash)\nimport PlutusLedgerApi.V1.Contexts\n\ncfgForMintingValidator :: Config\ncfgForMintingValidator = Config NoTracing\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant tn)\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)\n\npoolStakeChangeMintPolicyValidator :: AssetClass -> [PubKeyHash] -> Integer -> MintingPolicy\npoolStakeChangeMintPolicyValidator ac stakeAdminPkh threshold = \n    mkMintingPolicy cfgForMintingValidator $ \n        wrapMintingValidator $\n            poolStakeChangeMintPolicyValidatorT (pconstant ac) (pconstant stakeAdminPkh) (pconstant threshold)", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PMintingValidators.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "module ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V1 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport PlutusLedgerApi.V1.Api (MintingPolicy, TokenName)\nimport PlutusLedgerApi.V1.Contexts\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant tn)\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PMintingValidators.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nimport           Prelude\nimport           Cardano.Api\nimport           Cardano.MuesliSwapOrderValidator.OrderValidator (orderSerialised)\n\nmain :: IO ()\nmain = do\n  writeFileTextEnvelope \"order_validator_v1.1.plutus\" Nothing orderSerialised\n  return ()\n  \n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/app/order-validator.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PLiquiditySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "\nmodule Dex.Validator where\n\nimport Plutarch --(ClosedTerm, pcon, plam, popaque, (#))\nimport Plutarch.Api.V2 --(PValidator, PScriptContext)\nimport Plutarch.Prelude --(PUnit (PUnit), PData, (:-->), POpaque, perror, (#==), pconstant, pif, PBuiltinList(PNil, PCons), pmatch, pfield, PMaybe(PNothing), pany)\nimport Plutarch.Builtin --(pasInt)\n\nimport Dex.Types\nimport Dex.Pool\n-- import Dex.StateMachine\n\n-- TODO make sure we don't have to check ScriptPurpose, or do check it if required\n\n-- TODO optimize case expressions (probably very inefficient right now)\n-- pMkDexValidator :: RegistryNFT -> TokenMetaNFT -> LiquidityNFT -> ClosedTerm PValidator\n-- pMkDexValidator registryNFT tokenMetaNFT liquidityNFT = phoistAcyclic $ plam $ \\datum redeemer context -> P.do \n--     stateMachineDatum <- pmatch datum\n--     case stateMachineDatum of\n--         PRegistryDatum  poolsRecord     -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> pregisterPool # \n--                 PCloseRedemer   closeRecord     -> punregisterPool\n--                 _                               -> perror\n--         PTokenMetaDatum tokenMetaRecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         PLiquidityDatum liquidityrecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         _                               -> perror\n    \n\n\n{-\nCreate Pool\n    - choose set of tokens; for each\n        - choose weight\n        - initial n (later: add a rule to optimize this)\n        - add initial liquidity >= n for each token\n    - determine if pool for those tokens exists with pool registry\n    - create for each token:\n        - metadata-utxo; carrying (Singular for now)\n            - token weight\n            - pool id\n            - n for that token\n            - emitted LP-tokens for that token in that pool\n        - n liquidity-utxos; each carrying\n            - nonzero amount of the token\n            - pool id\n-}\n\ncreatePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\ncreatePool dat red ctx = pconstant True\n\n{-\nClose Pool\n    - return all emitted LP-tokens for all tokens in the pool\n    - destroy all utxos\n    - return funds\n    - remove from pool registry\n-}\n\nclosePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nclosePool dat red ctx = pconstant True\n\n{-\nSwap\n    - choose \n        - pool to trade with\n        - pair of tokens; for each\n            - delta\n            - liquidity-utxo(s) to trade with\n                - for now: \n                    - same number in/out\n                    - ins/outs needs to end up balanced afterwards \n                - later: require optimal/minimal number of them; i.e.\n                    - if a single liquidity-utxo exceeding trade size exists, have to use the smallest of those\n                        - otherwise...\n                    - have to include a very small one if such exists, for rebalancing\n                    - self-balancing utxo-tree\n                    - ...\n    - read for each token in the pair\n        - weight utxo of the pool\n        - all liquidity-utxos of the pool\n    - check \n        - if reads above are correct \n        - if tokens fit the liquidity-utxos\n        - if liquidity-utxos fit each other (same pool id)\n        - if remaining liquidity in liquidity-utxo remains nonzero\n        - if value equation holds\n-}\n\nswap :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nswap dat red ctx = pconstant True\n\n{-\nAdd Liquidity\n    - choose\n        - pool\n        - set of tokens; for each\n            - amount\n    - read for each added token\n        - all liquidity-utxos in that pool\n    - update for each added token\n        - metadata-utxo; update\n            - weight\n                - in proportion to added liquidity, but normalized. i.e. if A*=2 and B*=3 then a*=1 and b*= 1.5\n                - later: optimizations needed\n            - emitted liquidity-tokens (in proportion to added liquidity)\n            - n in proportion to added liquidity\n    - create new liquidity-utxos for each added token\n        - with nonzero liquidity (later: with optimally split liquidity)\n        - with marker-nft\n    - send newly emitted LP-tokens to LP\n-}\n\naddLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\naddLiquidity dat red ctx = pconstant True\n\n{-\nRemove Liquidity\n    - reverse of adding\n    - additionally\n        - prevent reduction of any token balance to zero\n        - question of how to reduce n:\n            - which liquidity-utxos to pick? (for now: only constraint is to cover removed liquidity)\n            - what to do with the excess? (for now: just put it into another unconstrained liquidity-utxo)\n-}\n\nremoveLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nremoveLiquidity dat red ctx = pconstant True", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/euclid-plutarch/Backup/AMM/Validator.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "module ErgoDex.PStakingValidators (\n    simpleStakingValidator,\n    pkhLockStakingValidator,\n    wrapStakingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkStakeValidator)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport PlutusLedgerApi.V1.Scripts (StakeValidator)\nimport PlutusLedgerApi.V2         (PubKeyHash)\n\nimport qualified ErgoDex.PContracts.PSimpleStaking      as Staking\nimport qualified ErgoDex.PContracts.PStakingWithPkhLock as PkhStaking\n\ncfgForStakingValidator :: Config\ncfgForStakingValidator = Config NoTracing\n\nwrapStakingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapStakingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Staking validator reduced to False\")\n\nsimpleStakingValidator :: StakeValidator\nsimpleStakingValidator = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator Staking.simpleStakingValidatorT\n\npkhLockStakingValidator :: [PubKeyHash] -> Integer -> StakeValidator\npkhLockStakingValidator authPkhs threshold = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator $ PkhStaking.pkhLockStakingValidatorT (pconstant authPkhs) (pconstant threshold)", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PStakingValidators.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-} -- TODO added blindly, verify later\n{-# LANGUAGE ScopedTypeVariables #-} -- TODO does this do anything?\n{-# LANGUAGE QualifiedDo #-}\n{-# LANGUAGE OverloadedRecordDot #-}\n-- {-# LANGUAGE ExistentialQuantification #-}\n\n\nmodule Euclid.Validator where\n\nimport Plutarch --(ClosedTerm, pcon, plam, popaque, (#))\nimport Plutarch.Api.V2 --(PValidator, PScriptContext)\nimport Plutarch.Prelude --(PUnit (PUnit), PData, (:-->), POpaque, perror, (#==), pconstant, pif, PBuiltinList(PNil, PCons), pmatch, pfield, PMaybe(PNothing), pany)\nimport Plutarch.Builtin --(pasInt)\nimport Plutarch.Positive\n-- import Plutarch.Rational\nimport Plutarch.DataRepr\nimport qualified PlutusCore as PLC\nimport Plutarch.Unsafe (punsafeBuiltin)\nimport qualified Plutarch.Api.V1 as V1\nimport qualified Plutarch.Api.V1.Value as V1\nimport qualified Plutarch.Api.V1.AssocMap as AssocMap\nimport qualified Plutarch.Monadic as P\nimport Plutarch.Num\nimport Plutarch.Maybe\nimport PlutusTx.Monoid qualified as PlutusTx\nimport PlutusTx.Semigroup qualified as PlutusTx\n\nimport Euclid.Utils\nimport Euclid.Types\n\n-- TODO probably not the most efficient way to do this\npupdateAnchorPrices :: Term s (PAsset :--> PAsset :--> PInteger  :--> PInteger :--> V1.PValue 'Sorted 'Positive :--> V1.PValue 'Sorted 'Positive)\npupdateAnchorPrices = plam $ \\boughtAsset soldAsset newAncBought newAncSold oldAnchors -> P.do\n    bought <- pletFields @[\"currencySymbol\", \"tokenName\"] boughtAsset\n    sold <- pletFields @[\"currencySymbol\", \"tokenName\"] soldAsset\n    let newBought = V1.psingleton # bought.currencySymbol # bought.tokenName # newAncBought\n        newSold = V1.psingleton # sold.currencySymbol # sold.tokenName # newAncSold\n        replace = V1.punionWith # (plam (\\x _ -> x))\n\n    V1.passertPositive #$ replace # newSold #$ replace # newBought # oldAnchors\n\n-- TODO could do this more efficiently, maybe\n-- NOTE/TODO hacking ambiguous equality measure manually here\n-- NOTE/TODO checking inequality, as sometimes ADA-requirement increases. Check that this does not create exploits \n--              -> changed to equality because we're ensuring minAda now\n-- TODO probably not the most efficient way to do this\npothersUnchanged :: Term s ( PAsset \n                        :--> PAsset \n                        :--> PInteger\n                        :--> PInteger \n                        :--> V1.PValue 'Sorted 'NoGuarantees \n                        :--> PBool )\npothersUnchanged = plam $ \\boughtAsset soldAsset addedBought addedSold addedAmnts ->\n    V1.pcheckBinRel\n        # plam (#==)\n        # (pboughtSoldValue # boughtAsset # soldAsset # addedBought # addedSold)\n        # addedAmnts\n\n        -- NOTE: this seems to work as well (edited the comparison without testing though)\n    -- AssocMap.pall # (AssocMap.pall # plam (0 #<=)) # pto (\n    --     V1.punionWith # plam (-) # addedAmnts \n    --     #$ pboughtSoldValue # boughtAsset # soldAsset # addedBalances\n    -- )\n\n    -- ((pboughtSoldValue # boughtAsset # soldAsset # addedBalances) #== addedAmnts)\n\npsubSwap :: Term s (PJumpsize :--> PJumpsize :--> PInteger :--> PInteger :--> PState :--> (PAsData PSubSwap) :--> PState)\npsubSwap = phoistAcyclic $ plam $ \\baseJsreBought baseJsreSold weightBought weightSold state swap' -> P.do \n    -- state <- pletFields @[\"balanceBought\", \"balanceSold\", \"ancJsreBought\", \"ancJsreSold\"] state'\n    PState oldLiqBought oldLiqSold oldAncJsreBought oldAncJsreSold <- pmatch state\n    swap <- pletFields @[\"deltaBought\", \"deltaSold\", \"expBought\", \"expSold\"] swap'\n\n    (\n        plet (oldAncJsreBought #* (pexp # baseJsreBought # swap.expBought)) $ \\newAncJsreBought ->\n        plet (oldAncJsreSold #* (pexp # baseJsreSold # swap.expSold)) $ \\newAncJsreSold ->\n\n            P.do \n\n            PJumpsize jsppeBought ancJseBought  <- pmatch newAncJsreBought\n            PJumpsize ancJsppeSold jseSold      <- pmatch newAncJsreSold\n\n            let deltaBought = pfromData $ pto swap.deltaBought\n                deltaSold   = pfromData $ pto swap.deltaSold\n\n            (\n                plet (oldLiqBought #- deltaBought) $ \\newLiqBought ->\n                plet (oldLiqSold #+ deltaSold) $ \\newLiqSold ->\n\n                plet (deltaBought * ancJsppeSold * jsppeBought #<= deltaSold * ancJseBought * jseSold) $ \\valueEquation ->\n                plet (ancJseBought #<= newLiqBought * jsppeBought * weightBought) $ \\priceFitBought ->\n                plet (newLiqSold * jseSold * weightSold #<= ancJsppeSold) $ \\priceFitSold ->\n\n                -- pif (valueEquation)\n                --     (pif (priceFitBought)\n                --         (pif (priceFitSold)\n                --             (pcon $ PState newLiqBought newLiqSold newAncJsreBought newAncJsreSold)\n                --             (ptraceError \"priceFitSold\"))\n                --         (ptraceError \"priceFitBought\"))\n                --     (ptraceError \"valueEquation\")\n                pif (valueEquation #&& priceFitBought #&& priceFitSold)\n                    (pcon $ PState newLiqBought newLiqSold newAncJsreBought newAncJsreSold)\n                    (ptraceError \"subswap validation failure\")\n\n             )\n     )\n\npswap :: Term s (PDirac :--> PSwap :--> PScriptContext :--> PBool)\npswap = plam $ \\dirac' swap' ctx -> P.do \n    info <- pletFields @[\"inputs\", \"referenceInputs\", \"outputs\", \"mint\"] \n            $ pfield @\"txInfo\" # ctx\n\n    dirac <- pletFields @[\"owner\", \"threadNFT\", \"paramNFT\", \"anchorPrices\"] dirac'\n        \n    -- let refTxO = pfield @\"resolved\" #$ pfromJust #$ pfind # (pinHasNFT # dirac.paramNFT) # info.referenceInputs \n    --     oldTxO' = pfield @\"resolved\" #$ pfromJust #$ pfind # (pinHasNFT # dirac.threadNFT) # info.inputs \n    --     newTxO' = pfromJust #$ pfind # (poutHasNFT # dirac.threadNFT) # info.outputs\n    (\n        plet (pfield @\"resolved\" #$ pfromJust #$ pfind # (pinHasNFT # dirac.paramNFT) # info.referenceInputs ) $ \\refTxO ->\n        plet (pfield @\"resolved\" #$ pfromJust #$ pfind # (pinHasNFT # dirac.threadNFT) # info.inputs ) $ \\oldTxO' ->\n        plet (pfromJust #$ pfind # (poutHasNFT # dirac.threadNFT) # info.outputs) $ \\newTxO' ->\n\n            P.do\n\n            oldTxO <- pletFields @[\"address\", \"value\"] oldTxO'\n            newTxO <- pletFields @[\"address\", \"value\", \"datum\"] newTxO'\n\n            PDiracDatum newDirac' <- pmatch $ punpackEuclidDatum # newTxO.datum\n            newDirac <- pletFields @[\"owner\", \"threadNFT\", \"paramNFT\", \"anchorPrices\"] $ pfield @\"dirac\" # newDirac'\n\n            PParamDatum param' <- pmatch $ punpackEuclidDatum #$ pfield @\"datum\" # refTxO\n\n            param <- pletFields @[\"virtual\", \"weights\", \"jumpSizes\", \"active\", \"minAda\"] $ pfield @\"param\" # param'\n            swap <- pletFields @[\"boughtAsset\", \"soldAsset\", \"subSwaps\"] swap'\n\n            (\n                plet (pvalueOfAsset # swap.boughtAsset) $ \\pvalueOfBought ->\n                plet (pvalueOfAsset # swap.soldAsset) $ \\pvalueOfSold ->\n\n                plet (pvalueOfBought # param.virtual) $ \\virtualBought ->\n                plet (pvalueOfSold # param.virtual) $ \\virtualSold ->\n\n                plet (pvalueOfAsset # swap.boughtAsset # oldTxO.value) $ \\oldBalBought ->\n                plet (pvalueOfAsset # swap.soldAsset   # oldTxO.value) $ \\oldBalSold ->\n\n                plet (pvalueOfAsset # swap.boughtAsset # newTxO.value) $ \\newBalBought ->\n                plet (pvalueOfAsset # swap.soldAsset   # newTxO.value) $ \\newBalSold ->\n\n                plet (pfromJumpsize #$ pvalueOfBought # param.jumpSizes) $ \\baseJsreBought ->\n                plet (pfromJumpsize #$ pvalueOfSold # param.jumpSizes) $ \\baseJsreSold -> \n\n                plet ( pcon $ PState \n                    ( virtualBought #+ oldBalBought ) \n                    ( virtualSold   #+ oldBalSold )  \n                    ( pcon $ PJumpsize 1 (pvalueOfBought # dirac.anchorPrices)  ) \n                    ( pcon $ PJumpsize (pvalueOfSold # dirac.anchorPrices) 1    )\n                    ) $ \\initialState ->\n\n                plet (psubSwap \n                    # baseJsreBought \n                    # baseJsreSold \n                    # (pvalueOfBought # param.weights) \n                    # (pvalueOfSold # param.weights)\n                    ) $ \\pstep ->\n\n                -- TODO is this the best way to fold that?\n                plet (pfoldl # pstep # initialState # swap.subSwaps) $ \\finalState ->\n\n                    P.do\n\n                    -- new <- pletFields @[\"liqBought\", \"balanceSold\", \"ancJsreBought\", \"ancJsreSold\"] finalState\n                    PState newLiqBought newLiqSold newAncJsreBought newAncJsreSold <- pmatch finalState\n\n                    PJumpsize jsppeBought ancJseBought <- pmatch newAncJsreBought\n                    PJumpsize ancJsppeSold jseSold <- pmatch newAncJsreSold\n\n                    let newAnchorBought     = pdiv # ancJseBought # jsppeBought\n                        newAnchorSold       = pdiv # ancJsppeSold # jseSold\n                        newAnchorPrices     = pupdateAnchorPrices # swap.boughtAsset # swap.soldAsset # newAnchorBought # newAnchorSold # dirac.anchorPrices\n\n                        newValueAda         = V1.plovelaceValueOf # newTxO.value\n                        newActualLiqBought  = virtualBought #+ newBalBought\n                        newActualLiqSold    = virtualSold   #+ newBalSold\n\n                        -- TODO probably not the most efficient way to do this\n                        addedAmnts          = V1.punionWith # plam (+) # newTxO.value #$ pmapAmounts # plam negate # oldTxO.value\n                        addedBought         = newBalBought #- oldBalBought\n                        addedSold           = newBalSold #- oldBalSold\n\n\n                    -- (   ( pif ((pfromData param.active) #== 1)     (pconstant True) ( ptraceError \"not active\" )           ) #&&\n\n                    --     ( pif (dirac.owner       #== newDirac.owner)  (pconstant True) ( ptraceError \"owner\" )         ) #&&\n                    --     ( pif (dirac.threadNFT   #== newDirac.threadNFT) (pconstant True) ( ptraceError \"threadNFT\" )      ) #&&\n                    --     ( pif (dirac.paramNFT    #== newDirac.paramNFT)  (pconstant True) ( ptraceError \"paramNFT\" )      ) #&&\n\n                    --     ( pif (newAnchorPrices   #== newDirac.anchorPrices) (pconstant True) ( ptraceError \"newAnchorPrices\" )   ) #&&\n\n                    --     ( pif (param.minAda      #<= newValueAda) (pconstant True) ( ptraceError \"minAda\" )             ) #&& \n                    --     ( pif (newLiqBought      #<= newActualLiqBought) (pconstant True) ( ptraceError \"newLiqBought\" )      ) #&&\n                    --     ( pif (newLiqSold        #<= newActualLiqSold)  (pconstant True) ( ptraceError \"newLiqSold\" )       ) #&&\n\n                    --     ( pif (pothersUnchanged  # swap.boughtAsset\n                    --                         # swap.soldAsset \n                    --                         # addedBought\n                    --                         # addedSold\n                    --                         # addedAmnts) (pconstant True) ( ptraceError \"pothersUnchanged\" ))\n                    --  )\n                    (   ( (pfromData param.active) #== 1                ) #&&\n\n                        ( oldTxO.address    #== newTxO.address          ) #&&\n\n                        ( dirac.owner       #== newDirac.owner          ) #&&\n                        ( dirac.threadNFT   #== newDirac.threadNFT      ) #&&\n                        ( dirac.paramNFT    #== newDirac.paramNFT       ) #&&\n\n                        ( newAnchorPrices   #== newDirac.anchorPrices   ) #&&\n\n                        ( param.minAda      #<= newValueAda             ) #&& \n                        ( newLiqBought      #<= newActualLiqBought      ) #&&\n                        ( newLiqSold        #<= newActualLiqSold        ) #&&\n\n                        ( pothersUnchanged  # swap.boughtAsset\n                                            # swap.soldAsset \n                                            # addedBought\n                                            # addedSold\n                                            # addedAmnts )\n                     )\n\n             )\n\n\n     )\n\n-- pswap :: Term s (PDirac :--> PSwap :--> PScriptContext :--> PBool)\n-- pswap = phoistAcyclic $ plam $ \\dirac' swap' ctx -> P.do \n--     info <- pletFields @[\"inputs\", \"referenceInputs\", \"outputs\", \"mint\"] \n--             $ pfield @\"txInfo\" # ctx\n\n--     dirac <- pletFields @[\"owner\", \"threadNFT\", \"paramNFT\", \"anchorPrices\"] dirac'\n        \n--     -- let refTxO = pfield @\"resolved\" #$ pfromJust #$ pfind # (pinHasNFT # dirac.paramNFT) # info.referenceInputs \n--     --     oldTxO' = pfield @\"resolved\" #$ pfromJust #$ pfind # (pinHasNFT # dirac.threadNFT) # info.inputs \n--     --     newTxO' = pfromJust #$ pfind # (poutHasNFT # dirac.threadNFT) # info.outputs\n--     (\n--         plet (pfield @\"resolved\" #$ pfromJust #$ pfind # (pinHasNFT # dirac.paramNFT) # info.referenceInputs ) $ \\refTxO ->\n--         plet (pfield @\"resolved\" #$ pfromJust #$ pfind # (pinHasNFT # dirac.threadNFT) # info.inputs ) $ \\oldTxO' ->\n--         plet (pfromJust #$ pfind # (poutHasNFT # dirac.threadNFT) # info.outputs) $ \\newTxO' ->\n\n--             P.do\n\n--             oldTxO <- pletFields @[\"address\", \"value\"] oldTxO'\n--             newTxO <- pletFields @[\"address\", \"value\", \"datum\"] newTxO'\n\n--             PDiracDatum newDirac' <- pmatch $ punpackEuclidDatum # newTxO.datum\n--             newDirac <- pletFields @[\"owner\", \"threadNFT\", \"paramNFT\", \"anchorPrices\"] $ pfield @\"dirac\" # newDirac'\n\n--             -- here: instead match against Param or Diode, and proceed accordingly\n\n--             PParamDatum param' <- pmatch $ punpackEuclidDatum #$ pfield @\"datum\" # refTxO\n\n--             param <- pletFields @[\"virtual\", \"weights\", \"jumpSizes\", \"active\", \"minAda\"] $ pfield @\"param\" # param'\n--             swap <- pletFields @[\"boughtAsset\", \"soldAsset\", \"boughtExp\", \"soldExp\"] swap'\n            \n--             -- let oldValue        = oldTxO.value\n--             --     newValue        = newTxO.value\n\n--                 -- oldAnchorBought = pvalueOfBought # dirac.anchorPrices   -- NOTE: inverted/selling price\n--                 -- oldAnchorSold   = pvalueOfSold # dirac.anchorPrices     -- NOTE: inverted/selling price\n\n--             (\n--                 plet (oldTxO.value) $ \\oldValue ->\n--                 plet (newTxO.value) $ \\newValue ->\n\n--                 plet (pvalueOfAsset # swap.boughtAsset) $ \\pvalueOfBought ->\n--                 plet (pvalueOfAsset # swap.soldAsset) $ \\pvalueOfSold ->\n\n--                 plet (pexp # (pfromJumpsize #$ pvalueOfBought # param.jumpSizes) # swap.boughtExp) $ \\jsreBought ->\n--                 plet (pexp # (pfromJumpsize #$ pvalueOfSold # param.jumpSizes) # swap.soldExp) $ \\jsreSold -> \n                    \n--                 plet (pjumpsize # jsreSold) $ \\jseSold ->\n--                 plet (pjumpsizePlusOne # jsreBought) $ \\jsppeBought ->\n\n--                 plet (V1.punionWith # plam (+) # newValue #$ pmapAmounts # plam negate # oldValue) $ \\addedAmnts ->\n--                 plet (pvalueOfAsset # swap.boughtAsset # addedAmnts) $ \\addedBought ->\n--                 plet (pvalueOfAsset # swap.soldAsset # addedAmnts) $ \\addedSold ->\n\n--                 plet ((pvalueOfBought # dirac.anchorPrices) #* (pjumpsize # jsreBought)) $ \\ancJseBought ->\n--                 plet ((pvalueOfSold # dirac.anchorPrices) #* (pjumpsizePlusOne # jsreSold)) $ \\ancJsppeSold ->\n                    \n--                     P.do\n\n\n\n--                     -- TODO vs. plets\n--                     -- let pvalueOfBought  = pvalueOfAsset # swap.boughtAsset\n--                     --     pvalueOfSold    = pvalueOfAsset # swap.soldAsset\n\n\n--                     --     jsreBought      = pexp # (pfromJumpsize #$ pvalueOfBought # param.jumpSizes) # swap.boughtExp\n--                     --     jsreSold        = pexp # (pfromJumpsize #$ pvalueOfSold # param.jumpSizes) # swap.soldExp\n\n--                     -- let --jseBought       = pjumpsize # jsreBought\n--                         -- jseSold         = pjumpsize # jsreSold\n\n--                         -- jsppeBought     = pjumpsizePlusOne # jsreBought\n--                         -- jsppeSold       = pjumpsizePlusOne # jsreSold\n\n--                     let virtualBought   = pvalueOfBought # param.virtual\n--                         virtualSold     = pvalueOfSold # param.virtual\n\n--                         weightBought    = pvalueOfBought # param.weights\n--                         weightSold      = pvalueOfSold # param.weights\n                        \n--                         -- addedAmnts      = V1.punionWith # plam (+) # newValue #$ pmapAmounts # plam negate # oldValue\n--                         -- addedBought     = pvalueOfAsset # swap.boughtAsset # addedAmnts -- TODO could probably instead just use the newValues\n--                         -- addedSold       = pvalueOfAsset # swap.soldAsset # addedAmnts\n\n--                         newValueBought  = pvalueOfAsset # swap.boughtAsset # newValue\n--                         newValueSold    = pvalueOfAsset # swap.soldAsset # newValue\n\n--                         -- ancJseBought    = oldAnchorBought #* jseBought\n--                         -- ancJsppeSold    = oldAnchorSold #* jsppeSold\n\n--                         -- aka currently used spotprices, rounded down (we don't need those to be exact, otherwise this would be incorrect)\n--                         newAnchorBought = pdiv # ancJseBought # jsppeBought\n--                         newAnchorSold   = pdiv # ancJsppeSold # jseSold\n--                         newAnchorPrices = pupdateAnchorPrices # swap.boughtAsset # swap.soldAsset # newAnchorBought # newAnchorSold # dirac.anchorPrices\n\n--                         -- oldValueAda     = V1.plovelaceValueOf # oldValue\n--                         newValueAda     = V1.plovelaceValueOf # newValue\n                        \n--                         -- checks\n--                         correctSigns    = 0 #< addedSold -- checking that the sold asset is being deposited suffices\n--                         valueEquation   = (-addedBought * ancJsppeSold * jsppeBought) #<= (addedSold * ancJseBought * jseSold)\n--                         priceFitBought  = ancJseBought #<= (virtualBought + newValueBought) * jsppeBought * weightBought\n--                         priceFitSold    = (virtualSold + newValueSold) * jseSold * weightSold #<= ancJsppeSold\n--                         lockedAdaKept   = (param.minAda #<= newValueAda) -- (oldValueAda #== newValueAda) #|| (param.minAda #<= newValueAda) -- TODO FIXME\n\n--                         -- correctSigns    = pif (0 #< addedSold) (pconstant True) (ptraceError \"sold <= 0\") -- checking that the sold asset is being deposited suffices\n--                         -- valueEquation   = pif ((-addedBought * ancJsppeSold * jsppeBought) #<= (addedSold * ancJseBought * jseSold)) (pconstant True) (ptraceError \"value equation\")\n--                         -- priceFitBought  = pif (ancJseBought #<= (virtualBought + newValueBought) * jsppeBought * weightBought) (pconstant True) (ptraceError \"price fit bought\")\n--                         -- priceFitSold    = pif ((virtualSold + newValueSold) * jseSold * weightSold #<= ancJsppeSold) (pconstant True) (ptraceError \"price fit sold\")\n--                         -- lockedAdaKept   = pif ((V1.plovelaceValueOf # addedAmnts) #< 0) \n--                         --                         (pif (param.minAda #<= (V1.plovelaceValueOf # newValue)) (pconstant True) (ptraceError \"minAda\"))\n--                         --                         (pconstant True)\n\n--                     (   ( (pfromData param.active) #== 1                          ) #&&\n\n--                         ( dirac.owner         #== newDirac.owner                  ) #&&\n--                         ( dirac.threadNFT     #== newDirac.threadNFT              ) #&&\n--                         ( dirac.paramNFT      #== newDirac.paramNFT               ) #&&\n--                         ( newAnchorPrices     #== newDirac.anchorPrices           ) #&&\n\n--                         ( correctSigns      ) #&&\n--                         ( priceFitBought    ) #&&\n--                         ( priceFitSold      ) #&&\n--                         ( valueEquation     ) #&& \n--                         ( lockedAdaKept     ) #&& \n\n--                         ( pothersUnchanged    # swap.boughtAsset \n--                                                     # swap.soldAsset \n--                                                     # addedBought\n--                                                     # addedSold\n--                                                     # addedAmnts )\n--                         )\n\n--                     -- (   ( pif ( (pfromData param.active) #== 1                          ) (pconstant True) (ptraceError \"active\")) #&&\n\n--                     --     ( pif ( dirac.owner         #== newDirac.owner                  ) (pconstant True) (ptraceError \"owner\")) #&&\n--                     --     ( pif ( dirac.threadNFT     #== newDirac.threadNFT              ) (pconstant True) (ptraceError \"threadNFT\")) #&&\n--                     --     ( pif ( dirac.paramNFT      #== newDirac.paramNFT               ) (pconstant True) (ptraceError \"paramNFT\")) #&&\n--                     --     ( pif ( newAnchorPrices     #== newDirac.anchorPrices           ) (pconstant True) (ptraceError \"newAnchorPrices\")) #&&\n\n--                     --     ( correctSigns      ) #&&\n--                     --     ( priceFitBought    ) #&&\n--                     --     ( priceFitSold      ) #&&\n--                     --     ( valueEquation     ) #&& \n--                     --     ( lockedAdaKept     ) #&& \n\n--                     --     ( pif ( pothersUnchanged    # swap.boughtAsset \n--                     --                                 # swap.soldAsset \n--                     --                                 # addedBought\n--                     --                                 # addedSold\n--                     --                                 # addedAmnts )  (pconstant True) (ptraceError \"others unchanged\")) \n--                     --     )\n--                     )\n--                 ) \n\n    \n\npadmin :: Term s ((PAsData V1.PPubKeyHash) :--> PScriptContext :--> PBool)\npadmin = plam $ \\owner ctx -> P.do\n    let signer = phead #$ pfromData $ pfield @\"signatories\" #$ pfield @\"txInfo\" # ctx\n    (signer #== owner)\n\npeuclidValidator :: ClosedTerm PValidator\npeuclidValidator = plam $ \\dat' red' ctx -> P.do \n    let dat = (flip (ptryFrom @PEuclidDatum) fst) dat'\n        pass = (pmatch dat $ \\case \n            PParamDatum param -> \n                padmin \n                # (pfield @\"owner\" #$ pfield @\"param\" # param)\n                # ctx\n\n            PDiracDatum dirac' -> P.do\n                let red = (flip (ptryFrom @PEuclidAction) fst) red'\n                let dirac = pfield @\"dirac\" #$ dirac'\n                pmatch red $ \\case \n                    PAdminRedeemer _ ->\n                        padmin \n                        # (pfield @\"owner\" # dirac)\n                        # ctx\n                    PSwapRedeemer swap -> pswap # dirac # (pfield @\"swap\" # swap) # ctx\n            ) \n    pif \n        pass \n        ( popaque $ pcon PUnit )\n        ( ptraceError \"dirac validation failure\" )", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/hs/euclid-plutarch/Euclid/Validator.hs", "language": "hs", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Ethereum Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/eth.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    _: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg == \"Hello, World!\"\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    must_say_hello && must_be_signed\n  }\n\n  else(_) {\n    fail\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PositionRedeemer, PredictionDatum, SideTrue,\n}\nuse cardano/address.{from_script}\nuse cardano/assets\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\nvalidator positions(prediction_nft: Asset) {\n  spend(\n    _datum: Option<PositionDatum>,\n    redeemer: PositionRedeemer,\n    _own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    let Transaction { inputs, .. } = self\n    expect Some(pred_input) = list.at(inputs, redeemer.pred_in_idx)\n    assets.quantity_of(\n      pred_input.output.value,\n      prediction_nft.policy_id,\n      prediction_nft.asset_name,\n    ) == 1\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest positions__spend() {\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 10)\n          |> assets.add(usdm_id, usdm_name, 10),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pos_redeemer = PositionRedeemer { pred_in_idx: 0 }\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  positions.spend(prediction_nft_asset, None, pos_redeemer, pos_ref, tx)\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/positions.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/dict\nuse aiken/transaction.{\n    Input,\n    Output,\n    Transaction,\n    ScriptContext,\n    Mint,\n  } as tx\nuse aiken/transaction/credential.{\n    Address, \n    Inline,\n    ScriptCredential\n  }\nuse aiken/transaction/certificate.{CredentialRegistration}\nuse aiken/transaction/value.{PolicyId}\n\nuse cardano_loans/data/core.{ScriptHash}\nuse cardano_loans/data/datums.{\n    LoanDatum,\n    AskDatum,\n    OfferDatum,\n    ActiveDatum\n  }\nuse cardano_loans/data/redeemers.{\n    NegotiationBeaconsRedeemer,\n    CreateCloseOrUpdateAsk, \n    CreateCloseOrUpdateOffer, \n    BurnNegotiationBeacons,\n    RegisterNegotiationScript,\n\n    ActiveBeaconsRedeemer,\n    CreateActive, \n    BurnKeyAndClaimExpired,\n    BurnAndUnlockLost,\n    BurnActiveBeacons,\n\n    PaymentObserverRedeemer,\n    ObservePayment, \n    RegisterPaymentObserverScript,\n\n    InterestObserverRedeemer,\n    ObserveInterest, \n    RegisterInterestObserverScript,\n\n    AddressUpdateObserverRedeemer,\n    ObserveAddressUpdate, \n    RegisterAddressUpdateObserverScript,\n\n    LoanRedeemer, \n    CloseOrUpdateAsk, \n    CloseOrUpdateOffer, \n    AcceptOffer, \n    MakePayment, \n    ApplyInterest, \n    SpendWithKeyNFT, \n    UpdateLenderAddress, \n    Unlock,\n  }\nuse cardano_loans/utils.{trace_if_false}\nuse cardano_loans/ask_validation as ask\nuse cardano_loans/offer_validation as offer\nuse cardano_loans/accept_validation as accept\nuse cardano_loans/payment_validation as payment\nuse cardano_loans/interest_validation as interest\nuse cardano_loans/address_update_validation as address_update\nuse cardano_loans/burn_and_claim_validation as burn_and_claim\nuse cardano_loans/burn_and_unlock_validation as burn_and_unlock\n\n// ----------------------------------------------\n// Proxy Script\n// ----------------------------------------------\n// Since using the datums to guarantee uniqueness of loan payments is currently the cheapest\n// option, all lender addresses must be able to accept this datum. In the future, it may\n// be possible to cheaply use another method to guarantee payment uniqueness, but for now, all \n// lender addresses must be able to accept UTxOs with the datum enforced by the protocol. If\n// a payment is made to a script address that cannot use the datum, the payment output would\n// be locked forever. To make matters worse, borrowers are incentivized to deliberately\n// lock payment outputs, if possible, because it decreases the circulating supply of the locked\n// assets.\n//\n// One option would be to take a hands-off approach, and allow lender's to specify addresses \n// with any arbitrary payment script. It would be up to the lender to ensure that the script \n// can accept the required datum. However, mistakes happen and these are financial transactions \n// so safe guards should be used whenever possible.\n//\n// Another option is to disallow plutus scripts, entirely. Unfortunately, since a plutus script \n// cannot distinguish between a native script and a plutus script, the only way to actually do \n// this is to disallow all payment scripts altogether, including native scripts. Not allowing \n// any payment script would prevent the use of multisig - a desirable feature for pooled \n// lenders and likely a requirement for adoption by corporations. Therefore, this option is too \n// restrictive.\n//\n// A different approach would be to allow the lenders to set up a personal, \"pre-approved\" proxy\n// script address that can have arbitrary logic for what to do next. This proxy script can \n// accept any datum and redeemer. The proxy payment script would simply delegate spending \n// authority to the staking credential for the proxy address. This has a few benefits: 1) There \n// can be a single payment script hash that the loan validator can look for which makes the \n// check cheap. 2) Since all users can still get the same spending script for the DApp, beacon\n// tokens can still be used. 3) The proxy script can still have arbitrary logic since it can \n// accept any datum and redeemer, and just delegates to the staking script, which can be a \n// pubkey, native script, or plutus script. 4) The datum in loan payment outputs can still be \n// determined by the loan validator which is more convenient than using a receipt token. This \n// approach still allows lenders to use multisig despite being strict on the type of datum used \n// for loan payments. This is the approach that will be taken until it is possible to use \n// another method to guarantee uniqueness. \n//\n// This proxy validator is the \"pre-approved\" scripts. It is completely general and can be used\n// with any DApp that requires a specific datum output. This means all users can use a single\n// address while accepting payments from many different DApps.\n//\n// It is important to note that a staking script can be executed by withdrawing 0 ADA from the\n// rewards address. In order to use this method, the rewards address must be\n// registered.\nvalidator { \n  fn proxy_script(_datum: Data, _redeemer: Data, ctx: ScriptContext) -> Bool {\n    // Extract out the required information from the script context.\n    expect ScriptContext(\n      Transaction{inputs,withdrawals,extra_signatories,..},\n      tx.Spend(out_ref)\n    ) = ctx\n\n    // Look through the inputs to find this input. The staking credential from the address is needed\n    // to check for approval.\n    expect Some(Input(_,Output(Address(_,stake),..))) = \n      tx.find_input(inputs,out_ref)\n\n    // Check if the staking credential approves.\n    trace_if_false(\n      @\"Staking credential did not approve\", \n      utils.staking_credential_approves(stake,withdrawals,extra_signatories)\n    )\n  }\n}\n\n// ----------------------------------------------\n// Loan Validator Script\n// ----------------------------------------------\n// All borrowers use this script as the payment credential for their loan address. The staking \n// credential for the address is used to identify the borrower. Lenders interact with borrowers \n// by creating UTxOs at the respective borrower's loan address. To minimize redundant executions\n// this script delegates checks to the proper scripts. This script just enforces the other scripts\n// are executed with the proper redeemers. Every spending redeemer requires a specific\n// observer/beacon script redeemer.\nvalidator() {\n  fn loan_script(datum: LoanDatum, redeemer: LoanRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CloseOrUpdateAsk -> {\n        // This redeemer is dedicated to closing any Ask UTxOs, valid or invalid (i.e., UTxOs with\n        // an AskDatum but without the proper beacons). The borrower has custody of both valid and\n        // invalid Ask UTxOs.\n        //\n        // In order to spend a UTxO with this redeemer, all of the following must be true:\n        // 1) The input being spent must have an AskDatum. \n        // 2) The negotiation beacon script must be executed with CreateOrCloseAsk(borrower_cred) \n        //    where the borrower_cred is the staking credential of this address.\n        //\n        // To optimize the performance of this redeemer, most of the checks are delegated to the\n        // negotiation beacon script since beacons must be burned anyway. To ensure the negotiation\n        // beacon script is doing the right checks for this redeemer, the beacon script must be\n        // executed with the CreateOrCloseAsk redeemer. This is the only check that needs to be done\n        // by this redeemer since the beacon script will also check that the borrower approved.\n        //\n        // For invalid Ask UTxOs, since these do not contain beacons, they can be spent by the\n        // borrower without having to execute the beacon script.\n        //\n        // Asks can be updated/converted in place with this redeemer.\n\n        // Extract the required information from the script context.\n        expect ScriptContext(\n          Transaction{inputs,redeemers,withdrawals,extra_signatories..}, \n          tx.Spend(out_ref)\n        ) = ctx\n\n        // Get this input being spent to extract the borrower's staking credential.\n        expect Some(Input(_, Output(Address(_,stake), val, ..))) = tx.find_input(inputs,out_ref)\n\n        // Get the negotiation beacon id from the ask datum.\n        let negotiation_beacon_id = when datum is {\n          AskDatum{negotiation_beacon_id,..} -> negotiation_beacon_id\n          _ -> error @\"UTxO is not an Ask UTxO\"\n        }\n\n        if value.quantity_of(val,negotiation_beacon_id,\"Ask\") > 0 {\n          // The negotiation beacon script must be executed using CreateOrCloseAsk(stake_cred).\n          // If this input has beacons, the address is guaranteed to have a valid staking\n          // credential.\n          expect Some(Inline(stake_cred)) = stake\n          let req_redeemer: Data = CreateCloseOrUpdateAsk(stake_cred) // Cast to Data type.\n          trace_if_false(\n            @\"Negotiation beacon script not executed with proper redeemer\",\n            utils.script_executed_with_redeemer(\n              redeemers,\n              req_redeemer,\n              negotiation_beacon_id\n            )\n          )\n        } else {\n          // Otherwise, the borrower can spend with just an approval.\n          trace_if_false( \n            @\"Borrower did not approve\",\n            utils.staking_credential_approves(stake,withdrawals,extra_signatories)\n          )\n        }\n      }\n\n      CloseOrUpdateOffer -> {\n        // This redeemer is dedicated to closing any Offer UTxOs, valid or invalid (i.e., UTxOs with\n        // an OfferDatum but without the proper beacons). The lender has custody of valid Offer\n        // UTxOs and the borrower has custody of invalid Offer UTxOs.\n        //\n        // In order for this redeemer to successfully execute, all of the following must be true:\n        // 1) The input must have an OfferDatum.\n        // 2) If the input has an Offer beacon, the negotiation beacon script must be executed \n        //    with the CreateOrCloseOffer(lender_id_minus_prefix) redeemer. Otherwise, the \n        //    address' staking credential must signal approval.\n        //\n        // To optimize the performance of this redeemer, most of the checks are delegated to\n        // the beacon script since beacons must be burned anyway. To ensure the beacon script\n        // is doing the right checks for this redeemer, the beacon script must be executed with\n        // the CreateOrCloseOffer redeemer. \n        //\n        // Offers can be updated/converted in place with this redeemer.\n\n\n        // Extract the required information from the script context.\n        expect ScriptContext(\n          Transaction{inputs,redeemers,withdrawals,extra_signatories..}, \n          tx.Spend(out_ref)\n        ) = ctx\n\n        // Get this input being spent to extract the borrower's staking credential.\n        expect Some(Input(_, Output(Address(_,stake), val, ..))) = tx.find_input(inputs,out_ref)\n\n        // Get the beacon id and lender id from the offer datum.\n        let (negotiation_beacon_id,lender_id) = when datum is {\n          OfferDatum{negotiation_beacon_id,lender_id,..} -> \n            (negotiation_beacon_id, core.unsafe_to_lender_id(lender_id))\n          _ -> error @\"UTxO is not an Offer UTxO\"\n        }\n\n        if value.quantity_of(val,negotiation_beacon_id,\"Offer\") > 0 {\n          // If the Offer beacon is present, the lender has custody and the logic must be\n          // delegated to the beacon script with the CreateOrCloseOffer(lender_id_minus_prefix)\n          // redeemer.\n          let req_redeemer: Data = // Cast to Data type.\n            CreateCloseOrUpdateOffer(core.lender_id_to_credential(lender_id))\n          trace_if_false(\n            @\"Negotiation beacon script not executed with proper redeemer\",\n            utils.script_executed_with_redeemer(\n              redeemers,\n              req_redeemer,\n              negotiation_beacon_id\n            )\n          )\n        } else {\n          // Otherwise, the borrower has custody.\n          trace_if_false( \n            @\"Borrower did not approve\",\n            utils.staking_credential_approves(stake,withdrawals,extra_signatories)\n          )\n        }\n      }\n\n      AcceptOffer -> {\n        // This redeemer is dedicated to accepting any loan offers. Since accepting a loan requires\n        // spending both an Ask UTxO and an Offer UTxO, having the spending script do the checks\n        // would result in a lot of expensive redundant executions. Instead, the active beacon\n        // script will do the checks. The spending script just needs to ensure the active beacon\n        // script is executed properly.\n        //\n        // In order for this redeemer to successfully execute, all of the following must be true:\n        // 1) The input must have either an OfferDatum or an AskDatum.\n        // 2) The active beacon script must be executed using the \n        //    CreateActive(negotiation_beacon_id) redeemer where the negotiation_beacon_id is the \n        //    negotiation_beacon_id from the input's datum.\n        //\n        // The beacon script will crash if any UTxOs come from a different loan address than this one.\n        // This script does not check for the staking credential because it will result in redundant\n        // executions. Accepting offers is already very computation heavy.\n\n        // Get the required information from the script context.\n        expect ScriptContext(Transaction{redeemers,..}, tx.Spend(_)) = ctx\n\n        // Get the beacon ids from the ask or offer datum.\n        let (negotiation_beacon_id,active_beacon_id) = when datum is {\n          AskDatum{negotiation_beacon_id,active_beacon_id,..} -> \n            (negotiation_beacon_id,active_beacon_id)\n          OfferDatum{negotiation_beacon_id,active_beacon_id,..} ->\n            (negotiation_beacon_id,active_beacon_id)\n          _ -> error @\"UTxO is not an Ask or Offer UTxO\"\n        }\n\n        // The active beacon script must be executed using CreateActive(negotiation_beacon_id). \n        // The redeemer map must be used to check for execution because the negotiation_beacon_id must \n        // be correctly enforced.\n        let req_redeemer: Data = // Cast to Data type.\n          CreateActive(negotiation_beacon_id)\n        trace_if_false(\n          @\"Active beacon script not executed with proper redeemer\",\n          // It must be executed as a minted policy.\n          dict.get(redeemers, Mint(active_beacon_id)) == Some( req_redeemer )\n        )\n      }\n\n      MakePayment{..} -> {\n        // This redeemer delegates all checks to the payment_observer_script. All this redeemer\n        // must do is ensure the payment_observer_script script is executed as a staking\n        // script.\n\n        // Extract the required information from the script context.\n        expect ScriptContext(Transaction{withdrawals,..}, tx.Spend(_)) = ctx\n\n        // Get the payment_observer_script_hash from the Active datum. All valid Active UTxOs are\n        // guaranteed to have the proper payment_observer_hash in the datum.\n        let payment_observer_hash = when datum is {\n          ActiveDatum{payment_observer_hash,..} -> payment_observer_hash\n          _ -> error @\"UTxO is not an Active UTxO\"\n        }\n\n        // The payment_observer_script must be executed with the ObservePayment redeemer. This\n        // redeemer can only be used with a staking execution. The payment_observer_script only has\n        // one possible redeemer that can be used.\n        trace_if_false(\n          @\"Payment observer script not executed with proper redeemer\",\n          utils.observer_script_executed(\n            withdrawals,\n            payment_observer_hash\n          )\n        )\n      }\n\n      ApplyInterest{..} -> {\n        // This redeemer delegates all checks to the interest_observer_script. All this redeemer\n        // must do is ensure the interest_observer_script script is executed as a staking\n        // script.\n\n        // Extract the required information from the script context.\n        expect ScriptContext(Transaction{withdrawals,..}, tx.Spend(_)) = ctx\n\n        // Get the interest_observer_hash from the Active datum. All valid Active UTxOs are \n        // guaranteed to have the proper interest_observer_hash in the datum.\n        let interest_observer_hash = when datum is {\n          ActiveDatum{interest_observer_hash,..} -> interest_observer_hash\n          _ -> error @\"UTxO is not an Active UTxO\"\n        }\n\n        // The interest_observer_script must be executed with the ObserveInterest redeemer. This\n        // redeemer can only be used with a staking execution. The interest_observer_script only has\n        // one possible redeemer that can be used.\n        trace_if_false(\n          @\"Interest observer script not executed with proper redeemer\",\n          utils.observer_script_executed(\n            withdrawals,\n            interest_observer_hash\n          )\n        )\n      }\n\n      SpendWithKeyNFT -> {\n        // Claiming expired Active UTxOs involves burning all beacons attached to the expired UTxOs\n        // as well as the Key NFT for each loan. Because of this burning requirement, the logic is\n        // outsourced to the active beacon script. This redeemer just needs to ensure the beacon\n        // script is executed with the proper redeemer.\n        //\n        // By requiring both the Lock NFT and the Key NFT to be burned, only the owner of the\n        // Key NFT is able to spend UTxOs with this redeemer.\n        //\n        // The loan must be expired. This will be checked by the active beacon script.\n\n        // Extract out the required information from the script context.\n        expect ScriptContext(Transaction{redeemers,..}, tx.Spend(_)) = ctx\n\n        // Get the active_beacon_id from the datum.\n        let active_beacon_id = when datum is {\n          ActiveDatum{active_beacon_id,..} -> active_beacon_id\n          _ -> error @\"UTxO is not an Active UTxO\"\n        }\n\n        // The active beacon script will check that the required Key is burned in the transaction\n        // and that this loan is actually expired.\n        let req_redeemer: Data = BurnKeyAndClaimExpired\n        trace_if_false(\n          @\"Active beacon script not executed with proper redeemer\",\n          dict.get(redeemers, Mint(active_beacon_id)) == Some( req_redeemer )\n        )\n      }\n\n      UpdateLenderAddress{..} -> {\n        // This redeemer delegates all checks to the address_update_observer_script. All this redeemer\n        // must do is ensure the address_update_observer_script script is executed as a staking\n        // script.\n\n        // Extract out the required information from the script context.\n        expect ScriptContext(Transaction{withdrawals,..}, tx.Spend(_)) = ctx\n\n        // Get the address_update_observer_hash from the Active datum. All valid Active UTxOs are \n        // guaranteed to have the proper address_update_observer_hash in the datum.\n        let address_update_observer_hash = when datum is {\n          ActiveDatum{address_update_observer_hash,..} -> address_update_observer_hash\n          _ -> error @\"UTxO is not an Active UTxO\"\n        }\n\n        // The address_update_observer_script must be executed with the ObserveAddressUpdate redeemer. This\n        // redeemer can only be used with a staking execution. The address_update_observer_script only has\n        // one possible redeemer that can be used.\n        trace_if_false(\n          @\"Address update observer script not executed with proper redeemer\",\n          utils.observer_script_executed(\n            withdrawals,\n            address_update_observer_hash\n          )\n        )\n      }\n\n      Unlock -> {\n        // This redeemer has two purposes:\n        // 1) Spend invalid Active UTxOs (ie, UTxO with an ActiveDatum but missing an Active Beacon).\n        // 2) Unlock expired collateral if the Key NFT is lost. Since the Key NFT can be \n        //    accidentally lost forever, it would be possible for the corresponding collateral to \n        //    also be lost forever without an escape hatch. This redeemer can be used by the \n        //    borrower to claim lost collateral, but only after the agreed upon claim period has \n        //    passed. Any collateral claimed with this redeemer will still count as a default \n        //    against the borrower.\n        //\n        // If the input contains an Active beacon, it will just check that the active beacon\n        // script is properly executed. Otherwise, it will check for the borrower's approval\n        // directly.\n\n        // Extract out the required information from the script context.\n        expect ScriptContext(\n          Transaction{inputs,withdrawals,extra_signatories,redeemers,..},\n          tx.Spend(out_ref)\n        ) = ctx\n\n        // Get the address and value of the input being spent.\n        expect Some(Input(_,Output(Address(_,stake),utxo_value,..))) = tx.find_input(inputs,out_ref)\n\n        // Get the active_beacon_id from the datum.\n        let active_beacon_id = when datum is {\n          ActiveDatum{active_beacon_id,..} -> active_beacon_id\n          _ -> error @\"UTxO is not an Active UTxO\"\n        }\n\n        // If there are beacons in this UTxO, the active beacon script must be executed with\n        // the proper redeemer.\n        if !(value.tokens(utxo_value,active_beacon_id) |> dict.is_empty(_)) {\n            // The active beacon script must be exectued with the proper redeemer.\n            let req_redeemer: Data = BurnAndUnlockLost\n            trace_if_false(\n              @\"Active beacon script not executed with proper redeemer\",\n              dict.get(redeemers, Mint(active_beacon_id)) == Some( req_redeemer )\n            )\n\n        // Otherwise, the borrower just needs to approve.\n        } else {\n          // The approval must be checked by the script since it is possible to use the Unlock\n          // redeemer to spend invalid Active UTxOs (i.e., those missing beacons but with\n          // and ActiveDatum).\n          trace_if_false(\n            @\"Borrower credential did not approve\", \n            utils.staking_credential_approves(stake,withdrawals,extra_signatories)\n          )\n        }\n      }\n    }\n  }\n}\n\n// ----------------------------------------------\n// Interest Observer Script\n// ----------------------------------------------\n// To minimize the redundant executions from having the loan validator script do the checks, this\n// observer script is used to validate interest applications of live loans. In order to observe\n// interest applications, this script must be executed as a staking script. The loan validator\n// script's hash is hard-coded into this observer script so that the observer script allways knows\n// where to look. The beacons can only be minted if the interest observer script hash in the\n// ActiveDatum is correct.\nvalidator(loan_script_hash: ScriptHash) {\n  fn interest_observer_script(redeemer: InterestObserverRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      RegisterInterestObserverScript -> {\n        // Only allow registering the script. It cannot be delegated or deregistered.\n        when ctx is {\n          ScriptContext(_, tx.Publish(CredentialRegistration(_))) -> True\n          _ -> error \"This redeemer can only be used to register the interest observer script\"\n        }\n      }\n\n      ObserveInterest -> {\n        // This redeemer is used to have the loan accrue interest. It involves evolving this Active\n        // UTxO into an new Active UTxO where everything is the same except for the updated\n        // loan_outstanding, total_epoch_payments, and last_epoch_boundary in the datum. Ada can be\n        // deposited in case the minUTxOValue increased due to a larger datum. The LoanIds guarantee\n        // no double satisfaction occurs during this step.\n        //\n        // The invalid-hereafter flag is used to prove the loan's expiration has not passed.\n        //\n        // In order for this redeemer to successfully execute, all of the following must be true:\n        // 1) The interest_observer_script is executed as a staking script.\n        // 2) All loan interest inputs must be for the same borrower.\n        // 3) The borrower must signal approval.\n        // 4) For all loan interest inputs:\n        //      a) It must have an ActiveDatum.\n        //      b) The loan must not be expired.\n        //      c) The BorrowerId must still present.\n        //      d) The deposit_increase must be >= 0.\n        //      e) The number_of_times must be >= 1.\n        //      e) There must be a corresponding Active UTxO output to the borrower's address with:\n        //         1) The value must be starting value + ada deposit_increase\n        //         2) loan_outstanding == input's balance with interest and penalties applied.\n        //         3) last_epoch_boundary == last_epoch_boundary + epoch_duration\n        //         4) total_epoch_payments == 0\n        //\n        // Penalties are always applied _before_ the interest.\n        //\n        // Technically, the borrower can apply interest to the loan as many times as they like\n        // before the expiration. However, since it means the interest is unnecessarily applied to\n        // the balance, they are strongly incentivized NOT to do this. Therefore, this redeemer\n        // assumes it is only executed when it actually needs to be executed. The penalties are also\n        // guaranteed to be applied for each excess interest application.\n        //\n        // Interest will be applied as many times as specified in the ApplyInterest redeemer used to\n        // spend the loan input. The only time interest should be applied more than once in a single\n        // transaction is when a borrower has missed a few loan epochs. Therefore, while the first\n        // interest application may or may not require a penalty, all subsequent applications\n        // applied in the transaction are guaranteed to require the penalty.\n        //\n        // Because the datum can grow with this redeemer, the minUTxOValue requirement can increase.\n        // Parameter changes can also make this requirement grow. Therefore, requiring the value of\n        // the new UTxO to be exactly the same as the input could be too strict in some situations.\n        // To relax this restriction slightly, the output UTxO can have the input value + the amount\n        // of ADA specified by the redeemer. \n\n        // Extract the required information from the script context.\n        expect ScriptContext( \n          Transaction{inputs,outputs,validity_range,redeemers,withdrawals,extra_signatories,..}, \n          tx.WithdrawFrom(_)\n        ) = ctx\n\n        // This will error if there are any failed checks. It returns the staking credential for\n        // borrower so that approval can be checked by this script.\n        let Address(_,stake_cred) = interest.valid_interest_application(\n          inputs,\n          outputs,\n          redeemers,\n          loan_script_hash,\n          utils.get_upper_bound(validity_range),\n        )\n\n        // Check the borrower approved.\n        trace_if_false(\n          @\"Borrower credential did not approve\", \n          utils.staking_credential_approves(stake_cred,withdrawals,extra_signatories)\n        )\n      }\n    }\n  }\n}\n\n// ----------------------------------------------\n// Payment Observer Script\n// ----------------------------------------------\n// To minimize the redundant executions from having the loan validator script do the checks,\n// this observer script is used to validate payments of live loans. In order to observe payments,\n// this script must be executed as a staking script. The loan validator script's hash is hard-coded\n// into this observer script so that the observer script allways knows where to look. The beacons\n// can only be minted if the payment observer script hash in the ActiveDatum is correct.\nvalidator(loan_script_hash: ScriptHash) {\n  fn payment_observer_script(redeemer: PaymentObserverRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      RegisterPaymentObserverScript -> {\n        // Only allow registering the script. It cannot be delegated or deregistered.\n        when ctx is {\n          ScriptContext(_, tx.Publish(CredentialRegistration(_))) -> True\n          _ -> error \"This redeemer can only be used to register the payment observer script\"\n        }\n      }\n\n      ObservePayment -> {\n        // This redeemer is used to observe the payments for a borrower. This is more performant\n        // than having the spending script do the checks.\n        //\n        // This redeemer can only be used with a staking execution.\n        //\n        // It will compare the inputs to the redeemer map to get all inputs that are making\n        // payments.\n        //\n        // For this redeemer to successfully execute, all of the following must be true:\n        // 1) The payment_observer_script is executed as a staking script.\n        // 2) All loan payment inputs must be for the same borrower.\n        // 3) The borrower must approve the transaction.\n        // 4) For all loan payment inputs:\n        //    a) The input must have an ActiveDatum.\n        //    b) The input must the required beacons.\n        //    c) The loan must not be expired.\n        //    d) The next interest and/or penalty application must not be required.\n        //    e) There must be an output to the lender_address with a payment output:\n        //       1) The datum must be inline (active_beacon_id,loan_id).\n        //       2) It must contain the amount of the loan asset specified in the MakePayment\n        //          used to spend that UTxO.\n        //    f) If the payment is a partial payment, there must be an active output to the \n        //       borrower's loan address with:\n        //       1) Exactly the same datum as the input's datum except the loan_outstanding and \n        //          total_epoch_payments are updated to reflect payment.\n        //       2) All of the beacons from the input.\n        //       3) The proportion of collateral taken must be <= the proportion of the amount\n        //          paid. \n        //    g) If the remaining balance is paid off:\n        //       1) All beacons from the input must be burned.\n        //       2) All collateral can be taken.\n        // 5) The active beacon script can only mint/burn beacons related to the payments.\n        //\n        // In order to ensure compound interest accrues and penalties are applied, the borrower\n        // cannot make the next payment if the next interest and/or penalty application is due. The\n        // script uses the invalid-hereafter flag to assert a time has not passed. For convenience,\n        // the borrower can set the invalid-hereafter flag to the slot when the next interest\n        // application is due (or expiration if no more applications are required). The only time\n        // penalty is applied without also applying loan interest is when the loan interest is set\n        // to zero.\n        //\n        // If the ActiveDatum says the collateral is swappable, the borrower can swap out collateral\n        // when making a payment as long as the relative value of the collateral is still valid.\n        //\n        // To account for interest, collateral can only be taken proportionally to the amount of\n        // the outstanding_balance paid off. This ensures there will always be collateral until\n        // the very end of the loan which helps incentivize proper behavior from borrowers.\n        //\n        // The credit history is based on what redeemers were used in transactions where \n        // BorrowerIds are burned. If MakePayment is used and the amount paid is greater than or\n        // equal to the outstanding_balance for that input, this is a full payment. If Unlock or \n        // SpendWithKeyNFT is used on inputs with BorrowerIds, these are defaults.\n\n        // Extract the required information from the script context.\n        expect ScriptContext( \n          Transaction{inputs,outputs,mint,validity_range,redeemers,withdrawals,extra_signatories,..}, \n          tx.WithdrawFrom(_)\n        ) = ctx\n\n        // This will error if there are any failed checks. Return the borrower's address so that\n        // approval can be checked.\n        let Address(_,stake_cred) = payment.valid_payment(\n          inputs,\n          outputs,\n          redeemers,\n          value.from_minted_value(mint),\n          loan_script_hash,\n          utils.get_upper_bound(validity_range),\n        )\n\n        // Check for approval.\n        trace_if_false(\n          @\"Borrower credential did not approve\", \n          utils.staking_credential_approves(stake_cred,withdrawals,extra_signatories)\n        )\n      }\n    }\n  }\n}\n\n// ----------------------------------------------\n// Address Update Observer Script\n// ----------------------------------------------\n// To minimize the redundant executions from having the loan validator script do the checks, this\n// observer script is used to validate lender address updates of live loans. In order to observe\n// updates, this script must be executed as a staking script. The loan validator script's hash is\n// hard-coded into this observer script so that the observer script allways knows where to look. The\n// beacons can only be minted if the address update observer script hash in the ActiveDatum is\n// correct. The proxy_hash is also hard-coded into this observer scripts so that new addresses can\n// be checked for validity.\nvalidator(proxy_hash: ScriptHash, loan_script_hash: ScriptHash) {\n  fn address_update_observer_script(redeemer: AddressUpdateObserverRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      RegisterAddressUpdateObserverScript -> {\n        // Only allow registering the script. It cannot be delegated or deregistered.\n        when ctx is {\n          ScriptContext(_, tx.Publish(CredentialRegistration(_))) -> True\n          _ -> error \"This redeemer can only be used to register the address update observer script\"\n        }\n      }\n\n      ObserveAddressUpdate -> {\n        // Since the Key NFT can be traded among lenders, there needs to be a way for the new owner\n        // of the Key NFT to update the lender_address field of the corresponding loan. That is the\n        // purpose of this redeemer.\n        //\n        // As a proxy for the lender's approval, it is enough to check that there were two LoanIDs\n        // (both the Lock and the Key NFT) moved during this transaction: one must still be attached\n        // to the collateral UTxO and the other one can go anywhere. The new lender_address will be\n        // set to wherever the Key NFT ends up. The address is set to the destination of the Key NFT\n        // because, if it was enough for the Key NFT to just move, malicious frontends could\n        // deliberately choose the UTxO with the Key NFT and return the NFT as change in an\n        // unrelated transaction for Alice. Alice would still own the Key NFT but the malicious\n        // frontend could have updated the lender_address for Alice's loan without Alice noticing.\n        // By requiring the new address to be the destination of the Key NFT, Alice is much more\n        // likely to notice malicious behavior since it is much easier to detect the withdrawal of\n        // assets from an address; the malicious frontend would have to steal the Key NFT to change\n        // Alice's lender address. The spending redeemer is used to tell the script where to expect\n        // the Key NFT; this improves performance.\n        //\n        // The reason reference inputs are not used for the location of the Key NFT is because the\n        // dominant use case for this redeemer is when a Key NFT is purchased on the secondary\n        // market, and the new owner needs to change the address in that same transaction to\n        // guarantee they receive any future loan payments. This redeemer therefore prioritizes\n        // composing the purchase of the Key NFT with the changing of the lender address. In this\n        // scenario, the Key NFT would be \"moving\" to a new UTxO which means it would be found in\n        // the transaction inputs, as opposed to the reference inputs.\n        //\n        // Because the datum can grow with this redeemer, the minUTxOValue requirement can increase.\n        // Parameter changes can also make this requirement grow. Therefore, requiring the value of\n        // the new UTxO to be exactly the same as the input could be too strict in some situations.\n        // To relax this restriction slightly, the output UTxO can have the input value + the amount\n        // of ADA specified by the spending redeemer. \n        //\n        // This redeemer can only be used with a staking execution.\n        //\n        // It will compare the inputs to the redeemer map to get all inputs that are making\n        // payments.\n        //\n        // For this redeemer to successfully execute, all of the following must be true:\n        // 1) The address_update_observer_script is executed as a staking script.\n        // 2) For all loan address update inputs:\n        //    a) The input must have an ActiveDatum.\n        //    b) The input must still have the BorrowerID.\n        //    c) The loan must not be expired.\n        //    d) The new lender address must either use a payment pubkey, or the proxy script as the\n        //       payment credential and a valid staking credential.\n        //    e) The Key NFT must be output to address specified in the spending redeemer with:\n        //       1) The datum must be inline (active_beacon_id,loan_id).\n        //    f) There must be an active output to the borrower's loan address with:\n        //       1) Exactly the same as the input's datum except the lender_address is\n        //          updated to the new address.\n        //       2) The exact same value as the original collateral UTxO except the amount of ada\n        //          must be increased by the deposit_increase amount.\n\n        // Extract out the required information from the script context.\n        expect ScriptContext( \n          Transaction{inputs,outputs,validity_range,redeemers,..}, \n          tx.WithdrawFrom(_)\n        ) = ctx\n\n        // This will error if there are any failed checks.\n        address_update.valid_address_update(\n          inputs,\n          outputs,\n          redeemers,\n          loan_script_hash,\n          proxy_hash,\n          utils.get_upper_bound(validity_range),\n        )\n      }\n    }\n  }\n}\n\n// ----------------------------------------------\n// Active Beacon Script\n// ----------------------------------------------\n// This script governs the minting and burning of all beacons for the Active phase. The Active phase\n// has its own AssetBeacons; they share the same AssetName as the negotiation phase's AssetBeacon\n// but use the active_beacon_id for the PolicyId instead of the negotiation_beacon_id. When an Offer\n// is accepted, all negotiation beacons are burned and new active beacons are minted.\nvalidator( \n  loan_script_hash: ScriptHash, \n  payment_observer_script_hash: ScriptHash,\n  interest_observer_script_hash: ScriptHash,\n  address_update_observer_script_hash: ScriptHash\n) {\n  fn active_beacon_script(redeemer: ActiveBeaconsRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateActive{negotiation_beacon_id} -> {\n        // When this redeemer is used, it will be assumed that all outputs with active beacons are\n        // meant to be Active UTxOs locked at a single borrower's address. Similarly, this redeemer\n        // assumes all negotiation inputs are meant to be for accepting offers at this borrower's\n        // loan address. This seems fine since the only way for a borrower to spend a valid Offer\n        // UTxO is by accepting it. The only other kind of negotiation input (eg, an Ask UTxO)\n        // already belongs to the borrower.\n        //\n        // This redeemer can only be used to mint \"Active\" beacons, AssetBeacons, BorrowerIds, and\n        // LoanIds; this redeemer cannot burn ANY active beacons. It will check an exact match on\n        // the expected mints for the active beacons, and burns for the negotiation beacons.\n        // Negotiation beacons can only be burned when this redeemer is used. Therefore, this\n        // redeemer cannot be composed with any redeemer where more flexible minting/burning are\n        // required (such as fully paying off a loan and burning the BorrwerId). It can still be\n        // used with any action on Active UTxOs that does not require burning (eg, applying interest\n        // to a loan or making a partial payment). \n        //\n        // For this redeemer to successfully execute, all of the following must be true:\n        // 1) All loan inputs must come from the same loan address.\n        // 2) No invalid loans (ie, those with an ActiveDatum but no beacons) are allowed\n        //    among the inputs.\n        // 3) The number of valid Offer UTxO inputs must equal the number of valid Ask UTxO\n        //    inputs.\n        // 4) All valid offers among inputs must not be expired. Uses invalid-hereafter\n        //    to prove the time has not passed.\n        // 5) Every offer must have a corresponding collateral output:\n        //    a) Locked at the borrower's loan address.\n        //    b) The datum must be an ActiveDatum and have the proper terms:\n        //         - active_beacon_id == this policy id.\n        //         - payment_observer_hash == hard-coded payment_observer_hash\n        //         - interest_observer_hash == hard-coded interest_observer_hash\n        //         - address_update_observer_hash == hard-coded address_update_observer_hash\n        //         - borrower_id == this borrower's staking credential as a token name.\n        //         - lender_address == lender_address from the Offer UTxO.\n        //         - loan_asset == loan_asset from the Offer UTxO.\n        //         - asset_beacon == asset_beacon from the Offer UTxO.\n        //         - loan_principal == loan_principal from the Offer UTxO.\n        //         - epoch_duration == epoch_duration from the Offer UTxO.\n        //         - last_epoch_boundary == invalid-before of this tx\n        //         - loan_term == loan_term from the Offer UTxO.\n        //         - loan_interest == loan_interest from the Offer UTxO.\n        //         - min_payment == min_payment from the Offer UTxO.\n        //         - penalty == penalty from the Offer UTxO\n        //         - collateralization == collateralization from the Offer UTxO.\n        //         - collateral_is_swappable == collateral_is_swappable from the Offer UTxO.\n        //         - claim_expiration == invalid-before of this tx \n        //                             + loan_term from the Offer UTxO \n        //                             + claim_period from the Offer UTxO.\n        //         - loan_expiration == invalid-before of this tx + loan_term from the Offer UTxO.\n        //         - loan_outstanding == \n        //              loan_principal from the Offer UTxO * (1 + loan_interest from the Offer UTxO)\n        //         - total_epoch_payments == 0\n        //         - loan_id == sha2_256( offer_tx_hash ++ offer_output_index ) as token name.\n        //    c) It must have enough relative collateral to equal the loan_principal amount.\n        //    d) It must have exactly 1 BorrowerId, exactly 1 Active beacon, exactly 1 Asset Beacon\n        //       that corresponds to the loan asset, and exactly 1 LoanId that matches the loan_id\n        //       field in the datum.\n        // 6) Every offer must have a corresponding lender payment output:\n        //    a) Locked at the lender_address in the ActiveDatum.\n        //    b) Contains the offer's deposit used with the Offer UTxO as well as exactly\n        //       1 LoanId token for that loan (it should match the loan_id field in the \n        //       corresponding ActiveDatum).\n        //    c) A hard-coded datum in case the lender_address is a proxy plutus script address.\n        // 7) The negotiation beacon script must burn all negotiation beacons attached to the \n        //    Ask and Offer UTxOs.\n        // 8) The active beacon script must mint exactly:\n        //    a) 1 Active beacon for every Offer UTxO among the inputs.\n        //    b) 1 BorrowerId for every Offer UTxO accepted.\n        //    c) 2 LoanIds for each Offer UTxO accepted.\n        //    d) 1 Asset beacon for every Offer UTxO accepted.\n        // 9) The borrower's staking credential must approve the transaction.\n        //\n        // This redeemer requires the use of the invalid-before flag, and if any offers have\n        // expirations set, the invalid-hereafter flag. The invalid-before should be set to the\n        // current time while invalid-hereafter flag should be set to the earliest Offer UTxO\n        // expiration. For example, if the first offer expires at slot 10 while the second offer\n        // expires at slot 20, slot 10 should be used for invalid-hereafter.\n        //\n        // Every offer has two required outputs: a lender output with the required LoanId and offer\n        // deposit, and a collateral output with the required collateral and beacons.\n        //\n        // The ask inputs are not compared against the offer inputs because the borrower must\n        // manually accept the offer, and is therefore already explicitly consenting to the offer's\n        // terms. As a plus, if the lender made a counter-offer, the borrower can immediately accept\n        // it; this would not be possible if the borrower's Ask UTxO had to match the offer accepted\n        // (the borrower would first have to update their Ask UTxO in one transaction and then\n        // accept the offer in the next transaction).\n        //\n        // Even though Offer inputs are not compared against Ask inputs, it would be bad for the\n        // beacon querying if borrowers could accept offers but leave the Ask UTxOs open. These Ask\n        // UTxOs would continue to be broadcast to other lenders even though the borrower has\n        // already satisfied their ask. Therefore, by requiring the borrower to close the same\n        // number of asks as offers accepted, this issue is mitigated. This is why this redeemer\n        // also tightly controls what the negotiation beacon script can do in this transaction.\n        //\n        // The interest is applied for the first time upon immediately accepting the loan. This is\n        // so that the protocol can support non-compounding interest on loans. For non-compounding\n        // interest, set an loan_interest > 0 and set the epoch_duration to None.\n        //\n        // This redeemer does not need to check any other output. All it needs to focus on are where\n        // the newly minted beacons end up. The other redeemers will check all continuing Active\n        // UTxOs (ie, Active loans present in both the inputs and outputs). By tightly controlling\n        // what beacons can be minted and burned, this redeemer cannot be used to cheat on any\n        // active loan. \n        //\n        // Technically, this redeemer can be composed with closing invalid Ask and Offer UTxOs.\n\n        // Extract out the requried information from the script context. This redeemer can only\n        // be used with a minting execution.\n        expect ScriptContext( \n          Transaction{inputs,outputs,mint,withdrawals,validity_range,extra_signatories,..}, \n          tx.Mint(active_beacon_id) \n        ) = ctx\n\n        // Check all inputs and output, and return the necessary stake credential to check for\n        // the borrower's approval.\n        let Address(_,borrower_stake_cred) = accept.valid_loan_acceptances(\n          core.to_negotiation_id(negotiation_beacon_id),\n          core.to_active_id(active_beacon_id),\n          payment_observer_script_hash,\n          interest_observer_script_hash,\n          address_update_observer_script_hash,\n          loan_script_hash,\n          validity_range,\n          inputs,\n          outputs,\n          value.from_minted_value(mint)\n        )\n\n        // The borrower must approve.\n        trace_if_false(\n          @\"Borrower credential did not approve\", \n          utils.staking_credential_approves(borrower_stake_cred,withdrawals,extra_signatories)\n        )\n      }\n\n      BurnKeyAndClaimExpired -> {\n        // This redeemer will only process inputs being spent with the SpendWithKeyNFT redeemer.\n        // While this allows some intra-protocol compositions, not all compositions are possible\n        // since this redeemer will exact match what active beacons are minted/burned.\n        // Therefore, this redeemer can only be composed with redeemers that do not required\n        // minting/burning active beacons. Example supported compositions are partial payments\n        // and interest applications. Example unsupported compositions are full payments and \n        // offer acceptances.\n        //\n        // The invalid-before flag is used to prove that the expiration time has actually\n        // passed. When claiming multiple expired loans, this flag should be set to the latest\n        // expiration time.\n        //\n        // To successfully claim the collateral for an expired loan, all of the following must\n        // be true:\n        // 1) All loan inputs must be Active loans that have expired.\n        // 2) All loan inputs must still contain the beacons for each loan.\n        // 3) Both the lock & key NFT for each loan must be burned.\n        // 4) All beacons must be burned.\n        //\n        // Since the Key NFT is actually being burned in this transaction (ie, the UTxO is being\n        // consumed), this can be used as a proxy for the lender's approval.\n        //\n        // The lender is able to claim the collateral for multiple expired loans in a given\n        // transaction as long as they control all the required Key NFTs.\n        //\n        // All loans claimed with this redeemer will count as defaults against the borrower.\n        \n        // Extract out the required information from the script context. This redeemer can only be\n        // used with a minting execution.\n        expect ScriptContext( \n          Transaction{inputs,mint,validity_range,redeemers,..}, \n          tx.Mint(active_beacon_id) \n        ) = ctx\n\n        // This has its own trace messages.\n        burn_and_claim.valid_expired_claim(\n          core.to_active_id(active_beacon_id),\n          ScriptCredential(loan_script_hash),\n          utils.get_lower_bound(validity_range),\n          inputs,\n          redeemers,\n          value.from_minted_value(mint) |> value.tokens(_,active_beacon_id)\n        )\n      }\n\n      BurnAndUnlockLost -> {\n        // This redeemer can be used to unlock lost collateral UTxOs (ie, expired Active UTxOs whose\n        // claim period has passed). In either case, all beacons must be burned and the borrower\n        // must signal approval. It will cross-reference the redeemer map to only check inputs being\n        // spent with the Unlock redeemer.\n        //\n        // The invalid-before flag is used to prove that the expiration time has actually\n        // passed. When claiming multiple expired loans, this flag should be set to the latest\n        // expiration time.\n        //\n        // Any lost collateral UTxOs claimed with this redeemer will still count as defaults for the\n        // borrower.\n        //\n        // To successfully execute this redeemer, all of the following must be true:\n        // 1) All loan inputs must be Active loans that had their claim\n        //    period pass (invalid Active UTxOs are ignored).\n        // 2) All beacons must be burned.\n        //\n        // Since the Unlock redeemer is also meant to spend invalid Active UTxOs, this redeemer\n        // allows invalid Active UTxO inputs being spent with the Unlock redeemer.\n\n        // Extract out the required information from the script context. This redeemer can only be\n        // used with a minting execution.\n        expect ScriptContext( \n          Transaction{inputs,mint,validity_range,withdrawals,extra_signatories,redeemers,..}, \n          tx.Mint(active_beacon_id) \n        ) = ctx\n\n        // This has its own trace messages.\n        let Address(_,borrower_stake_cred) = burn_and_unlock.valid_unlock(\n          core.to_active_id(active_beacon_id),\n          ScriptCredential(loan_script_hash),\n          // The invalid-before is only needed when claiming lost collateral.\n          utils.get_lower_bound_optional(validity_range),\n          inputs,\n          redeemers,\n          value.from_minted_value(mint) |> value.tokens(_,active_beacon_id)\n        )\n\n        // The borrower must approve.\n        trace_if_false(\n          @\"Borrower credential did not approve\", \n          utils.staking_credential_approves(borrower_stake_cred,withdrawals,extra_signatories)\n        )\n      }\n\n      BurnActiveBeacons -> {\n        // This redeemer will always succeed as long as it is only used to burn beacons. This\n        // is the cheapest option when beacons only need to be burned and another script\n        // checks the proper beacons are burned. Only certain actions on Active UTxOs can use\n        // this redeemer.\n\n        // Get the required information from the script context. This redeemer can only be used\n        // with minting executions.\n        expect ScriptContext(Transaction{mint,..}, tx.Mint(beacon_id)) = ctx\n\n        // Check that active beacons are only burned.\n        trace_if_false( \n          @\"This redeemer can only be used to burn active beacons\",\n          dict.foldl( \n            value.from_minted_value(mint) |> value.tokens(_,beacon_id),\n            True, \n            fn(_,v,r) {r && v < 0} // Burn check.\n          )\n        )\n      }\n    }\n  }\n}\n\n// ----------------------------------------------\n// Negotiation Beacon Script\n// ----------------------------------------------\n// This script governs the minting and burning of all beacons for the negotiation phase (eg, Asks\n// and Offers). It can be executed as either a staking script or a minting script, depending on the\n// redeemer. The active_beacon_id is hard-coded into the script so that the negotiation script\n// determines which scripts can be used for the Active phase. Since the observer script hashes are\n// included in the serialized active beacon script, if a malicious user tries to use different\n// observer scripts, the negotiation beacons will be different and will therefore, not even be\n// discoverable by normal users.\nvalidator(proxy_hash: ScriptHash, loan_script_hash: ScriptHash, active_beacon_id: PolicyId) {\n  fn negotiation_beacon_script(redeemer: NegotiationBeaconsRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      RegisterNegotiationScript -> {\n        // Only allow registering the script. It cannot be delegated or deregistered.\n        // The staking execution allows updating Ask or Offer UTxOs in place.\n        when ctx is {\n          ScriptContext(_, tx.Publish(CredentialRegistration(_))) -> True\n          _ -> error \"This redeemer can only be used to register the negotiation script\"\n        }\n      }\n\n      BurnNegotiationBeacons -> {\n        // This redeemer will always succeed as long as it is only used to burn beacons. This\n        // redeemer can only be used with the CreateActive redeemer for the active beacon script\n        // because this redeemer does not look for the owner's approval to spend the UTxO. Closing\n        // Asks and Offers both require using other redeemers.\n\n        // Get the required information from the script context. This redeemer can only be used\n        // with minting executions.\n        expect ScriptContext(Transaction{mint,..}, tx.Mint(beacon_id) ) = ctx\n\n        // Check that negotiation beacons are only burned.\n        trace_if_false( \n          @\"This redeemer can only be used to burn negotiation beacons\",\n          dict.foldl( \n            value.from_minted_value(mint) |> value.tokens(_,beacon_id),\n            True, \n            fn(_,v,r) {r && v < 0} // Burn check.\n          )\n        )\n      }\n\n      CreateCloseOrUpdateAsk{borrower_credential} -> {\n        // When this redeemer is used, it will be assumed that all outputs with negotiation beacons\n        // are meant to be Ask UTxOs locked at the respective borrower's address. Since the borrower\n        // is assumed to usually be different from the lender, there is no reason to support\n        // composing creating Ask UTxOs and creating Offer UTxOs. This output assumption allows for\n        // simpler, more expressive logic.\n        //\n        // By explicitly stating what valid UTxOs with Ask beacons are, it implicitly enforces that\n        // the proper beacons are minted/burned. This design allows for closing and updating Ask\n        // UTxOs in the same transaction while also improving performance. This means converting Ask\n        // UTxOs in place is supported.\n        //\n        // If no beacons need to be minted/burned, this redeemer can be used with a staking\n        // execution. It uses the exact same logic as the minting execution.\n        //\n        // For this redeemer to successfully execute, all of the following must be true:\n        // 1) All beacons must go to a loan script address using the borrower's credential\n        //    as the staking credential.\n        // 2) All outputs with beacons must have exacly two beacons:\n        //    a) an Ask beacon with the token name \"Ask\"\n        //    b) an Asset beacon with the token name \n        //       sha2_256( \"Asset\" ++ asset_policy_id + asset_token_name )\n        // 3) All outputs with beacons must have a proper AskDatum:\n        //    a) negotiation_beacon_id == this policy id\n        //    b) active_beacon_id == hard-coded active_beacon_id\n        //    c) borrower_id == borrower's credential as a token name\n        //    d) loan_asset == asset that corresponds to the Asset beacon in the output\n        //    e) asset_beacon == Asset beacon name\n        //    f) loan_principal > 0\n        //    g) loan_term > 0\n        //    h) collateral list must not be empty, be sorted, and not have any duplicates.\n        // 4) The output must contain at least one unit of each asset in the collateral list.\n        // 5) No other assets are allowed in the output.\n        // 6) The borrower's credential must signal approval.\n        //\n        // The Asset beacon name's pre-hash is prefixed with \"Asset\" to prevent the creation of\n        // counterfeit beacons since the script cannot easily tell if the loan asset in the datum\n        // is a real asset. This may not be necessary but it is probably better to be cautious.\n        //\n        // The Asset beacon names are deliberately the same for both the negotiation beacons and the\n        // active beacons to improve beacon usability (just swap out the policy id).\n        //\n        // One unit of each asset in the collateral list must be stored in the Ask UTxO to allow the\n        // lender to potentially filter Ask UTxOs based off the loan asset AND a desired collateral\n        // asset. In other words, the collateral itself can compliment the beacon queries. This\n        // requirement also has the added benefit of protecting against denial-of-service attacks\n        // against the beacon queries by: 1) invalidating Ask UTxOs with fake collateral assets, and\n        // 2) pushing up the required minUTxOValue for each Ask UTxO. The minUTxOValue makes it\n        // expensive to create millions of Ask UTxOs with real but worthless collateral just to\n        // pollute the beacon queries.\n        //\n        // The borrower's credential must signal approval so that only the borrower can initiate\n        // negotiations under that identity. This cryptographically prevents identity theft.\n        //\n        // The loan asset is deliberately allowed to be the same as a collateral asset to enable\n        // secured loans. Secured loans are very useful for bootstrapping a borrower's credit\n        // history.\n        //\n        // There is no need for the AskDatum to contain the observer scripts since the observer\n        // script hashes are hard-coded into the active beacon script. Therefore, the active beacon\n        // script hash implicitly also declares what observer scripts are allowed to be used.\n\n        // Extract out the required information from the script context.\n        let ScriptContext(Transaction{outputs,withdrawals,extra_signatories,..}, purpose) = ctx\n\n        // This redeemer must be used with either a staking execution or a minting execution. Get\n        // the negotiation_beacon_id from the purpose while checking the type of execution used.\n        let negotiation_beacon_id = when purpose is {\n          tx.Mint(negotiation_beacon_id) -> negotiation_beacon_id\n          tx.WithdrawFrom(Inline(ScriptCredential(negotiation_beacon_id))) -> negotiation_beacon_id\n          _ -> error @\"This redeemer must be used with minting or staking execution\"\n        }\n\n        // Helper variable\n        let borrower_stake_cred = Some(Inline(borrower_credential))\n\n        // All of the following must successfully validate.\n        and {\n          // Check outputs. This has its own trace messages.\n          ask.ask_beacon_destination_check(\n            Address(ScriptCredential(loan_script_hash),borrower_stake_cred),\n            core.credential_to_borrower_id(borrower_credential),\n            core.to_negotiation_id(negotiation_beacon_id),\n            core.to_active_id(active_beacon_id),\n            outputs\n          ),\n          // Check for approval.\n          trace_if_false(\n            @\"Borrower credential did not approve\", \n            utils.staking_credential_approves(borrower_stake_cred,withdrawals,extra_signatories)\n          )\n        }\n      }\n\n      CreateCloseOrUpdateOffer{lender_credential} -> {\n        // When this redeemer is used, it will be assumed that all outputs with negotiation beacons\n        // are meant to be Offer UTxOs locked at borrowers' addresses on behalf of the respective\n        // lender. Since the borrower is usually assumed to be different from the lender, there is\n        // no reason to support composing creating Ask UTxOs and creating Offer UTxOs.\n        //\n        // By explicitly stating what valid UTxOs with Offer beacons are, it implicitly enforces that\n        // the proper beacons are minted/burned. This design allows for closing and updating Offer\n        // UTxOs in the same transaction while also improving performance. This means converting\n        // Offer UTxOs in place is supported.\n        //\n        // If no beacons need to be minted/burned, this redeemer can be used with a staking\n        // execution. It uses the exact same logic as the minting execution.\n        //\n        // The Offer UTxOs do not need to all go to the same address; Alice can open Offer UTxOs\n        // for different borrowers in a single transaction.\n        //\n        // For this redeemer to successfully execute, all of the following must be true:\n        // 1) All beacons must go to a loan script address with a valid staking credential.\n        // 2) All outputs with beacons must have exacly three beacons:\n        //    a) an Offer beacon with the token name \"Offer\"\n        //    b) an Asset beacon with the token name \n        //       sha2_256( \"Asset\" ++ asset_policy_id + asset_name )\n        //    c) A LenderId where the token name is the lender's stake credential, prefixed \n        //       with either \"00\" or \"01\" depending on if the lender's stake credential is a\n        //       pubkey credential or script credential, respectively.\n        // 3) All outputs with beacons must have a proper OfferDatum:\n        //    a) negotiation_beacon_id == this policy id\n        //    b) active_beacon_id == hard-coded active_beacon_id\n        //    c) lender_id == the token name for the LenderId token in the output\n        //    d) lender_address == either a payment pubkey address or a proxy script address\n        //       with a valid staking credential\n        //    e) loan_asset == asset that corresponds to the Asset beacon in the output\n        //    f) loan_principal > 0\n        //    g) epoch_duration > 0 if used\n        //    h) loan_term > 0\n        //    i) loan_interest must have a denominator > 0 and a numerator >= 0\n        //    j) min_payment >= 0\n        //    k) The penalty must either have a fixed fee > 0, a percent fee > 0, or no penalty.\n        //    l) collateralization list must not be empty, be sorted, not have any duplicates, and \n        //       all relative prices must have numerators >= 0 and have denominators > 0\n        //    m) claim_period > 0\n        //    n) offer_deposit > 0\n        //    o) offer_expiration > 0 if used.\n        // 4) The output must contain exactly the principal for the loan + the offer deposit.\n        // 5) No other assets are allowed in the output.\n        // 6) The lender's credential must signal approval.\n        //\n        // There is no need for the OfferDatum to contain the observer scripts since the observer\n        // script hashes are hard-coded into the active beacon script. Therefore, the active beacon\n        // script hash implicitly also declares what observer scripts are allowed to be used.\n        //\n        // Prefixing the LenderId with either \"00\" or \"01\" allows the scripts to know whether the \n        // lender_id is for a pubkey or script just from its asset name.\n        //\n        // The epoch_duration field determines how often interest must be applied and/or how often\n        // the min_payment must be met to avoid penalties. Setting interest to 0 will enable\n        // interest interest-free loans. An interest > 0 with compounding_interest set to False\n        // will result in a non-compounding interest loan.\n        //\n        // If the lender does not want a particular collateral asset used, the relative value\n        // for that asset can be set to 0 to prevent it from counting as collateral. The undesired\n        // asset can also be omitted from the list, instead.\n        //\n        // The min_payment is the minimum required payment a borrower must make each epoch\n        // period. If the minimum payment has not been met by the time the next interest payment\n        // is required, the penalty will be applied to the outstanding balance. This field\n        // incentivizes the borrower to make regular payments on the loan. It can be set to zero\n        // to make the lender's offer more competitive against other offers. Penalties can still\n        // be applied even if the loan's interest is set to zero, or if the interest is\n        // non-compounding.\n        //\n        // The collateral_is_swappable field does not need to be checked since the only possible\n        // values are true and false; anything else will cause the script to crash when the datum is\n        // parsed. This field controls whether collateral can be swapped out during a loan payment.\n        // When swapping out collateral, the total relative value of the collateral backing the loan\n        // must still satsify the requirements. While being able to swap out collateral favors the\n        // borrower, the fact that the lender must explicitly allow it means the borrower cannot\n        // abuse this feature. Lender's can use this field to make their offers more attactive than\n        // the offers from other lenders.\n        //\n        // The lender's credential must approve so that the LenderId is cryptographically paired\n        // to that lender. No one can pollute the LenderId queries for that lender. This also\n        // ensures that the lender did not mistakenly specify the wrong credential type in the\n        // redeemer.\n\n        // Extract out the required information from the script context.\n        let ScriptContext(Transaction{outputs,withdrawals,extra_signatories,..}, purpose) = ctx\n\n        // This redeemer must be used with either a staking execution or a minting execution. Get\n        // the negotiation_beacon_id from the purpose while checking the type of execution used.\n        let negotiation_beacon_id = when purpose is {\n          tx.Mint(negotiation_beacon_id) -> negotiation_beacon_id\n          tx.WithdrawFrom(Inline(ScriptCredential(negotiation_beacon_id))) -> negotiation_beacon_id\n          _ -> error @\"This redeemer must be used with minting or staking execution\"\n        }\n\n        // All of the following must successfully validate.\n        and {\n          // Check outputs. This has its own trace messages.\n          offer.offer_beacon_destination_check(\n            loan_script_hash,\n            core.credential_to_lender_id(lender_credential),\n            core.to_negotiation_id(negotiation_beacon_id),\n            core.to_active_id(active_beacon_id),\n            proxy_hash,\n            outputs\n          ),\n          // The lender must approve creating the offer.\n          trace_if_false(\n            @\"Lender credential did not approve\", \n            utils.staking_credential_approves(\n              Some(Inline(lender_credential)),\n              withdrawals,\n              extra_signatories\n            )\n          )\n        }\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/cardano-loans/aiken/validators/cardano_loans.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse aiken/interval\nuse aiken/primitive/bytearray\nuse calculation/process.{pool_input_to_state, process_orders}\nuse cardano/address.{Address, Inline, Script}\nuse cardano/assets.{AssetName, PolicyId, Value, ada_policy_id}\nuse cardano/script_context.{ScriptContext}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction, Withdraw,\n}\nuse shared.{\n  AssetClass, Ident, count_orders, own_input_index, pool_lp_name, pool_nft_name,\n  spent_output,\n}\nuse sundae/multisig\nuse types/pool.{\n  BurnPool, CreatePool, Manage, ManageRedeemer, MintLP, PoolDatum,\n  PoolMintRedeemer, PoolRedeemer, PoolScoop, UpdatePoolFees, WithdrawFees,\n} as types_pool\nuse types/settings.{SettingsDatum, find_settings_datum}\n\n/// The core / base \"pooled AMM\" script for the SundaeSwap v3 protocol\n///\n/// Parameterized by the Settings policy ID, which makes the script unique, as well as lets us validate / read global settings.\n///\n/// This script is responsible for:\n///  - Guarding access to the pools assets on behalf of the depositors\n///  - Enabling and executing a batch of orders against those assets, implementing a standard 'AMM' swap protocol\n///  - Serving as a minting policy, minting the Pool NFT and LP tokens\n///  - Accumulating protocol fees on behalf of the protocol\n///  - Allowing protocol rewards to be withdrawn to a DAO treasury\n///\n/// It does so by allowing a permissioned set of entities to \"scoop\" a batch of orders, and ensuring that each one\n/// pays out to the appropriate destination.\n///\n/// This set of people is permissioned to prevent classes of \"sandwich\" attacks, wherein a malicious actor could\n/// execute and match orders in their *own* favor, rather than the users favor.\n///\n/// Also of particular sensitivity is the optimizations applied; To achieve high-throughput, low-cost DeFi, executing\n/// each order independently suffers from some amount of overhead.  If, for example, the execution costs are split into:\n/// A - The costs that need to be run in each transaction, regardless of what is executed\n/// B - The costs that need to be executed for each order\n/// C - The costs exclusive to batching, such as sorting the orders\n///\n/// It is likely, then, that protocols converge on the per-order cost of batching being lower than un-batched variants, i.e.\n///\n/// A + B*n + C < (A + B) * n\nvalidator pool(\n  manage_stake_script_hash: ScriptHash,\n  settings_policy_id: PolicyId,\n) {\n  spend(\n    datum: Option<PoolDatum>,\n    redeemer: PoolRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    expect Some(datum) = datum\n    // First, we destructure the transaction right upfront, because field access is O(n),\n    // and we want access to these fields with just a single pass over the transaction\n    // This will be a common pattern throughout the scripts\n    // (in fact, I really want a compiler optimization that detects and lifts repeated field accesses into a destructure)\n    let Transaction {\n      inputs,\n      outputs,\n      reference_inputs,\n      mint,\n      datums,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      ..\n    } = transaction\n\n    // Then, (confusing terminology aside) find the specific pool UTXO being spent by this transaction\n    let pool_input = spent_output(transaction, out_ref)\n\n    // And pattern match to get the pool script hash; in particular, this can be used to find the pool output,\n    // *and* to know the policy ID of pool tokens, because this is a dual spending/minting validator.\n    expect Script(pool_script_hash) = pool_input.address.payment_credential\n\n    // The protocol configures many global settings via a \"settings\" UTXO, updatable by certain administrators\n    // This is included as a reference input, so we have a utility to check the reference inputs for the settings NFT\n    // Note: it's important to check for the NFT, because checking just for the address would let someone pay random funds to the settings address.\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n\n    // Then, there are two different actions that can be taken against a pool:\n    // - Scooping a batch of orders\n    // - Withdrawing protocol fees to the treasury\n    when redeemer is {\n      // In the case of the scoop, the redeemer indicates which scooper is doing the scoop, and the order in which the inputs should be processed\n      PoolScoop { signatory_index, scooper_index, input_order } -> {\n        // Find the pool output, the output datum, and destructure it to access the fields we need to process the scoop\n        let (\n          Output { address: pool_output_address, value: pool_output_value, .. },\n          PoolDatum {\n            identifier: actual_identifier,\n            circulating_lp: actual_circulating_lp,\n            protocol_fees: actual_protocol_fees,\n            assets: actual_assets,\n            bid_fees_per_10_thousand: actual_bid_fees_per_10_thousand,\n            ask_fees_per_10_thousand: actual_ask_fees_per_10_thousand,\n            market_open: actual_market_open,\n            ..\n          },\n        ) = find_pool_output(outputs)\n\n        // Ensure that the pool output is to the same payment credential; This is critical, because it ensures that the pool NFT\n        // or liquidity aren't paid to some other script in control of an attacker.\n        // Note that we check the stake credential is correctly updated (or not) in the various redeemer cases below.\n        // We also check that the pool output has the correct output, which ensures it contains the pool NFT,\n        // meaning this can't just be a \"token output\" with the correct payment credential, but everything paid elsewhere.\n        expect\n          pool_output_address.payment_credential == Script(pool_script_hash)\n\n        // Deconstruct the settings datum with the fields we need for a scoop\n        let SettingsDatum {\n          authorized_scoopers,\n          base_fee,\n          simple_fee,\n          strategy_fee,\n          ..\n        } = settings_datum\n\n        // Do a simple scan over the orders to count up the number of orders we'll be processing\n        // This is unavoidable, because it's part of making sure that the provided redeemer set isn't\n        // excluding orders\n        let real_order_count = count_orders(inputs)\n        // Calculate the portion of the fee that each order will be\n        // entitled to pay;\n        // Because the division is rounded down, we add real_order_count and subtact 1\n        // to ensure that we take the ceiling instead, and round in the protocols favor.\n        let amortized_base_fee =\n          ( base_fee + real_order_count - 1 ) / real_order_count\n        // Make sure it's not negative, for example if base_fee was negative\n        expect amortized_base_fee >= 0\n\n        // Construct the initial pool state from the datum and the locked values\n        // This intermediate state will be updated as we process each order, allowing us to do a scan over each input\n        // In particular, it calculates what fees we should be charging (because of the linear fee decay) and the actual tradable reserves\n        // (excluding protocol fees, which shouldn't factor into the price)\n        // Note: this abomination is brought to you by the fact that constructing and destructuring structs\n        // is expensive, so it's cheaper to have **massive** lambdas / continuations\n        let\n          pool_policy_a,\n          pool_asset_name_a,\n          pool_quantity_a,\n          pool_policy_b,\n          pool_asset_name_b,\n          pool_quantity_b,\n          pool_policy_lp,\n          pool_asset_name_lp,\n          pool_quantity_lp,\n          bid_fees,\n          ask_fees,\n          initial_protocol_fees,\n        <- pool_input_to_state(pool_script_hash, datum, pool_input)\n\n        // Process the orders in order, and decide the final pool state we should see\n        // This also counts up the number of simple / strategy orders, which let us compute the effective protocol fee.\n        // for optimization purposes, there are quite a lot of parameters, and their interaction is quite subtle\n        let\n          final_a,\n          final_b,\n          final_lp,\n          simple_count,\n          strategy_count,\n        <-\n          process_orders(\n            actual_identifier,\n            // The pool identifier, so we can check that each order is for this pool\n            validity_range,\n            // The validity range of the transaction, so we can check strategies haven't expired\n            withdrawals,\n            // Include the withdrawals, in case a strategy has some kind of attached script condition\n            datums,\n            // The datums, so we can look up the datum of each order (which may be inline, but may also be in the datums dict)\n            // The initial pool state, such as the reserves and circulating LP\n            pool_policy_a,\n            pool_asset_name_a,\n            pool_quantity_a,\n            pool_policy_b,\n            pool_asset_name_b,\n            pool_quantity_b,\n            pool_policy_lp,\n            pool_asset_name_lp,\n            pool_quantity_lp,\n            input_order,\n            // The input ordering specified by the scooper\n            bid_fees,\n            // The liquidity provider fee to charge for bids (A -> B), in parts per 10,000 (basis points)\n            ask_fees,\n            // ... for Ask (swap B -> A)\n            amortized_base_fee,\n            // The base fee split by the number of orders, paid for each user\n            simple_fee,\n            // The fee to charge for each \"simple\" order (swap, deposit, withdrawal, etc.)\n            strategy_fee,\n            // The fee to charge for each \"strategy\" order\n            0,\n            // The previous index we processed, intitially 0; this lets us detect if we need to \"restart\" the input list\n            inputs,\n            // *All* inputs, so we can start over at the beginning of the list if we want\n            inputs,\n            // *Remaining* inputs, so we can advance through the list one by one so long as the orders are in order\n            list.drop(outputs, 1),\n            // The list of outputs we should be comparing orders against\n            0,\n            // A uniqueness bit-flag, to detect which orders have already been processed; see lib/calculation/InputSorting.md\n            0,\n            // The accumulated count of \"simple\" orders, for calculating the fee; set to 0 to start, but incremented in each recursion\n            0,\n          )\n        // The accumulated count of \"strategy\" orders, see line above.\n        // We need to make sure that the number of orders matches the amount that we processed\n        // so the scooper doesn't \"under-report\" the orders and steal the funds on the order\n        expect simple_count + strategy_count == real_order_count\n\n        // We calculate the expected total collected protocol fee\n        // We multiply amortized_base_fee, which everyone paid, by the number of orders\n        // and then the respective fees for each simple order and strategy order\n        let expected_fees_collected =\n          amortized_base_fee * real_order_count + simple_count * simple_fee + strategy_count * strategy_fee\n\n        // Make sure we actually increased the protocol fee by exactly this amount\n        expect\n          actual_protocol_fees == initial_protocol_fees + expected_fees_collected\n\n        // The pool should have all of the scooper fees, and the quantity of each token of the outcome\n        // Note that initializing the state with `-transaction.fee` means this gets subracted out of the protocol fees\n        // TODO: do we need to account for this? it seems to have gotten lost in some changes.\n        expect\n          minted_correct_pool_tokens(pool_script_hash, mint, datum, final_lp)\n\n        // Check that the scooper is authorized; the protocol can allow *any* scoopers, or limit it to a set of actors\n        // It's safe to use values provided in the redeemer to efficiently skip to the expected scooper / expected signature\n        // because at the end of the day, we just care that the scooper has signed the transaction. If the scooper provides\n        // anything but the correct indexes, it'll just fail the transaction.\n        expect\n          when authorized_scoopers is {\n            Some(authorized_scoopers) -> {\n              // OPTIMIZATION: skip 10 entries at a time\n              // OPTIMIZATION: assume scooper is first extra_signatory? have to assume there will only ever be one extra_signatory\n              expect Some(scooper_sig) =\n                list.at(extra_signatories, signatory_index)\n              expect Some(scooper) = list.at(authorized_scoopers, scooper_index)\n              // must be an authorized scooper\n              scooper_sig == scooper\n            }\n            _ -> True\n          }\n\n        // the market must have opened; this allows projects to pre-create their pool, potentially across multiple protocols, and allows\n        // people to open orders ahead of time, and avoids things like sniping bots, etc.\n        // TODO: should we *only* prevent swaps / withdrawals? would it be ok to allow deposits?\n        // TODO: should we have a \"blackout period\", where withdrawals are prevented, similar to IPOs?\n        expect interval.is_entirely_after(validity_range, datum.market_open)\n\n        // We also check that the pool output has the right value (as mentioned above)\n        // In particular, the pool must have:\n        // - the pool NFT\n        // - the correctly adjusted assets from swapping, deposits, withdrawals, etc.\n        // - an additional amount of ADA corresponding to the protocol fees\n        // - NOTHING ELSE; This is important because someone could add tons of junk tokens and increase the execution units, potentially even freezing the UTXO\n        expect\n          has_expected_pool_value(\n            pool_script_hash,\n            actual_identifier,\n            pool_output_value,\n            pool_policy_a,\n            pool_asset_name_a,\n            final_a,\n            pool_policy_b,\n            pool_asset_name_b,\n            final_b,\n            final_lp,\n            actual_protocol_fees,\n          )\n        // Now, we check various things about the output datum to ensure they're each correct.\n        // Check that the datum correctly records the final circulating LP, accounting for any deposits and withdrawals\n        // In particular, this is important because that circulating supply is exaclty what determines the users ownership of assets in the pool\n        // If this gets out of sync with what we've actually minted, then users will be able to either redeem assets they aren't entitled to,\n        // or be unable to access funds they are entitled to.\n        expect actual_circulating_lp == final_lp\n\n        // Make sure the protocol fees have been correctly updated\n        expect\n          actual_protocol_fees == initial_protocol_fees + expected_fees_collected\n\n        // And make sure each of these fields is unchanged\n        and {\n          datum.identifier == actual_identifier,\n          datum.assets == actual_assets,\n          datum.bid_fees_per_10_thousand == actual_bid_fees_per_10_thousand,\n          datum.ask_fees_per_10_thousand == actual_ask_fees_per_10_thousand,\n          datum.market_open == actual_market_open,\n          // Finally, make sure we don't change the stake credential; this can only be done when withdrawing fees, by the treasury administrator\n          pool_input.address.stake_credential == pool_output_address.stake_credential,\n        }\n      }\n      Manage ->\n        // There must be a redeemer for a (stake-script) withdrawal against the manage stake script,\n        // and the redeemer must correctly point at the pool UTXO\n        pairs.foldl(\n          transaction.redeemers,\n          False,\n          fn(script_purpose, redeemer, acc) {\n            when script_purpose is {\n              Withdraw(Script(script)) -> {\n                let is_valid_manage_script_invoke =\n                  if script == manage_stake_script_hash {\n                    expect redeemer: ManageRedeemer = redeemer\n                    let redeemer_pool_input =\n                      when redeemer is {\n                        UpdatePoolFees { pool_input } -> pool_input\n                        WithdrawFees { pool_input, .. } -> pool_input\n                      }\n                    let input_index = own_input_index(transaction, out_ref)\n                    // Manage redeemer must have the correct index of this pool input\n                    input_index == redeemer_pool_input\n                  } else {\n                    False\n                  }\n                acc || is_valid_manage_script_invoke\n              }\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  mint(r: PoolMintRedeemer, own_policy_id: PolicyId, transaction: Transaction) {\n    // When minting, we can be doing one of two things: minting the pool itself, or minting the LP token\n    when r is {\n      // For creating a new pool, one of our design objectives was to avoid requiring interaction with any global\n      // \"factory\", as in v1; this created a lot of contention, and didn't serve it's original goal of ensuring that\n      // the (pair, fee) was unique.\n      CreatePool(assets, pool_output_ix, metadata_output_ix) -> {\n        // And grab the pool output\n        expect Some(pool_output) = list.at(transaction.outputs, pool_output_ix)\n\n        // Check that the pool datum is inline, because a datum hash could brick this pool\n        expect InlineDatum(d) = pool_output.datum\n        expect pool_output_datum: PoolDatum = d\n\n        // The assets on the pool must be sorted\n        // This is partially to make off-chain indexing easier, and as an on-chain optimization,\n        // so we can always assume that, if ADA is one of the pairs, it's the first asset.\n        // This also prevents creating an X/X pool, since we require the assets to be stricly less than\n        // Note, it is a NON GOAL to enforce that any specific (pair, fee) combination is unique; while aggregating liquidity\n        // can be beneficial for capital efficiency, in practice that will happen anyway, and smaller pools can be useful as\n        // a pressure release valve. Additionally, we have bigger plans around interesting order splitting modes of operation that\n        // make that less important.\n        let (asset_a, asset_b) = assets\n        let coin_pair_ordering_is_canonical =\n          compare_asset_class(asset_a, asset_b) == Less\n\n        // We use the first input ref spent in this transaction to uniquely identify the pool\n        // This is a trick widely used to produce NFTs, and ensures that we can generate a hash that is unique to this pool\n        expect Some(first_input) = list.at(transaction.inputs, 0)\n        let first_input_index =\n          int_to_ident(first_input.output_reference.output_index)\n\n        // Calculate the identifier by hashing the txRef of the first input\n        // this makes the pool unique\n        // With CIP-68 identifiers (which take up 4 bytes), we have 28 bytes of space;\n        // ideally we'd use blake2b-224, which is exactly a 224 byte hash, but that won't be on-chain until plutus v3;\n        // So, we use blake2b-256 and drop a few bytes. Now, does this compromise the uniqueness guarantees?\n        // It is strongly believed by the cryptographer community that blake2b-256 provides indifferentiability from random oracles\n        // [https://eprint.iacr.org/2013/322.pdf]\n        // which allows us to treat the 256 bits as uniformly sampled. This means that there are 2^256 equally likely values, and the\n        // chance of collision is 1 in 2^256, unfathomably small.\n        // Even when used in bulk, the birthday paradox means that you would need to generate 2^128 different hashes before you had even a 50% chance of collision.\n        // This is known as \"128 bit security\", and is considered a gold standard of cryptography.\n        // So, how does dropping 4 bytes (32 bits) from this hash impact that analysis?\n        // There are still 2^224 possible values, meaning it offers 2^112 bit security, still considered \"unbreakable\".\n        // As a comparison, at the time of this writing the entire bitcoin network is performing 500 exa-hashes per second, or\n        // 500 * 10^18 hashes per second. If the entire bitcoin network was directed towards trying to generate a collision on pool ident, it would take\n        // Roughly 10^13 seconds, or 317,098 years to have a 50% chance of collision. Not to mention the cost of storing and comparing to detect if you'd performed\n        // a collision, or the cost of grinding UTXOs on cardano to give fresh inputs to the pool script.\n        let new_pool_id =\n          first_input.output_reference.transaction_id\n            |> bytearray.concat(#\"23\") // '#' character\n            |> bytearray.concat(first_input_index)\n            |> crypto.blake2b_256\n            |> bytearray.drop(4)\n\n        // With that pool identifier, we can attach 3 different CIP-68 pool identifiers:\n        // - (100) indicates a tracking token, for the purposes of on-chain metadata read by off-chain infra, so we can provide a nice experience to the users wallet for example\n        // - (222) indicates the pool NFT, which uniquely identifies the UTXO that holds pool assets\n        // - (333) indicates the fungible LP token, which represents a percentage ownership of the pool\n        let (new_pool_ref_token, new_pool_nft_token, new_pool_lp_token) =\n          shared.pool_token_names(new_pool_id)\n\n        // Then, find the settings datum, so we can ensure the reference token is paid to the metadata admin\n        let reference_inputs = transaction.reference_inputs\n        let settings_datum =\n          find_settings_datum(reference_inputs, settings_policy_id)\n\n        // Grab the initial reserves of each token by looking at what's paid to the UTXO\n        let coin_a_amt =\n          assets.quantity_of(pool_output.value, asset_a.1st, asset_a.2nd)\n        let coin_b_amt =\n          assets.quantity_of(pool_output.value, asset_b.1st, asset_b.2nd)\n\n        // Ensure that the pool pays the pool creation fee, if any, by ensuring that the initial protocol_fees value is greater than or equal to the fee\n        expect\n          pool_output_datum.protocol_fees >= settings_datum.pool_creation_fee\n\n        // Only ada has a null policy id. If coin A is ada, subtract the initial protocol_fees setting from the coin A amount\n        // rider from the output to get the true amount in the pool.\n        let coin_a_amt_sans_protocol_fees =\n          if bytearray.is_empty(asset_a.1st) {\n            coin_a_amt - pool_output_datum.protocol_fees\n          } else {\n            coin_a_amt\n          }\n\n        // Check that the quantity of LP tokens is correct; In particular, we adopt Uniswaps convention of\n        // using the sqrt of the product of the two values for the initial number of LP tokens to mint..\n        // This helps minimize precision loss: it gives decent initial liquidity values for a range of\n        // sizes of pools, such that an individual LP token is granular enough for depositing and withdrawing for most users.\n        // In particular, though, we don't calculate the sqrt here, which is an expensive function; we instead verify that the\n        // amount minted is valid by checking that it squares to the correct product\n        let initial_lq = pool_output_datum.circulating_lp\n        expect\n          shared.is_sqrt(coin_a_amt_sans_protocol_fees * coin_b_amt, initial_lq)\n\n        // And check that we mint the correct tokens, and nothing else.\n        let expected_mint =\n          shared.to_value((own_policy_id, new_pool_ref_token, 1))\n            |> assets.merge(\n                shared.to_value((own_policy_id, new_pool_nft_token, 1)),\n              )\n            |> assets.merge(\n                shared.to_value((own_policy_id, new_pool_lp_token, initial_lq)),\n              )\n        let mint_is_correct = transaction.mint == expected_mint\n\n        // Confirm that the correct funds (asset A, asset B, the correct amount of ADA, and the pool NFT) get paid to the pool output\n        let funds_spent_to_pool =\n          has_expected_pool_value(\n            own_policy_id,\n            new_pool_id,\n            pool_output.value,\n            asset_a.1st,\n            asset_a.2nd,\n            coin_a_amt_sans_protocol_fees,\n            asset_b.1st,\n            asset_b.2nd,\n            coin_b_amt,\n            initial_lq,\n            pool_output_datum.protocol_fees,\n          )\n\n        // Make sure we send the pool metadata token to the metadata admin\n        // We use an index from the redeemer to skip to the right output, in case there are multiple outputs to the metadata admin\n        // This is safe to do for the usual reasons: if they point at a UTXO without the ref token, the transaction will fail.\n        expect Some(metadata_output) =\n          list.at(transaction.outputs, metadata_output_ix)\n        expect metadata_output.address == settings_datum.metadata_admin\n        expect\n          assets.quantity_of(\n            metadata_output.value,\n            own_policy_id,\n            new_pool_ref_token,\n          ) == 1\n\n        // We also check that the datum on the metadata output is void; It would be complex and in-flexible to enforce any particular structure on this, so we\n        // instead leave it to the metadata admin to spend the output and provide it the correct datum; We also don't want to leave it unspecified, because\n        // 1) the metadata admin might actually be a script address, in which case having no datum will permanently lock the metadata\n        // 2) the pool minter might include malicious metadata, such as an icon pointing at hardcore porn; until the metadata admin spent it, this would appear in users wallets,\n        //    and potentially even on access UIs for the Sundae protocol\n        expect metadata_output.datum == InlineDatum(Void)\n\n        // And check that the datum is initialized correctly; This is part of why we have a minting policy handling this,\n        // as it allows us to authenticate the providence of the datum.\n        // A datum is valid so long as\n        // - the pool identifier is set correctly\n        // - the assets is set correctly\n        // - the initial circulating supply is set correctly\n        // - the initial and final fees per 10,000 are both non-negative (>= 0%)\n        // - the intitial and final fees per 10,000 are both less than or equal to 10000 (<= 100%)\n        let pool_output_datum_correct = and {\n            pool_output_datum.identifier == new_pool_id,\n            pool_output_datum.assets == (asset_a, asset_b),\n            pool_output_datum.circulating_lp == initial_lq,\n            shared.fees_in_legal_range(\n              pool_output_datum.bid_fees_per_10_thousand,\n            ),\n            shared.fees_in_legal_range(\n              pool_output_datum.ask_fees_per_10_thousand,\n            ),\n          }\n\n        // Make sure that the pool output is paid into own_policy_id (the pool script, remember this is a multivalidator)\n        // and that one of the valid staking addresses is attached\n        expect pool_output.address.payment_credential == Script(own_policy_id)\n        expect\n          list.any(\n            settings_datum.authorized_staking_keys,\n            fn(a) { pool_output.address.stake_credential == Some(Inline(a)) },\n          )\n\n        // And then check each of the conditions above as the condition for minting\n        and {\n          coin_pair_ordering_is_canonical,\n          mint_is_correct,\n          funds_spent_to_pool,\n          pool_output_datum_correct,\n        }\n      }\n      // When minting an LP token, we just need to make sure the pool script is being spent, as it will enforce the correct\n      // name and quantity of the LP tokens.\n      //\n      // To do that, we could check for the pool NFT on the inputs, but this is expensive, especially if the pool input ends up being one of the last.\n      // So instead we check that the pool NFT is in the first output (this is safe to assume because it's unique, and if it's in any other output it will fail)\n      // and that we're not minting the pool token (i.e. someone could \"pretend\" to mint LP tokens, but also mint the pool token to make it look like a scoop)\n      //\n      // So, lets enumerate the possible cases:\n      // - We use the CreatePool redeemer; this checks that *only* the correct pool token and correct number of LP tokens are minted\n      // - We use the MintLP redeemer; this checks that the pool token (which is unique and locked in the pool script) is in the outputs, and not minted\n      //   - the pool script checks that only the correct number of LP tokens, and nothing else under this policy ID, are minted\n      // And the impossible cases:\n      // - During CreatePool, it would be impossible to mint multiple of the same pool tokens; a different pool token; a different number of LP tokens; or a different pool's LP tokens\n      // - During MintLP, it would be impossible to mint the relevant pool token; thus, the pool script must run, and thus it will be impossible to mint another pool token, a different pool\n      //   ident pool token, a different quantity of LP tokens, or a different pools LP tokens\n      MintLP(pool_ident) -> {\n        let pool_nft_name = shared.pool_nft_name(pool_ident)\n        expect Some(pool_output) = list.head(transaction.outputs)\n        and {\n          (\n            pool_output.value\n              |> assets.quantity_of(own_policy_id, pool_nft_name)\n          ) == 1,\n          (\n            transaction.mint\n              |> assets.quantity_of(own_policy_id, pool_nft_name)\n          ) == 0,\n        }\n      }\n      BurnPool(pool_ident) -> {\n        // Burning an asset is only possible when spending it, so if we enforce\n        // that the mints consist of exactly 1 burn for the specified pool NFT\n        // then we can defer to the pool spending validator\n        let pool_nft_name = shared.pool_nft_name(pool_ident)\n        let expected_mint = shared.to_value((own_policy_id, pool_nft_name, -1))\n        transaction.mint == expected_mint\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn find_pool_output(outputs: List<Output>) -> (Output, PoolDatum) {\n  // Find the pool output; we can assume the pool output is the first output, because:\n  // - The ledger doesn't reorder outputs, just inputs\n  // - We check that the address is correct, so if the first output was to a different contract, we would fail\n  // - We check that the datum is the correct type, meaning we can't construct an invalid pool output\n  // - Later, we check that the pool output has the correct value, meaning it *must* contain the pool token, so we can't pay to the pool script multiple times\n  expect Some(pool_output) = list.head(outputs)\n  expect InlineDatum(output_datum) = pool_output.datum\n  expect output_datum: PoolDatum = output_datum\n  (pool_output, output_datum)\n}\n\n/// This is responsible for checking that the minting value on the transaction is valid\n/// based on the pool state, the policy ID, and the initial incoming datum.\nfn minted_correct_pool_tokens(\n  pool_policy_id: PolicyId,\n  mint: Value,\n  datum: PoolDatum,\n  quantity_lp: Int,\n) -> Bool {\n  // Unwrap the silly MintedValue special type\n  // Note also we only look at the tokens with this policyID\n  // so that we can still mint other tokens\n  let minted_tokens = assets.tokens(mint, pool_policy_id)\n\n  // If the initial datum has the same circulating LP as the outcome, then we expect no minted tokens\n  // Otherwise, the minted tokens should be exactly the pool LP tokens and nothing else\n  // TODO: confirm that the \"minting 0 ada\" problem doesn't apply here; we have real-world transactions, so I doubt it does, but I want to confirm.\n  // TODO: This should allow minting of other tokens, from other policy IDs, perhaps, for composibility?\n  if datum.circulating_lp == quantity_lp {\n    dict.is_empty(minted_tokens)\n  } else {\n    dict.to_pairs(minted_tokens) == [\n      Pair(pool_lp_name(datum.identifier), quantity_lp - datum.circulating_lp),\n    ]\n  }\n}\n\n/// Check that the UTXO contents are correct given a specific pool outcome\n/// In particular, it must have the final A reserves, the final B reserves, the pool NFT, and the protocol fees\npub fn has_expected_pool_value(\n  pool_script_hash: PolicyId,\n  identifier: Ident,\n  output_value: Value,\n  pool_policy_a: PolicyId,\n  pool_asset_name_a: AssetName,\n  pool_quantity_a: Int,\n  pool_policy_b: PolicyId,\n  pool_asset_name_b: AssetName,\n  pool_quantity_b: Int,\n  final_lp: Int,\n  final_protocol_fees: Int,\n) -> Bool {\n  // Asset A *could* be ADA; in which case there should be 3 tokens on the output\n  // (ADA, Asset B, and the NFT)\n  if pool_policy_a == ada_policy_id {\n    let actual =\n      list.foldl(\n        assets.flatten(output_value),\n        // (token count, lovelace amount, token b amount, pool nft amount)\n        (0, 0, 0, 0),\n        fn(asset, acc) {\n          let token_count = acc.1st + 1\n          if asset.1st == pool_policy_a {\n            (token_count, acc.2nd + asset.3rd, acc.3rd, acc.4th)\n          } else if asset.1st == pool_policy_b && asset.2nd == pool_asset_name_b {\n            (token_count, acc.2nd, acc.3rd + asset.3rd, acc.4th)\n          } else {\n            expect asset == (pool_script_hash, pool_nft_name(identifier), 1)\n            (token_count, acc.2nd, acc.3rd, acc.4th + 1)\n          }\n        },\n      )\n    // If we're withdrawing the last bit of liquidity, we just have ADA and the pool token\n    let expected =\n      if final_lp == 0 {\n        expect pool_quantity_a == 0\n        expect pool_quantity_b == 0\n        (2, final_protocol_fees, 0, 1)\n      } else {\n        (3, final_protocol_fees + pool_quantity_a, pool_quantity_b, 1)\n      }\n    // Rather than constructing a value directly (which can be expensive)\n    // we can just compare the expected token count and amounts with a single pass over the value\n    expected == actual\n  } else {\n    // Asset A isn't ADA, Asset B will *never* be ADA; in this case, there should be 4 tokens on the output:\n    // ADA, the Pool NFT, Asset A, and Asset B\n    let actual =\n      list.foldl(\n        assets.flatten(output_value),\n        // (token count, lovelace amount, token a amount, token b amount, pool nft amount)\n        (0, 0, 0, 0, 0),\n        fn(asset, acc) {\n          let token_count = acc.1st + 1\n          if asset.1st == ada_policy_id {\n            (token_count, acc.2nd + asset.3rd, acc.3rd, acc.4th, acc.5th)\n          } else if asset.1st == pool_policy_a && asset.2nd == pool_asset_name_a {\n            (token_count, acc.2nd, acc.3rd + asset.3rd, acc.4th, acc.5th)\n          } else if asset.1st == pool_policy_b && asset.2nd == pool_asset_name_b {\n            (token_count, acc.2nd, acc.3rd, acc.4th + asset.3rd, acc.5th)\n          } else {\n            expect asset == (pool_script_hash, pool_nft_name(identifier), 1)\n            (token_count, acc.2nd, acc.3rd, acc.4th, acc.5th + 1)\n          }\n        },\n      )\n    // If we're withdrawing the last bit of liquidity, we just have ADA and the pool token\n    let expected =\n      if final_lp == 0 {\n        expect pool_quantity_a == 0\n        expect pool_quantity_b == 0\n        (2, final_protocol_fees, 0, 0, 1)\n      } else {\n        (4, final_protocol_fees, pool_quantity_a, pool_quantity_b, 1)\n      }\n    expected == actual\n  }\n}\n\n// Compare two policy IDs to determine a sort order; used in particular to enforce an ordering on the assets in the pool\nfn compare_asset_class(a: AssetClass, b: AssetClass) {\n  let (a_policy, a_token) = a\n  let (b_policy, b_token) = b\n  when bytearray.compare(a_policy, b_policy) is {\n    Less -> Less\n    Equal -> bytearray.compare(a_token, b_token)\n    Greater -> Greater\n  }\n}\n\n// Convert a specific integer (like a UTXO index) into a byte array, so we can construct a hashable string when minting the pool\npub fn int_to_ident(n: Int) -> Ident {\n  expect n < 256\n  bytearray.push(#\"\", n)\n}\n\n// In order to keep the script size small for the pool script, we defer some functions to a separate stake script;\n// when the treasury administrator attempts to withdraw fees, or the fee manager attempts to update the pool fee,\n// it only checks for this particular script hash. This script, using the withdraw 0 trick, then checks the correct invariants\nvalidator manage(settings_policy_id: PolicyId) {\n  else(ctx: ScriptContext) {\n    expect redeemer: ManageRedeemer = ctx.redeemer\n    let transaction = ctx.transaction\n    let Transaction {\n      inputs,\n      outputs,\n      reference_inputs,\n      mint,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      ..\n    } = transaction\n\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n\n    when redeemer is {\n      // In order to withdraw `amount` fees into `treasury_output` utxo, looking at `pool_input`\n      WithdrawFees { amount, treasury_output, pool_input } -> {\n        // Find the pool input; note that we don't look for the pool NFT here, because if someone\n        // spends with an unauthenticated UTXO, it will fail the spend script; and if someone\n        // spends with a different script address, this script can't do anything fishy,\n        // just enforces some things about the outputs\n        // We also can't pull this out of the when, because we don't have the pool_input index yet\n        expect Some(pool_input) = list.at(inputs, pool_input)\n        let pool_input = pool_input.output\n        expect InlineDatum(datum) = pool_input.datum\n        expect datum: PoolDatum = datum\n        expect Script(pool_script_hash) = pool_input.address.payment_credential\n        let PoolDatum {\n          circulating_lp: initial_circulating_lp,\n          protocol_fees: initial_protocol_fees,\n          ..\n        } = datum\n        // Make sure we withdraw *only* up to what we've earned\n        // We allow less than, so that you can leave some behind for the minUTXO cost, or continuing to earn staking rewards, etc.\n        expect amount <= initial_protocol_fees\n\n        // Only the treasury administrator is allowed to withdraw the fees, to prevent DDOS, and because of the allowance below\n        expect\n          multisig.satisfied(\n            settings_datum.treasury_admin,\n            extra_signatories,\n            validity_range,\n            withdrawals,\n          )\n\n        // Asking the DAO to approve every single cost individually would be a small cognitive DDOS on the community\n        // Instead, the DAO can set an \"allowance\", which is a percentage of each withdrawal that is entrusted to the\n        // treasury administrator to pay those basic fees, such as paying the scoopers, or running incentive programs, etc.\n        //\n        // In particular, it's a percentage, to ensure that splitting up the withdrawals into multiple transactions doesn't\n        // allow them to game that withdrawal.\n        let allowance =\n          amount * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        let to_treasury = amount - allowance\n\n        // And, we must pay everything except the allowance amount to the treasury address\n        // We use the `treasury_output` index to skip to it quickly, rather than scanning for the output\n        // TODO: should we instead sum all the values at the treasury output, to allow\n        // paying out in multiple UTXOs for some reason?\n        expect Some(treasury_output) = list.at(outputs, treasury_output)\n        expect treasury_output.address == settings_datum.treasury_address\n        // We ensure that it's sent with the Void datum. This is because the treasury is likely to be a script address\n        // and scripts are unspendable without a datum; We also don't have any notion of what the \"correct\" datum would be\n        // so we just enforce it to void. If the output datum ever needed a specific datum, we would have to use a proxy address\n        // that worked with the void datum, and paid to the real treasury with the correct datum.\n        // TODO: should we just let the treasury admin specify the datum on the redeemer? Or include it in the settings?\n        expect treasury_output.datum == InlineDatum(Void)\n        // And make sure we pay at least that much in that output. It could be more, for example to donate other ADA from other sources to that address\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n\n        if initial_circulating_lp == 0 {\n          // If there is no liquidity, just require the treasury admin to withdraw everything\n          expect amount == initial_protocol_fees\n          // If circulating_lp is 0, all of the assets have been withdrawn, and so the UTXO will be\n          // ADA (for the treasury fees) and the pool NFT; so we can very cleverly check that the pool\n          // NFT is burned by negating the input, and stripping off the lovelace\n          expect\n            mint == assets.negate(assets.without_lovelace(pool_input.value))\n          True\n        } else {\n          let (\n            Output {\n              address: pool_output_address,\n              value: pool_output_value,\n              ..\n            },\n            output_datum,\n          ) = find_pool_output(outputs)\n          expect\n            pool_output_address.payment_credential == Script(pool_script_hash)\n\n          // As part of withdrawing, we should decrease the protocol fees by the amount we're withdrawing\n          // but, importantly, *nothing else*; so we construct a datum with everything from the initial datum, plus the protofol fees updated\n          let expected_datum =\n            PoolDatum { ..datum, protocol_fees: initial_protocol_fees - amount }\n          expect output_datum == expected_datum\n\n          // Now, check that the pool output decreases *only* by the amount we're withdrawing, and not by fewer or greater ADA\n          let expected_output_value =\n            assets.merge(pool_input.value, assets.from_lovelace(-amount))\n          expect pool_output_value == expected_output_value\n          expect\n            list.any(\n              settings_datum.authorized_staking_keys,\n              fn(a) { pool_output_address.stake_credential == Some(Inline(a)) },\n            )\n          True\n        }\n      }\n      // To update the pool fees for the pool at `pool_input`...\n      UpdatePoolFees { pool_input } -> {\n        // Find the pool input; note that we don't look for the pool NFT here, because if someone\n        // spends with an unauthenticated UTXO, it will fail the spend script; and if someone\n        // spends with a different script address, this script can't do anything fishy,\n        // just enforces some things about the outputs\n        // This is duplicated code with the other branch, but only because we don't have pool_input yet\n        expect Some(pool_input) = list.at(inputs, pool_input)\n        let pool_input = pool_input.output\n        expect InlineDatum(datum) = pool_input.datum\n        expect datum: PoolDatum = datum\n        // We need the pool output to check that only the fees or fee manager are updated\n        let (\n          Output { address: pool_output_address, value: pool_output_value, .. },\n          pool_output_datum,\n        ) = find_pool_output(outputs)\n\n        let PoolDatum {\n          bid_fees_per_10_thousand,\n          ask_fees_per_10_thousand,\n          fee_manager: output_fee_manager,\n          ..\n        } = pool_output_datum\n\n        // Make sure we don't update the fees to negative or above 100%\n        expect shared.fees_in_legal_range(bid_fees_per_10_thousand)\n        expect shared.fees_in_legal_range(ask_fees_per_10_thousand)\n\n        let expected_datum =\n          PoolDatum {\n            ..datum,\n            bid_fees_per_10_thousand: bid_fees_per_10_thousand,\n            ask_fees_per_10_thousand: ask_fees_per_10_thousand,\n            fee_manager: output_fee_manager,\n          }\n        expect pool_output_datum == expected_datum\n\n        // Check that the *current* fee manager approves the update\n        expect Some(fee_manager) = datum.fee_manager\n        expect\n          multisig.satisfied(\n            fee_manager,\n            extra_signatories,\n            validity_range,\n            withdrawals,\n          )\n\n        // And make sure we don't touch the assets on the pool input; they must be spent back into the same script\n        and {\n          pool_output_address == pool_input.address,\n          pool_output_value == pool_input.value,\n        }\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/transaction.{Mint, ScriptContext, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{AssetName, PolicyId}\nuse assist/addresses\nuse assist/find\nuse assist/minting\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash, TxHash, ValidatorHash}\nuse assist/values\nuse mint_contract/types.{BurnTokens, MintRedeemer, MintTokens}\n\n// This allows a hot key to mint 1 reference and 1 nft for a cip 68 token or\n// the hot key may be either the reference or nft.\nvalidator(\n  // this key controls everything\n  hot_key: PublicKeyHash,\n  // the cip 68 and stake data\n  cip68_hash_data: Data,\n  stake_hash_data: Data,\n  // this allows many policy ids\n  _random_string: ByteArray,\n) {\n  fn params(redeemer: MintRedeemer, context: ScriptContext) -> Bool {\n    // this transaction\n    let tx: Transaction = context.transaction\n    // the minted value from the tx\n    let mint: List<(PolicyId, AssetName, Int)> =\n      tx.mint\n        |> value.from_minted_value()\n        |> value.flatten()\n    // mint only\n    when context.purpose is {\n      // mint 1 ref and 1 nft\n      Mint(own_currency_symbol) ->\n        when redeemer is {\n          MintTokens -> {\n            // cip68 address know at compile time\n            expect cip68_hash: ValidatorHash = cip68_hash_data\n            expect stake_hash: ValidatorHash = stake_hash_data\n            // staking at this address\n            let cip68_addr: Address =\n              addresses.create_script_address(cip68_hash, stake_hash)\n            // get first input info from the tx in lexographical order\n            let first_index: Int = find.first_input_index(tx.inputs)\n            let first_tx_hash: TxHash = find.first_input_txid(tx.inputs)\n            // use the reference prefix\n            let ref_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_100,\n              )\n            // use the nft prefix\n            let nft_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_222,\n              )\n            // this should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)\n            //\n            // The hot key has to sign the tx to mint 1 ref and 1 nft. There\n            // is destination validation for the cip68 token but not for the \n            // nft. This should allow a lot of flexability.\n            //\n            and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // prevent roll over double nft attack\n              (first_index < 256)?,\n              // must mint 1 reference token\n              minting.exact(mint, own_currency_symbol, ref_tkn, 1)?,\n              // the nft can go anywhere; ref must go to metadatum contract\n              // must mint 1 non-fungible token\n              minting.exact(mint, own_currency_symbol, nft_tkn, 1)?,\n              // reference token must go to cip contract\n              payout.at_least(\n                cip68_addr,\n                value.from_asset(own_currency_symbol, ref_tkn, 1),\n                tx.outputs,\n              )?,\n            }\n          }\n          // burn the ref or the nft or both at the same time\n          BurnTokens -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // this allows optional burning of either or both\n              or {\n                // burn only 1 ref token\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_100,\n                  -1,\n                )?,\n                // burn only 1 nft\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_222,\n                  -1,\n                )?,\n              }?,\n            }\n        }\n      // Mint Only\n      _ -> False\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/minter.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, Redeemer, ScriptContext,\n  ScriptPurpose, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, Inline, ScriptCredential}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse lb_v2/treasury_validation.{validate_creating_treasury_out}\nuse lb_v2/types.{\n  AddSellers, Asset, BurnSeller, CloseTreasury, CollectManager, CollectOrders,\n  CollectSellers, CreateTreasury, FactoryDatum, FactoryRedeemer, Initialization,\n  ManageOrder, ManagerDatum, MintManager, MintOrder, MintRedeemOrders,\n  MintSeller, RedeemOrders, TreasuryDatum, UsingSeller, ValidatorHash,\n}\nuse lb_v2/utils.{\n  assert, compute_lp_asset_name, factory_auth_an, make_wrapper_redeemer,\n  manager_auth_an, manager_minimum_ada, minimum_number_seller,\n  must_get_end_validity, seller_auth_an, treasury_auth_an,\n}\nuse lb_v2/validation\n\n// Spending Factory for:\n// 1. Create a new Treasury (redeemer: )\n//    - 1 Factory Input needs to be spent\n//    - 2 Factory Outputs need to be paid\n//    - 1 Factory Token needs to be mint\n//    - 1 Treasury Token needs to be mint\n//    - 1 Treasury Ouptut needs to be paid\n//    - 1 Manager Token needs to be mint\n//    - 1 Manager Ouptut needs to be paid\n//    - at least @minimum_number_seller need to be mint\n//    - at least @minimum_number_seller Seller Ouptuts need to be paid\n// 2. Close a Treasury:\n//    - 1 Treasury Token needs to be burn\n//    - 1 Treasury Input needs to be spent\n//    - 1 Factory Token needs to be burn\n//    - 2 Factory Inputs need to be spent\n//    - 1 Factory Output need to be paid\n//    - Authorize by Project Owner\nvalidator(\n  // seed output to initialize Factory Linked List \n  out_ref: OutputReference,\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n  // ValidatorHash of Seller Validator\n  manager_hash: ValidatorHash,\n  // ValidatorHash of Seller Validator\n  seller_hash: ValidatorHash,\n  // ValidatorHash of Order Validator\n  order_hash: ValidatorHash,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(factory_ref) } = context\n    let Transaction {\n      inputs,\n      mint,\n      outputs,\n      extra_signatories,\n      validity_range,\n      ..\n    } = transaction\n    // find own's input to get `factory_hash`\n    expect Some(Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(factory_hash),\n          ..\n        },\n        ..\n      },\n      ..\n    }) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: in_out_ref, .. } = input\n          in_out_ref == factory_ref\n        },\n      )\n    // find all Factory Inputs\n    let factory_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          payment_credential == ScriptCredential(factory_hash)\n        },\n      )\n    // find all Factory Outputs\n    let factory_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: Address { payment_credential, .. }, .. } =\n            output\n          payment_credential == ScriptCredential(factory_hash)\n        },\n      )\n    // Extract some necessary data.\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let (base_asset, raise_asset) =\n      when redeemer is {\n        CreateTreasury { base_asset: d_base_asset, raise_asset: d_raise_asset } ->\n          (d_base_asset, d_raise_asset)\n        CloseTreasury { base_asset: d_base_asset, raise_asset: d_raise_asset } ->\n          (d_base_asset, d_raise_asset)\n        _ -> fail @\"Only spending Factory Input when Create | Close Treasury\"\n      }\n    // sort to compute `asset_a`, `asset_b` in term AMM Pool Assets  \n    let (asset_a, asset_b) = utils.sort_two_assets(base_asset, raise_asset)\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // Compute `lp_asset_name` in term AMM Pool LP Token\n    let lp_asset_name =\n      compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    when redeemer is {\n      CreateTreasury { .. } -> {\n        let Transaction { datums, .. } = transaction\n        // finding exactly 1 Factory Input\n        expect [factory_input] = factory_inputs\n        // finding exactly 2 Factory Outputs\n        expect [f_out_head, f_out_tail] = factory_outputs\n        // finding exactly 1 Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs: outputs,\n            factory_policy_id: factory_hash,\n            treasury_hash: treasury_hash,\n          )\n        // finding exactly 1 Manager Output\n        expect [manager_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              // output belongs Manager Address\n              payment_credential == ScriptCredential(manager_hash)\n            },\n          )\n        // Extract some necessary data.\n        let Input { output: Output { value: factory_input_value, .. }, .. } =\n          factory_input\n        let Output {\n          datum: f_out_head_datum,\n          value: f_out_head_value,\n          reference_script: f_out_head_ref_script,\n          ..\n        } = f_out_head\n        let Output {\n          datum: f_out_tail_datum,\n          value: f_out_tail_value,\n          reference_script: f_out_tail_ref_script,\n          ..\n        } = f_out_tail\n        let mint_value = value.from_minted_value(mint)\n        let mint_seller_count =\n          value.quantity_of(mint_value, factory_hash, seller_auth_an)\n        let default_manager_output =\n          build_default_manager_output(\n            factory_policy_id: factory_hash,\n            manager_hash: manager_hash,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            seller_count: mint_seller_count,\n          )\n        // Trivial Assertions\n        expect\n          assert(\n            value.quantity_of(\n              factory_input_value,\n              factory_hash,\n              factory_auth_an,\n            ) == 1,\n            @\"Factory Input must be Legit!\",\n          )\n        expect assert(and {\n              // validate that new Factory UTxO datum must be followed by Linked List rule\n              // (old head, old tail) -> (old head, LP Token Name) and (LP Token Name, old tail)\n              // old head < LP Token Name < old tail\n              builtin.less_than_bytearray(current_head, lp_asset_name),\n              builtin.less_than_bytearray(lp_asset_name, current_tail),\n              // Factory Output must contains 1 Factory Token\n              value.quantity_of(f_out_head_value, factory_hash, factory_auth_an) == 1,\n              value.quantity_of(f_out_tail_value, factory_hash, factory_auth_an) == 1,\n              // Factory Output must contains only ADA and Factory Token\n              list.length(value.flatten(f_out_head_value)) == 2,\n              list.length(value.flatten(f_out_tail_value)) == 2,\n              // Head Factory Datum must be correct!\n              f_out_head_datum == InlineDatum(\n                FactoryDatum { head: current_head, tail: lp_asset_name },\n              ),\n              // Tail Factory Datum must be correct!\n              f_out_tail_datum == InlineDatum(\n                FactoryDatum { head: lp_asset_name, tail: current_tail },\n              ),\n              // Prevent Factory Output becoming heavy!\n              f_out_head_ref_script == None,\n              f_out_tail_ref_script == None,\n            }, @\"2 Factory Outputs must pay correctly!\")\n        // Assertions:\n        and {\n          // Manager Output must pay correctly!\n          manager_output == default_manager_output,\n          // Must prepare enough Sellers\n          mint_seller_count >= minimum_number_seller,\n          // Seller Outputs must pay correctly!\n          validation.validate_seller_outputs(\n            outputs: outputs,\n            factory_policy_id: factory_hash,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            seller_hash: seller_hash,\n            seller_count: mint_seller_count,\n          ),\n          // Treasury Output must pay correctly!\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_hash,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // Mint Value must be correct!\n          mint_value == get_minting_treasury(\n            factory_policy_id: factory_hash,\n            seller_count: mint_seller_count,\n          ),\n        }\n      }\n      CloseTreasury { .. } -> {\n        // finding exactly 2 Factory Inputs\n        expect [factory_input_1, factory_input_2] = factory_inputs\n        // finding exactly 1 Factory Output\n        expect [factory_output] = factory_outputs\n        // finding exactly 1 Treasury Input\n        expect [treasury_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  ..\n                },\n                ..\n              } = input\n              payment_credential == ScriptCredential(treasury_hash)\n            },\n          )\n        // extract some necessary data\n        expect Input {\n          output: Output {\n            datum: InlineDatum(factory_input_1_raw_datum),\n            value: factory_input_1_value,\n            ..\n          },\n          ..\n        } = factory_input_1\n        expect Input {\n          output: Output {\n            datum: InlineDatum(factory_input_2_raw_datum),\n            value: factory_input_2_value,\n            ..\n          },\n          ..\n        } = factory_input_2\n        expect Output {\n          value: factory_out_value,\n          datum: InlineDatum(factory_out_datum),\n          reference_script: factory_out_ref_script,\n          ..\n        } = factory_output\n        expect Input {\n          output: Output {\n            datum: InlineDatum(treasury_datum_raw),\n            value: treasury_in_value,\n            ..\n          },\n          ..\n        } = treasury_input\n        expect treasury_datum: TreasuryDatum = treasury_datum_raw\n        let TreasuryDatum {\n          base_asset: t_base_asset,\n          raise_asset: t_raise_asset,\n          owner,\n          is_cancelled,\n          reserve_raise,\n          total_penalty,\n          is_manager_collected,\n          ..\n        } = treasury_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        and {\n          // Auth Token Assertions:\n          value.quantity_of(\n            factory_input_1_value,\n            factory_hash,\n            factory_auth_an,\n          ) == 1,\n          value.quantity_of(\n            factory_input_2_value,\n            factory_hash,\n            factory_auth_an,\n          ) == 1,\n          value.quantity_of(factory_out_value, factory_hash, factory_auth_an) == 1,\n          value.quantity_of(treasury_in_value, factory_hash, treasury_auth_an) == 1,\n          // Remove Factory Linked List must be correct!\n          validate_factory_remove_node(\n            out_datum: factory_out_datum,\n            in_datum_1: factory_input_1_raw_datum,\n            in_datum_2: factory_input_2_raw_datum,\n            lp_asset_name: lp_asset_name,\n          ),\n          list.length(value.flatten(factory_out_value)) == 2,\n          factory_out_ref_script == None,\n          // LBE ID Assertions\n          t_base_asset == base_asset,\n          t_raise_asset == raise_asset,\n          value.from_minted_value(mint) == get_burning_treasury(\n            factory_policy_id: factory_hash,\n          ),\n          // authorize by owner\n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // LBE should already cancelled\n          is_cancelled,\n          // All Manager, Sellers must be collected!\n          is_manager_collected,\n          // All Orders have been executed.\n          reserve_raise == 0,\n          // All Penalty have been handled.\n          total_penalty == 0,\n        }\n      }\n      _ -> False\n    }\n  }\n\n  fn validate_factory_minting(redeemer: FactoryRedeemer, context: ScriptContext) {\n    let ScriptContext {\n      transaction: Transaction { inputs, outputs, redeemers, mint, .. },\n      purpose,\n    } = context\n    let mint_value = value.from_minted_value(mint)\n    when purpose is {\n      WithdrawFrom(stake_credential) -> {\n        expect Inline(ScriptCredential(factory_policy_id)) = stake_credential\n        and {\n          when value.flatten(mint_value) is {\n            [] ->\n              // Delegate validation logic to the Treasury Validator.\n              validation.has_spend(\n                inputs: inputs,\n                auth_policy_id: factory_policy_id,\n                auth_asset_name: treasury_auth_an,\n                validator_hash: treasury_hash,\n                redeemers: redeemers,\n                expected_redeemer: CollectOrders,\n              )\n            _ ->\n              // Delegate validation logic to the Treasury Validator.\n              validation.has_spend(\n                inputs: inputs,\n                auth_policy_id: factory_policy_id,\n                auth_asset_name: treasury_auth_an,\n                validator_hash: treasury_hash,\n                redeemers: redeemers,\n                expected_redeemer: RedeemOrders,\n              )\n          },\n          redeemer == ManageOrder,\n        }\n      }\n      Mint(factory_policy_id) ->\n        when redeemer is {\n          // Init Factory Linked List\n          Initialization ->\n            validate_initialization(\n              inputs: inputs,\n              outputs: outputs,\n              factory_policy_id: factory_policy_id,\n              out_ref: out_ref,\n              mint_value: mint_value,\n            )\n          // Delegate validation logic to the Treasury Validator.\n          CreateTreasury { .. } ->\n            has_spend_factory(inputs, factory_policy_id, redeemers, redeemer)\n          // Delegate validation logic to the Treasury Validator.\n          CloseTreasury { .. } ->\n            has_spend_factory(inputs, factory_policy_id, redeemers, redeemer)\n          // Collect Manager Transaction note:\n          //   1 Manager Token needs to be burned (trigger Factory Minting)\n          //   1 Manager Input needs to be spent\n          //   1 Treasury Input needs to be spent\n          //   1 Treasury Output needs to be paid\n          // Delegate validation logic to the Treasury Validator.\n          MintManager ->\n            // Delegate validation logic to the Treasury Validator.\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: treasury_auth_an,\n              validator_hash: treasury_hash,\n              redeemers: redeemers,\n              expected_redeemer: CollectManager,\n            )\n          MintSeller ->\n            // Delegate Logic to Manager Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: manager_auth_an,\n              validator_hash: manager_hash,\n              redeemers: redeemers,\n              expected_redeemer: AddSellers,\n            )\n          BurnSeller ->\n            // Delegate Logic to Manager Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: manager_auth_an,\n              validator_hash: manager_hash,\n              redeemers: redeemers,\n              expected_redeemer: CollectSellers,\n            )\n          MintOrder ->\n            // Delegate Logic to Seller Spend\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: seller_auth_an,\n              validator_hash: seller_hash,\n              redeemers: redeemers,\n              expected_redeemer: UsingSeller,\n            )\n          MintRedeemOrders ->\n            // Delegate validation logic to the Treasury Validator.\n            validation.has_spend(\n              inputs: inputs,\n              auth_policy_id: factory_policy_id,\n              auth_asset_name: treasury_auth_an,\n              validator_hash: treasury_hash,\n              redeemers: redeemers,\n              expected_redeemer: RedeemOrders,\n            )\n          _ -> False\n        }\n      _ -> False\n    }\n  }\n}\n\n// Validate Transaction Init Factory Linked List\n// Assertions:\n// - Spending @out_ref\n// - Mint 1 Factory Token\n// - Paying 1 Legitimate Factory Token\nfn validate_initialization(\n  inputs: List<Input>,\n  outputs: List<Output>,\n  factory_policy_id: PolicyId,\n  out_ref: OutputReference,\n  mint_value: Value,\n) -> Bool {\n  // Ensure transaction's outptus contain exactly 1 Factory Output \n  expect [\n    Output {\n      value: out_value,\n      datum,\n      reference_script: factory_reference_script,\n      ..\n    },\n  ] =\n    list.filter(\n      outputs,\n      fn(output) {\n        let Output { address: Address { payment_credential, .. }, .. } = output\n        payment_credential == ScriptCredential(factory_policy_id)\n      },\n    )\n  and {\n    factory_reference_script == None,\n    list.length(value.flatten(out_value)) == 2,\n    // Must spend @out_ref\n    list.any(\n      inputs,\n      fn(input) {\n        let Input { output_reference, .. } = input\n        output_reference == out_ref\n      },\n    ),\n    // Must mint 1 Factory Token\n    value.flatten(mint_value) == [(factory_policy_id, factory_auth_an, 1)],\n    // Factory Output must contain 1 Factory Token\n    value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n    // Factory Datum must be correct!\n    datum == InlineDatum(\n      FactoryDatum {\n        head: #\"00\",\n        tail: #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n      },\n    ),\n  }\n}\n\n// Transaction's spending Legit Factory Input base on `expected_redeemer`\nfn has_spend_factory(\n  inputs: List<Input>,\n  factory_hash: ValidatorHash,\n  redeemers: Dict<ScriptPurpose, Redeemer>,\n  expected_redeemer: FactoryRedeemer,\n) -> Bool {\n  // finding Legit Factory Inputs\n  let factory_inputs =\n    list.filter(\n      inputs,\n      fn(input) {\n        let Input {\n          output: Output {\n            address: Address { payment_credential, .. },\n            value: in_value,\n            ..\n          },\n          ..\n        } = input\n        and {\n          // input belongs Treasury Address\n          payment_credential == ScriptCredential(factory_hash),\n          // Factory Input must contains exactly 1 Factory Token\n          value.quantity_of(in_value, factory_hash, factory_auth_an) == 1,\n        }\n      },\n    )\n  // wrapping Factory Mint Redeemer -> Factory Spend Redeemer\n  let wrapper_redeemer = Some(make_wrapper_redeemer(expected_redeemer))\n  when expected_redeemer is {\n    CreateTreasury { .. } -> {\n      // CreateTreasury require only 1 Factory Input\n      expect [Input { output_reference, .. }] = factory_inputs\n      dict.get(redeemers, Spend(output_reference)) == wrapper_redeemer\n    }\n    CloseTreasury { .. } -> {\n      // CloseTreasury require 2 Factory Inputs as Head, Tail node\n      expect [\n        Input { output_reference: head_out_ref, .. },\n        Input { output_reference: tail_out_ref, .. },\n      ] = factory_inputs\n      and {\n        dict.get(redeemers, Spend(head_out_ref)) == wrapper_redeemer,\n        dict.get(redeemers, Spend(tail_out_ref)) == wrapper_redeemer,\n      }\n    }\n    _ -> False\n  }\n}\n\n// return Manager Output when creating Treasury\nfn build_default_manager_output(\n  factory_policy_id: ValidatorHash,\n  manager_hash: ValidatorHash,\n  base_asset: Asset,\n  raise_asset: Asset,\n  seller_count: Int,\n) -> Output {\n  let manager_address = credential.from_script(manager_hash)\n  // build default manager datum\n  let manager_datum =\n    ManagerDatum {\n      factory_policy_id,\n      base_asset,\n      raise_asset,\n      seller_count,\n      reserve_raise: 0,\n      total_penalty: 0,\n    }\n  // build default manager value\n  let manager_value =\n    value.from_lovelace(manager_minimum_ada)\n      |> value.add(factory_policy_id, manager_auth_an, 1)\n  Output {\n    address: manager_address,\n    value: manager_value,\n    datum: InlineDatum(manager_datum),\n    reference_script: None,\n  }\n}\n\n// Close LBE require remove 1 node from Factory Linked List\n// Logic remove node from Linked List is classic!\nfn validate_factory_remove_node(\n  // Factory Out Datum Raw\n  out_datum: Data,\n  // First Factory In Datum Raw\n  in_datum_1: Data,\n  // Second Factory In Datum Raw\n  in_datum_2: Data,\n  // LP Asset Name of LBE\n  lp_asset_name: AssetName,\n) -> Bool {\n  // sorting to find Head, Tail Node in term Factory Linked List\n  let (head_datum_raw, tail_datum_raw) =\n    utils.sort_two_consecutive_factory_datum(in_datum_1, in_datum_2)\n  expect head_datum: FactoryDatum = head_datum_raw\n  expect tail_datum: FactoryDatum = tail_datum_raw\n  expect factory_out_datum: FactoryDatum = out_datum\n  and {\n    factory_out_datum == FactoryDatum {\n      head: head_datum.head,\n      tail: tail_datum.tail,\n    },\n    head_datum.tail == lp_asset_name,\n    tail_datum.head == lp_asset_name,\n  }\n}\n\n// return Mint Value when creating new Treasury\nfn get_minting_treasury(factory_policy_id: PolicyId, seller_count: Int) -> Value {\n  value.from_asset(factory_policy_id, factory_auth_an, 1)\n    |> value.add(factory_policy_id, treasury_auth_an, 1)\n    |> value.add(factory_policy_id, manager_auth_an, 1)\n    |> value.add(factory_policy_id, seller_auth_an, seller_count)\n}\n\n// return Mint Value when close a Treasury\nfn get_burning_treasury(factory_policy_id: PolicyId) -> Value {\n  value.from_asset(factory_policy_id, factory_auth_an, -1)\n    |> value.add(factory_policy_id, treasury_auth_an, -1)\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/factory.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/interval.{Finite}\nuse aiken/list\nuse aiken/transaction.{\n  DatumHash, InlineDatum, Input, NoDatum, Output, ScriptContext, Spend,\n  Transaction, ValidityRange,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value.{PolicyId, Value, ada_asset_name, ada_policy_id}\nuse stableswap/pool_utils as poolutils\nuse stableswap/types.{\n  ApplyPool, Asset, DatumMap, Deposit, Exchange, OrderDatum, PoolDatum,\n  PoolParams, PoolRedeemer, UpdateAmpOrStakeCredential, Withdraw,\n  WithdrawAdminFee, WithdrawImbalance, WithdrawOneCoin,\n}\nuse stableswap/utils\n\nvalidator(params: PoolParams) {\n  fn validate_pool(\n    datum: PoolDatum,\n    redeemer: PoolRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, .. } = transaction\n    expect Spend(pool_ref) = purpose\n    expect Some(pool_input) = transaction.find_input(inputs, pool_ref)\n    when redeemer is {\n      ApplyPool(input_indexes, license_idx) -> {\n        expect !builtin.null_list(input_indexes)\n        validate_apply_pool(\n          params: params,\n          transaction: transaction,\n          pool_input: pool_input,\n          pool_in_datum: datum,\n          input_indexes: input_indexes,\n          license_idx: license_idx,\n        )\n      }\n      WithdrawAdminFee(admin_index, fee_to_index) ->\n        validate_withdraw_admin_fee(\n          params: params,\n          transaction: transaction,\n          pool_input: pool_input,\n          pool_in_datum: datum,\n          admin_index: admin_index,\n          fee_to_index: fee_to_index,\n        )\n      UpdateAmpOrStakeCredential(admin_index) ->\n        validate_update_amp_or_update_stake_credential(\n          params: params,\n          transaction: transaction,\n          pool_input: pool_input,\n          pool_in_datum: datum,\n          admin_index: admin_index,\n        )\n    }\n  }\n}\n\n// This function will trigger validation of ApplyPool redeemer\nfn validate_apply_pool(\n  params: PoolParams,\n  transaction: Transaction,\n  pool_input: Input,\n  pool_in_datum: PoolDatum,\n  input_indexes: List<Int>,\n  license_idx: Int,\n) -> Bool {\n  let Transaction { inputs, outputs, mint, validity_range, datums, .. } =\n    transaction\n  let PoolParams {\n    nft_asset,\n    lp_asset,\n    assets,\n    multiples,\n    fee,\n    admin_fee,\n    fee_denominator,\n    license_symbol,\n    maximum_deadline_range,\n    ..\n  } = params\n  let Input { output: pool_in_output, .. } = pool_input\n  let Output { address: pool_in_address, value: pool_in_value, .. } =\n    pool_in_output\n  let Address { payment_credential: pool_in_address_payment_credential, .. } =\n    pool_in_address\n\n  // - The validation requires having only a single Pool Input and a Pool Output in single batching transaction\n  // - The Pool Input and Output must have the same Address (both payment and stake credential part)\n  // - The idea here is that we will find the output having the same address with the spending input and \n  //   make sure that there's only one input and one output matching with pool's payment_credential\n  expect [pool_output] =\n    list.filter(\n      outputs,\n      fn(o) {\n        let Output { address: addr, .. } = o\n        addr == pool_in_address\n      },\n    )\n  let Output { value: pool_out_value, datum: pool_out_datum_raw, .. } =\n    pool_output\n\n  // Batching transaction only allow 1 Pool UTxO in the Inputs\n  expect [_] =\n    list.filter(\n      inputs,\n      fn(i) {\n        let Input { output: out, .. } = i\n        let Output { address: addr, .. } = out\n        let Address { payment_credential, .. } = addr\n        payment_credential == pool_in_address_payment_credential\n      },\n    )\n\n  expect pool_out_datum: PoolDatum =\n    when pool_out_datum_raw is {\n      InlineDatum(d) -> d\n      _ -> utils.must_find_script_datum(datums, pool_out_datum_raw)\n    }\n  let PoolDatum {\n    balances: pool_out_balances,\n    total_liquidity: pool_out_total_liquidity,\n    amp: pool_out_amp,\n    order_hash: pool_out_order_hash,\n  } = pool_out_datum\n\n  let PoolDatum {\n    balances: pool_in_balances,\n    total_liquidity: pool_in_total_liquidity,\n    amp: pool_in_amp,\n    order_hash: pool_in_order_hash,\n  } = pool_in_datum\n\n  // - Pool NFT is the part of Pool Value, which is known as Pool Identifier\n  // - Pool NFT must be existed on both Pool In/Output Value\n  let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } = nft_asset\n  expect and {\n      // Pool NFT must be existed in Pool Input and Output value\n      value.quantity_of(pool_in_value, nft_policy_id, nft_asset_name) == 1,\n      value.quantity_of(pool_out_value, nft_policy_id, nft_asset_name) == 1,\n      // Pool Value must only contains necessary token inside\n      check_pool_value(pool_out_value, assets),\n      // In @ApplyPool Redeemer, only balances and total_liquidity can be changed.\n      // The Amplification Coeffience & Order Hash must be unchanged. Amplification Coeffience can only be update via @UpdateAmp redeemer\n      pool_in_amp == pool_out_amp,\n      pool_in_order_hash == pool_out_order_hash,\n    }\n  let Input {\n    output: Output { address: batcher_address, value: batcher_value, .. },\n    ..\n  } = utils.list_at_index(inputs, license_idx)\n  let license_deadline = find_license_deadline(license_symbol, batcher_value)\n  let (start_valid_time_range, end_valid_time_range) =\n    find_posix_time_range(validity_range)\n\n  // - Only Batcher with valid license token can trigger @ApplyPool redeemer validation.  \n  // - A valid license token is the token with @tokenName (representing for expired milliseconds) \n  //   and must be within the time range from current_time to current_time + maximum_deadline_range\n  expect and {\n      license_deadline >= end_valid_time_range,\n      license_deadline <= start_valid_time_range + maximum_deadline_range,\n    }\n  let user_inputs =\n    list.filter(\n      inputs,\n      fn(input) {\n        let Input { output: out, .. } = input\n        let Output { address: addr, .. } = out\n        let Address { payment_credential: payment_cred, .. } = addr\n        when payment_cred is {\n          ScriptCredential(hash) -> hash == pool_in_order_hash\n          _ -> False\n        }\n      },\n    )\n\n  // Currently, transaction inputs will be sorted by TxId and TxIndex of UTxO.\n  // We have to calculate indexes of orders inputs sorting by the ASC created time\n  // on the off-chain and on-chain will sort the TxIns by the indexes\n  // Input Indexes in parameter will be reversed indexs of @user_inputs to reduce calculate step in On-Chain\n  let sorted_users_inputs =\n    list.foldl(\n      input_indexes,\n      [],\n      fn(idx, ips) { list.push(ips, utils.list_at_index(user_inputs, idx)) },\n    )\n  let user_outputs =\n    list.filter(\n      outputs,\n      fn(output) {\n        let Output { address: addr, .. } = output\n        addr != pool_in_address && addr != batcher_address\n      },\n    )\n\n  expect and {\n      // @input_indexes which is provided by Batcher must be unique array\n      utils.is_list_unique(input_indexes),\n      // @input_indexes and @user_inputs must have the same length\n      utils.compare_list_length(input_indexes, user_inputs),\n      // User Inputs and Outputs must have the same length\n      list.length(sorted_users_inputs) == list.length(user_outputs),\n      // Balances list in Pool In/Out datum must have the same length with Pool Assets list\n      utils.compare_list_length(assets, pool_in_balances),\n      utils.compare_list_length(assets, pool_out_balances),\n    }\n  let value_balances_in =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(pool_in_value, policy_id, asset_name)\n      },\n    )\n  let value_balances_out =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(pool_out_value, policy_id, asset_name)\n      },\n    )\n  let pool_out_state =\n    apply_orders(\n      datum_map: datums,\n      user_inputs: sorted_users_inputs,\n      user_outputs: user_outputs,\n      assets: assets,\n      multiples: multiples,\n      lp_asset: lp_asset,\n      amp: pool_in_amp,\n      fee: fee,\n      admin_fee: admin_fee,\n      fee_denominator: fee_denominator,\n      pool_state: (pool_in_balances, value_balances_in, pool_in_total_liquidity),\n    )\n  let Asset { policy_id: lp_policy_id, asset_name: lp_asset_name } = lp_asset\n  let total_delta_liquidity = pool_out_total_liquidity - pool_in_total_liquidity\n  let expected_mint =\n    value.zero()\n      |> value.add(lp_policy_id, lp_asset_name, total_delta_liquidity)\n  // Validate the Pool State (datum balances, value balances and total_liquidity) must be the same with the calculated amount after applying through all orders\n  and {\n    // value_balances_out == new_value_balances && pool_out_balances == new_datum_balances && pool_out_total_liquidity == new_total_liquidity\n    pool_out_state == (\n      pool_out_balances,\n      value_balances_out,\n      pool_out_total_liquidity,\n    ),\n    // Validate that @mint can only contains LP Token if having any order requires minting LP, otherwise, it must be empty\n    value.from_minted_value(mint) == expected_mint,\n  }\n}\n\n// This function will trigger validation of WithdrawAdminFee redeemer\nfn validate_withdraw_admin_fee(\n  params: PoolParams,\n  transaction: Transaction,\n  pool_input: Input,\n  pool_in_datum: PoolDatum,\n  admin_index: Int,\n  fee_to_index: Int,\n) -> Bool {\n  let Transaction { inputs, outputs, mint, datums, redeemers, .. } = transaction\n  let PoolParams { nft_asset, assets, admin_asset, .. } = params\n  let Input { output: pool_in_output, .. } = pool_input\n  let Output { address: pool_in_address, value: pool_in_value, .. } =\n    pool_in_output\n\n  // - The validation requires having only a single Pool Output\n  // - The Pool Input and Output must have the same Address (both payment and stake credential part)\n  expect [pool_output] =\n    list.filter(outputs, fn(o) { o.address == pool_in_address })\n  let Output { value: pool_out_value, datum: pool_out_datum_raw, .. } =\n    pool_output\n\n  expect pool_out_datum: PoolDatum =\n    when pool_out_datum_raw is {\n      InlineDatum(d) -> d\n      _ -> utils.must_find_script_datum(datums, pool_out_datum_raw)\n    }\n\n  let PoolDatum { balances: pool_in_balances, .. } = pool_in_datum\n\n  // - Pool NFT is the part of Pool Value, which is known as Pool Identifier\n  // - Pool NFT must be existed on both Pool In/Output Value\n  let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } = nft_asset\n\n  let value_balances_in =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(pool_in_value, policy_id, asset_name)\n      },\n    )\n  let value_balances_out =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(pool_out_value, policy_id, asset_name)\n      },\n    )\n  expect and {\n      // Having only one Pool Input in the transaction and make sure that it's an unique script in the input.\n      dict.size(redeemers) == 1,\n      // Pool NFT must be existed in Pool Input and Output value\n      value.quantity_of(pool_in_value, nft_policy_id, nft_asset_name) == 1,\n      value.quantity_of(pool_out_value, nft_policy_id, nft_asset_name) == 1,\n      // Pool Value must only contains necessary token inside\n      check_pool_value(pool_out_value, assets),\n      // Pool Datum must be unchanged in this redeemer\n      pool_in_datum == pool_out_datum,\n      // After Admin Fee amounts are withdrawn, Pool Value must be equals with Datum balances\n      value_balances_out == pool_in_balances,\n    }\n  // - Admin Fee amounts are the amounts belonged to Admin \n  // - These amounts are accumulated in Pool Value and \n  //   are calculated by the diff of Pool Value and Datum Balances \n  let admin_fee_amounts =\n    utils.zip_with(\n      value_balances_in,\n      pool_in_balances,\n      fn(val, bal) { val - bal },\n    )\n  let fee_to_output = utils.list_at_index(outputs, fee_to_index)\n  let withdrawal_amounts =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(fee_to_output.value, policy_id, asset_name)\n      },\n    )\n  // Admin can only withdraw the exact accumulated admin fee amounts\n  expect withdrawal_amounts == admin_fee_amounts\n  let admin_input = utils.list_at_index(inputs, admin_index)\n  let admin_value = admin_input.output.value\n  let Asset { policy_id: admin_policy_id, asset_name: admin_asset_name } =\n    admin_asset\n\n  and {\n    // Only Admin token can trigger this redeemer\n    value.quantity_of(admin_value, admin_policy_id, admin_asset_name) == 1,\n    // This Redeemer won't mint anything \n    value.is_zero(value.from_minted_value(mint)),\n  }\n}\n\n// This function will trigger validation of UpdateAmpOrStakeCredential redeemer\nfn validate_update_amp_or_update_stake_credential(\n  params: PoolParams,\n  transaction: Transaction,\n  pool_input: Input,\n  pool_in_datum: PoolDatum,\n  admin_index: Int,\n) -> Bool {\n  let Transaction { inputs, outputs, mint, datums, redeemers, .. } = transaction\n  let PoolParams { nft_asset, assets, admin_asset, .. } = params\n  let Input { output: pool_in_output, .. } = pool_input\n  let Output { address: pool_in_address, value: pool_in_value, .. } =\n    pool_in_output\n  let Address { payment_credential: pool_in_address_payment_credential, .. } =\n    pool_in_address\n\n  // - The validation requires having only a single Pool Output\n  // - The Pool Input and Output must have the same Address (only payment_credential part)\n  // - Admin can do either update AMP or update stake_credential in this redeemer\n  // - We also make sure that there's only one output matching with pool's payment_credential\n  expect [pool_output] =\n    list.filter(\n      outputs,\n      fn(o) {\n        let Output { address: addr, .. } = o\n        let Address { payment_credential, .. } = addr\n        payment_credential == pool_in_address_payment_credential\n      },\n    )\n  let Output { value: pool_out_value, datum: pool_out_datum_raw, .. } =\n    pool_output\n\n  expect pool_out_datum: PoolDatum =\n    when pool_out_datum_raw is {\n      InlineDatum(d) -> d\n      _ -> utils.must_find_script_datum(datums, pool_out_datum_raw)\n    }\n\n  let PoolDatum {\n    balances: pool_out_balances,\n    total_liquidity: pool_out_total_liquidity,\n    order_hash: pool_out_order_hash,\n    ..\n  } = pool_out_datum\n\n  let PoolDatum {\n    balances: pool_in_balances,\n    total_liquidity: pool_in_total_liquidity,\n    order_hash: pool_in_order_hash,\n    ..\n  } = pool_in_datum\n\n  // - Pool NFT is the part of Pool Value, which is known as Pool Identifier\n  // - Pool NFT must be existed on both Pool In/Output Value\n  let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } = nft_asset\n\n  expect and {\n      // Having only one Pool Input in the transaction and make sure that it's an unique script in the input.\n      dict.size(redeemers) == 1,\n      // Pool NFT must be existed in Pool Input and Output value\n      value.quantity_of(pool_in_value, nft_policy_id, nft_asset_name) == 1,\n      value.quantity_of(pool_out_value, nft_policy_id, nft_asset_name) == 1,\n      // Pool Value must only contains necessary token inside\n      check_pool_value(pool_out_value, assets),\n      // - Only Pool Datum's AMP can be updated, other fields must remain unchanged\n      // - TODO: Research the acceptable range which AMP can be changed\n      pool_in_balances == pool_out_balances,\n      pool_in_total_liquidity == pool_out_total_liquidity,\n      pool_in_order_hash == pool_out_order_hash,\n    }\n  let value_balances_in =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(pool_in_value, policy_id, asset_name)\n      },\n    )\n  let value_balances_out =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(pool_out_value, policy_id, asset_name)\n      },\n    )\n  // Pool Value must be unchanged in this redeemer\n  expect value_balances_in == value_balances_out\n  let admin_input = utils.list_at_index(inputs, admin_index)\n  let admin_value = admin_input.output.value\n  let Asset { policy_id: admin_policy_id, asset_name: admin_asset_name } =\n    admin_asset\n  and {\n    // Only Admin token can trigger this redeemer\n    value.quantity_of(admin_value, admin_policy_id, admin_asset_name) == 1,\n    // This Redeemer won't mint anything\n    value.is_zero(value.from_minted_value(mint)),\n  }\n}\n\nfn apply_orders(\n  datum_map: DatumMap,\n  user_inputs: List<Input>,\n  user_outputs: List<Output>,\n  assets: List<Asset>,\n  multiples: List<Int>,\n  lp_asset: Asset,\n  amp: Int,\n  fee: Int,\n  admin_fee: Int,\n  fee_denominator: Int,\n  pool_state: (List<Int>, List<Int>, Int),\n) -> (List<Int>, List<Int>, Int) {\n  when user_inputs is {\n    [] -> pool_state\n    [input, ..inputs] ->\n      when user_outputs is {\n        [] -> pool_state\n        [output, ..outputs] -> {\n          let Input {\n            output: Output {\n              value: order_in_value,\n              datum: order_in_datum_raw,\n              ..\n            },\n            ..\n          } = input\n          let Output {\n            value: order_out_value,\n            address: output_address,\n            datum: order_output_datum,\n            ..\n          } = output\n          expect order_datum: OrderDatum =\n            when order_in_datum_raw is {\n              InlineDatum(d) -> d\n              _ -> utils.must_find_script_datum(datum_map, order_in_datum_raw)\n            }\n          let OrderDatum {\n            receiver,\n            batcher_fee,\n            output_ada,\n            step: order_step,\n            receiver_datum_hash,\n            ..\n          } = order_datum\n          let is_valid_receiver_datum_hash =\n            when receiver_datum_hash is {\n              Some(datum_hash) -> {\n                expect DatumHash(output_datum_hash) = order_output_datum\n                output_datum_hash == datum_hash\n              }\n              None -> order_output_datum == NoDatum\n            }\n          // Verify Order Datum is correct\n          expect and {\n              receiver == output_address,\n              batcher_fee > 0,\n              output_ada > 0,\n              is_valid_receiver_datum_hash,\n            }\n          let new_state =\n            when order_step is {\n              Exchange(asset_in_index, asset_out_index, minimum_asset_out) -> {\n                expect minimum_asset_out > 0\n                validate_exchange(\n                  order_in_value: order_in_value,\n                  order_out_value: order_out_value,\n                  in_index: asset_in_index,\n                  out_index: asset_out_index,\n                  minimum_amount_out: minimum_asset_out,\n                  output_ada: output_ada,\n                  assets: assets,\n                  multiples: multiples,\n                  amp: amp,\n                  fee: fee,\n                  admin_fee: admin_fee,\n                  fee_denominator: fee_denominator,\n                  pool_state: pool_state,\n                )\n              }\n              Deposit(minimum_lp) -> {\n                expect minimum_lp > 0\n                validate_deposit(\n                  order_in_value: order_in_value,\n                  order_out_value: order_out_value,\n                  minimum_lp: minimum_lp,\n                  output_ada: output_ada,\n                  assets: assets,\n                  multiples: multiples,\n                  lp_asset: lp_asset,\n                  amp: amp,\n                  fee: fee,\n                  admin_fee: admin_fee,\n                  fee_denominator: fee_denominator,\n                  pool_state: pool_state,\n                )\n              }\n              Withdraw(minimum_amounts) -> {\n                expect utils.verify_non_negative_amounts(minimum_amounts)\n                validate_withdraw(\n                  order_in_value: order_in_value,\n                  order_out_value: order_out_value,\n                  minimum_amounts: minimum_amounts,\n                  output_ada: output_ada,\n                  assets: assets,\n                  lp_asset: lp_asset,\n                  pool_state: pool_state,\n                )\n              }\n              WithdrawImbalance(amounts_out) -> {\n                expect utils.verify_non_negative_amounts(amounts_out)\n                validate_withdraw_imbalance(\n                  order_in_value: order_in_value,\n                  order_out_value: order_out_value,\n                  amounts_out: amounts_out,\n                  output_ada: output_ada,\n                  assets: assets,\n                  multiples: multiples,\n                  lp_asset: lp_asset,\n                  amp: amp,\n                  fee: fee,\n                  admin_fee: admin_fee,\n                  fee_denominator: fee_denominator,\n                  pool_state: pool_state,\n                )\n              }\n              WithdrawOneCoin(asset_out_index, minimum_asset_out) -> {\n                expect minimum_asset_out > 0\n                validate_withdraw_one_coin(\n                  order_in_value: order_in_value,\n                  order_out_value: order_out_value,\n                  out_index: asset_out_index,\n                  minimum_amount_out: minimum_asset_out,\n                  output_ada: output_ada,\n                  assets: assets,\n                  multiples: multiples,\n                  lp_asset: lp_asset,\n                  amp: amp,\n                  fee: fee,\n                  admin_fee: admin_fee,\n                  fee_denominator: fee_denominator,\n                  pool_state: pool_state,\n                )\n              }\n            }\n          apply_orders(\n            datum_map: datum_map,\n            user_inputs: inputs,\n            user_outputs: outputs,\n            assets: assets,\n            multiples: multiples,\n            lp_asset: lp_asset,\n            amp: amp,\n            fee: fee,\n            admin_fee: admin_fee,\n            fee_denominator: fee_denominator,\n            pool_state: new_state,\n          )\n        }\n      }\n  }\n}\n\nfn calculate_deposit(\n  multiples: List<Int>,\n  fee: Int,\n  admin_fee: Int,\n  fee_denominator: Int,\n  assets: List<Asset>,\n  amount_ins: List<Int>,\n  amp: Int,\n  datum_balances: List<Int>,\n  value_balances: List<Int>,\n  total_liquidity: Int,\n) -> (List<Int>, List<Int>, Int) {\n  let new_value_balances =\n    utils.zip_with(value_balances, amount_ins, fn(balance, in) { balance + in })\n  if total_liquidity == 0 {\n    expect utils.verify_positive_ints(amount_ins)\n    let new_datum_balances =\n      utils.zip_with(\n        datum_balances,\n        amount_ins,\n        fn(balance, in) { balance + in },\n      )\n    let d1 = poolutils.get_d_mem(new_datum_balances, multiples, amp)\n    expect d1 > 0\n    (new_datum_balances, new_value_balances, d1)\n  } else {\n    let new_datum_balances_without_fee =\n      utils.zip_with(\n        datum_balances,\n        amount_ins,\n        fn(balance, in) { balance + in },\n      )\n    let d0 = poolutils.get_d_mem(datum_balances, multiples, amp)\n    let d1 = poolutils.get_d_mem(new_datum_balances_without_fee, multiples, amp)\n    let asset_length = list.length(assets)\n    let special_fee = fee * asset_length / ( 4 * ( asset_length - 1 ) )\n    let new_datum_balances_pair: List<(Int, Int)> =\n      utils.zip_with(\n        datum_balances,\n        new_datum_balances_without_fee,\n        fn(old_balance, new_balance) {\n          let ideal_balance = d1 * old_balance / d0\n          let difference = utils.abs(new_balance - ideal_balance)\n          let trading_fee_amount = special_fee * difference / fee_denominator\n          let admin_fee_amount =\n            trading_fee_amount * admin_fee / fee_denominator\n          (new_balance - admin_fee_amount, new_balance - trading_fee_amount)\n        },\n      )\n    let new_datum_balances =\n      list.map(\n        new_datum_balances_pair,\n        fn(pair) {\n          let (fst, _) = pair\n          fst\n        },\n      )\n    let new_datum_balances_with_trading_fee =\n      list.map(\n        new_datum_balances_pair,\n        fn(pair) {\n          let (_, snd) = pair\n          snd\n        },\n      )\n    expect utils.verify_positive_ints(new_datum_balances_with_trading_fee)\n    let d2 =\n      poolutils.get_d_mem(new_datum_balances_with_trading_fee, multiples, amp)\n    let lp_amount = total_liquidity * ( d2 - d0 ) / d0\n    expect d1 > d0\n    (new_datum_balances, new_value_balances, lp_amount)\n  }\n}\n\nfn validate_deposit(\n  order_in_value: Value,\n  order_out_value: Value,\n  minimum_lp: Int,\n  output_ada: Int,\n  assets: List<Asset>,\n  multiples: List<Int>,\n  lp_asset: Asset,\n  amp: Int,\n  fee: Int,\n  admin_fee: Int,\n  fee_denominator: Int,\n  pool_state: (List<Int>, List<Int>, Int),\n) -> (List<Int>, List<Int>, Int) {\n  let (datum_balances, value_balances, total_liquidity) = pool_state\n  let Asset { policy_id: lp_policy_id, asset_name: lp_asset_name } = lp_asset\n  let amount_ins =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(order_in_value, policy_id, asset_name)\n      },\n    )\n  let (new_datum_balances, new_value_balances, lp_amount) =\n    calculate_deposit(\n      multiples: multiples,\n      fee: fee,\n      admin_fee: admin_fee,\n      fee_denominator: fee_denominator,\n      assets: assets,\n      amount_ins: amount_ins,\n      amp: amp,\n      datum_balances: datum_balances,\n      value_balances: value_balances,\n      total_liquidity: total_liquidity,\n    )\n  let expected_order_out_value =\n    value.zero()\n      |> value.add(ada_policy_id, ada_asset_name, output_ada)\n      |> value.add(lp_policy_id, lp_asset_name, lp_amount)\n  expect and {\n      // Make sure that the actual lp amount will be minted must be greater than the minimum acceptance of this order\n      lp_amount >= minimum_lp,\n      // Verify the amount will be returned to users must be followed by the calculation above\n      expected_order_out_value == order_out_value,\n    }\n  (new_datum_balances, new_value_balances, total_liquidity + lp_amount)\n}\n\nfn validate_withdraw(\n  order_in_value: Value,\n  order_out_value: Value,\n  minimum_amounts: List<Int>,\n  output_ada: Int,\n  assets: List<Asset>,\n  lp_asset: Asset,\n  pool_state: (List<Int>, List<Int>, Int),\n) -> (List<Int>, List<Int>, Int) {\n  let (datum_balances, value_balances, total_liquidity) = pool_state\n  let Asset { policy_id: lp_policy_id, asset_name: lp_asset_name } = lp_asset\n  let withdrawal_lp_amount =\n    value.quantity_of(order_in_value, lp_policy_id, lp_asset_name)\n  let asset_amounts =\n    list.map(\n      datum_balances,\n      fn(balance) { balance * withdrawal_lp_amount / total_liquidity },\n    )\n  let new_datum_balances =\n    utils.zip_with(datum_balances, asset_amounts, fn(b1, b2) { b1 - b2 })\n  let new_value_balances =\n    utils.zip_with(value_balances, asset_amounts, fn(b1, b2) { b1 - b2 })\n  // Make sure that the actual assets amount must be greater than the minimum acceptance of this order\n  expect\n    utils.compare_list_with(\n      asset_amounts,\n      minimum_amounts,\n      fn(actual, expt) { actual >= expt },\n    )\n  let assets_amount_out =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(order_out_value, policy_id, asset_name)\n      },\n    )\n  let amount_ada_out =\n    value.quantity_of(\n      order_out_value,\n      value.ada_policy_id,\n      value.ada_asset_name,\n    )\n  // Verify the amount will be returned to users must be followed by the calculation above\n  expect assets_amount_out == asset_amounts && amount_ada_out == output_ada\n  let stable_assets_in_output_length =\n    list.reduce(\n      assets_amount_out,\n      0,\n      fn(n, am) {\n        if am > 0 {\n          n + 1\n        } else {\n          n\n        }\n      },\n    )\n  let expected_value_out_length = stable_assets_in_output_length + 1\n  // Verify the output will be returned to users must contains only necessary tokens\n  expect\n    list.length(value.flatten(order_out_value)) == expected_value_out_length\n  (\n    new_datum_balances,\n    new_value_balances,\n    total_liquidity - withdrawal_lp_amount,\n  )\n}\n\nfn calculate_exchange(\n  multiples: List<Int>,\n  fee: Int,\n  admin_fee: Int,\n  fee_denominator: Int,\n  amount_in: Int,\n  in_index: Int,\n  out_index: Int,\n  amp: Int,\n  datum_balances: List<Int>,\n  value_balances: List<Int>,\n) -> (Int, List<Int>, List<Int>) {\n  let multiple_balances =\n    utils.zip_with(\n      datum_balances,\n      multiples,\n      fn(balance, multiple) { balance * multiple },\n    )\n  let multiple_in = utils.list_at_index_step(multiples, in_index)\n  let multiple_out = utils.list_at_index_step(multiples, out_index)\n  let multiple_balances_in =\n    utils.list_at_index_step(multiple_balances, in_index)\n  let multiple_balances_out =\n    utils.list_at_index_step(multiple_balances, out_index)\n  let x = multiple_balances_in + amount_in * multiple_in\n  let y = poolutils.get_y(in_index, out_index, x, multiple_balances, amp)\n  let dy = multiple_balances_out - y\n  let dy_fee = dy * fee / fee_denominator\n  let dy_admin_fee = dy_fee * admin_fee / fee_denominator\n  let amount_out = ( dy - dy_fee ) / multiple_out\n  let new_datum_balance_in = x / multiple_in\n  let new_datum_balance_out = ( y + ( dy_fee - dy_admin_fee ) ) / multiple_out\n  let new_datum_balances =\n    list.indexed_map(\n      datum_balances,\n      fn(idx, balance) {\n        if idx == in_index {\n          new_datum_balance_in\n        } else if idx == out_index {\n          new_datum_balance_out\n        } else {\n          balance\n        }\n      },\n    )\n  let new_value_balances =\n    list.indexed_map(\n      value_balances,\n      fn(idx, balance) {\n        if idx == in_index {\n          balance + amount_in\n        } else if idx == out_index {\n          balance - amount_out\n        } else {\n          balance\n        }\n      },\n    )\n  (amount_out, new_datum_balances, new_value_balances)\n}\n\nfn validate_exchange(\n  order_in_value: Value,\n  order_out_value: Value,\n  in_index: Int,\n  out_index: Int,\n  minimum_amount_out: Int,\n  output_ada: Int,\n  assets: List<Asset>,\n  multiples: List<Int>,\n  amp: Int,\n  fee: Int,\n  admin_fee: Int,\n  fee_denominator: Int,\n  pool_state: (List<Int>, List<Int>, Int),\n) -> (List<Int>, List<Int>, Int) {\n  let (datum_balances, value_balances, total_liquidity) = pool_state\n  let Asset { policy_id: asset_in_policy_id, asset_name: asset_in_asset_name } =\n    utils.list_at_index_step(assets, in_index)\n  let Asset { policy_id: asset_out_policy_id, asset_name: asset_out_asset_name } =\n    utils.list_at_index_step(assets, out_index)\n  let amount_in =\n    value.quantity_of(order_in_value, asset_in_policy_id, asset_in_asset_name)\n  let (amount_out, new_datum_balances, new_value_balances) =\n    calculate_exchange(\n      multiples: multiples,\n      fee: fee,\n      admin_fee: admin_fee,\n      fee_denominator: fee_denominator,\n      amount_in: amount_in,\n      in_index: in_index,\n      out_index: out_index,\n      amp: amp,\n      datum_balances: datum_balances,\n      value_balances: value_balances,\n    )\n  let expected_order_out_value =\n    value.zero()\n      |> value.add(ada_policy_id, ada_asset_name, output_ada)\n      |> value.add(asset_out_policy_id, asset_out_asset_name, amount_out)\n  expect and {\n      amount_in > 0,\n      // Make sure that the actual asset amount must be greater than the minimum acceptance of this order\n      amount_out >= minimum_amount_out,\n      // Verify the amount will be returned to users must be followed by the calculation above and contains only necessary tokens\n      order_out_value == expected_order_out_value,\n    }\n  (new_datum_balances, new_value_balances, total_liquidity)\n}\n\nfn validate_withdraw_imbalance(\n  order_in_value: Value,\n  order_out_value: Value,\n  amounts_out: List<Int>,\n  output_ada: Int,\n  assets: List<Asset>,\n  multiples: List<Int>,\n  lp_asset: Asset,\n  amp: Int,\n  fee: Int,\n  admin_fee: Int,\n  fee_denominator: Int,\n  pool_state: (List<Int>, List<Int>, Int),\n) -> (List<Int>, List<Int>, Int) {\n  let (datum_balances, value_balances, total_liquidity) = pool_state\n  let Asset { policy_id: lp_policy_id, asset_name: lp_asset_name } = lp_asset\n  let new_datum_balances_without_fee =\n    utils.zip_with(\n      datum_balances,\n      amounts_out,\n      fn(balance, out) { balance - out },\n    )\n  expect utils.verify_positive_ints(new_datum_balances_without_fee)\n  let n = list.length(datum_balances)\n  let d0 = poolutils.get_d_mem(datum_balances, multiples, amp)\n  let d1 = poolutils.get_d_mem(new_datum_balances_without_fee, multiples, amp)\n  let special_fee = fee * n / ( 4 * ( n - 1 ) )\n  let new_datum_balances_pair =\n    utils.zip_with(\n      datum_balances,\n      new_datum_balances_without_fee,\n      fn(old_balance, new_balance) {\n        let ideal_balance = d1 * old_balance / d0\n        let difference = utils.abs(new_balance - ideal_balance)\n        let trading_fee_amount = special_fee * difference / fee_denominator\n        let admin_fee_amount = trading_fee_amount * admin_fee / fee_denominator\n        (new_balance - admin_fee_amount, new_balance - trading_fee_amount)\n      },\n    )\n  let new_datum_balances =\n    list.map(\n      new_datum_balances_pair,\n      fn(pair) {\n        let (fst, _) = pair\n        fst\n      },\n    )\n  let new_datum_balances_with_trading_fee =\n    list.map(\n      new_datum_balances_pair,\n      fn(pair) {\n        let (_, snd) = pair\n        snd\n      },\n    )\n  expect utils.verify_positive_ints(new_datum_balances_with_trading_fee)\n  let d2 =\n    poolutils.get_d_mem(new_datum_balances_with_trading_fee, multiples, amp)\n  let withdrawal_lp_amount =\n    value.quantity_of(order_in_value, lp_policy_id, lp_asset_name)\n  let necessary_lp_amount = total_liquidity * ( d0 - d2 ) / d0 + 1\n\n  // Make sure that the nessesary lp amount must be positive and less than the LP of this order\n  expect and {\n      necessary_lp_amount > 1,\n      withdrawal_lp_amount >= necessary_lp_amount,\n    }\n  let asset_amounts_out =\n    list.map(\n      assets,\n      fn(asset) {\n        let Asset { policy_id, asset_name } = asset\n        value.quantity_of(order_out_value, policy_id, asset_name)\n      },\n    )\n  let amount_ada_out =\n    value.quantity_of(\n      order_out_value,\n      value.ada_policy_id,\n      value.ada_asset_name,\n    )\n  let change_lp_amount =\n    value.quantity_of(order_out_value, lp_policy_id, lp_asset_name)\n\n  // Verify the amount will be returned to users must be followed by the calculation above\n  expect and {\n      amounts_out == asset_amounts_out,\n      amount_ada_out == output_ada,\n      change_lp_amount == withdrawal_lp_amount - necessary_lp_amount,\n    }\n  let new_value_balances =\n    utils.zip_with(\n      value_balances,\n      amounts_out,\n      fn(balance, out) { balance - out },\n    )\n  let stable_assets_in_output_length =\n    list.reduce(\n      asset_amounts_out,\n      0,\n      fn(n, am) {\n        if am > 0 {\n          n + 1\n        } else {\n          n\n        }\n      },\n    )\n  let expected_value_out_length =\n    if change_lp_amount > 0 {\n      stable_assets_in_output_length + 2\n    } else {\n      stable_assets_in_output_length + 1\n    }\n\n  // Verify the output will be returned to users must contains only necessary tokens\n  expect\n    list.length(value.flatten(order_out_value)) == expected_value_out_length\n  (\n    new_datum_balances,\n    new_value_balances,\n    total_liquidity - necessary_lp_amount,\n  )\n}\n\nfn calculate_withdraw_one_coin(\n  multiples: List<Int>,\n  fee: Int,\n  fee_denominator: Int,\n  amount_lp_in: Int,\n  out_index: Int,\n  amp: Int,\n  datum_balances: List<Int>,\n  total_liquidity: Int,\n) -> (Int, Int) {\n  let multiple_balances =\n    utils.zip_with(\n      datum_balances,\n      multiples,\n      fn(balance, multiple) { balance * multiple },\n    )\n  let d0 = poolutils.get_d(multiple_balances, amp)\n  let d1 = d0 - amount_lp_in * d0 / total_liquidity\n  let new_y = poolutils.get_y_d(out_index, multiple_balances, amp, d1)\n  let multiple_out = utils.list_at_index_step(multiples, out_index)\n  let out_amount_without_fee =\n    ( utils.list_at_index_step(multiple_balances, out_index) - new_y ) / multiple_out\n  let assets_length = list.length(datum_balances)\n  let special_fee = fee * assets_length / ( 4 * ( assets_length - 1 ) )\n  let multiple_balances_reduced =\n    list.indexed_map(\n      multiple_balances,\n      fn(idx, old_bal) {\n        let diff =\n          if idx == out_index {\n            old_bal * d1 / d0 - new_y\n          } else {\n            old_bal - old_bal * d1 / d0\n          }\n        old_bal - special_fee * diff / fee_denominator\n      },\n    )\n  let out_amount =\n    (\n      utils.list_at_index_step(multiple_balances_reduced, out_index) - poolutils.get_y_d(\n        out_index,\n        multiple_balances_reduced,\n        amp,\n        d1,\n      ) - 1\n    ) / multiple_out\n  (out_amount, out_amount_without_fee - out_amount)\n}\n\nfn validate_withdraw_one_coin(\n  order_in_value: Value,\n  order_out_value: Value,\n  out_index: Int,\n  minimum_amount_out: Int,\n  output_ada: Int,\n  assets: List<Asset>,\n  multiples: List<Int>,\n  lp_asset: Asset,\n  amp: Int,\n  fee: Int,\n  admin_fee: Int,\n  fee_denominator: Int,\n  pool_state: (List<Int>, List<Int>, Int),\n) -> (List<Int>, List<Int>, Int) {\n  let (datum_balances, value_balances, total_liquidity) = pool_state\n  let asset_out = utils.list_at_index_step(assets, out_index)\n  let Asset { policy_id: lp_policy_id, asset_name: lp_asset_name } = lp_asset\n  let amount_lp_in =\n    value.quantity_of(order_in_value, lp_policy_id, lp_asset_name)\n  expect amount_lp_in > 0\n  let (amount_out, fee_amount) =\n    calculate_withdraw_one_coin(\n      multiples: multiples,\n      fee: fee,\n      fee_denominator: fee_denominator,\n      amount_lp_in: amount_lp_in,\n      out_index: out_index,\n      amp: amp,\n      datum_balances: datum_balances,\n      total_liquidity: total_liquidity,\n    )\n  // Make sure that the actual asset amount must be greater than the minimum acceptance of this order\n  expect amount_out >= minimum_amount_out\n  let Asset { policy_id: asset_out_policy_id, asset_name: asset_out_asset_name } =\n    asset_out\n  // Verify the amount will be returned to users must be followed by the calculation above\n  let expected_order_out_value =\n    value.zero()\n      |> value.add(ada_policy_id, ada_asset_name, output_ada)\n      |> value.add(asset_out_policy_id, asset_out_asset_name, amount_out)\n  let admin_fee_amount = fee_amount * admin_fee / fee_denominator\n  let new_datum_balances =\n    list.indexed_map(\n      datum_balances,\n      fn(idx, old_bal) {\n        if idx == out_index {\n          old_bal - amount_out - admin_fee_amount\n        } else {\n          old_bal\n        }\n      },\n    )\n  let new_value_balances =\n    list.indexed_map(\n      value_balances,\n      fn(idx, old_bal) {\n        if idx == out_index {\n          old_bal - amount_out\n        } else {\n          old_bal\n        }\n      },\n    )\n  // Verify the output will be returned to users must contains only necessary tokens\n  expect order_out_value == expected_order_out_value\n  (new_datum_balances, new_value_balances, total_liquidity - amount_lp_in)\n}\n\nfn find_posix_time_range(time_rage: ValidityRange) -> (Int, Int) {\n  expect Finite(t1) = time_rage.lower_bound.bound_type\n  expect Finite(t2) = time_rage.upper_bound.bound_type\n  (t1, t2)\n}\n\n// This function will verify Pool Value elements\n// Pool Value only includes minimum ADA, Pool NFT and Stable Assets (if have) \nfn check_pool_value(val: Value, assets: List<Asset>) -> Bool {\n  let flatten_val = value.flatten(val)\n  let stable_asset_num =\n    list.reduce(\n      assets,\n      0,\n      fn(n, asset) {\n        let Asset { policy_id, asset_name } = asset\n        let c =\n          if value.quantity_of(val, policy_id, asset_name) > 0 {\n            1\n          } else {\n            0\n          }\n        n + c\n      },\n    )\n  list.length(flatten_val) == stable_asset_num + 2\n}\n\nfn find_license_deadline(license_symbol: PolicyId, val: Value) -> Int {\n  expect [(tn, am)] =\n    val\n      |> value.tokens(license_symbol)\n      |> dict.to_list()\n  expect am == 1\n  utils.bytearray_to_int(tn)\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/pool_validator.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\n/// The order validator is a basic order destined for execution against a pool\n///\n/// Other orders can be implemented as well, by using the same datum format, and\n/// updating the scoopers to know how to index and include these orders\n/// This would likely be done via a DAO vote.\n///\n/// The validator is parameterized by a specific stake script, more on that below.\n///\n/// Has two possible execution paths:\n/// - Cancel: the \"owner\" signs the transaction, allowing the UTXO be spent; we impose\n///   no additional constraints, so this could also be used to update an order by\n///   spending it back into the same script.\n///   Note: we use sundae.multisig, which allows multisig orders, or even orders that can\n///   be \"cancelled\" by a script!\n///\n/// - Scoop: the order is processed as a batch against a pool.\n///   Instead of re-checking the conditions in every single script, we instead use a clever trick\n///   We look for the stake_script_hash in the list of withdrawals!\n///   This means that the stake script must run, and it can always run, because withdrawals of 0 tokens are allowed!\n///   That stake_script then checks that a pool NFT is present on the UTXO, where most of the subtle and important logic is implemented.\nvalidator order(stake_script_hash: ScriptHash) {\n  // For the purposes of spending the order, we don't care what the datum is, so avoid deserializing it\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        // We only expect the datum here, to avoid any related costs in the other branch, which doesn't need it\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        // Defer to sundae.multisig\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              // TODO: we could make this more efficient by CBOR encoding the `Script` into the `stake_script_hash` parameter\n              // or perhaps even the whole withdrawal list to compare it all at once!\n              // and just doing a direct equaltiy comparison. Since this runs for each order, this could represent significant savings!\n              Script(script) -> acc || script == stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use types/order.{OrderDatum}\n\nvalidator documentation {\n  spend(_d: Option<OrderDatum>, _r: Data, _o: Data, _transaction: Data) {\n    True\n  }\n\n  else(_) {\n    fail\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/documentation.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference == output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> False\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 1)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/two_way_swap/types.{ \n  BeaconRedeemer,\n  UpdateSwaps,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  TakeAsset1,\n  TakeAsset2,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/two_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      // Take asset1 and deposit asset2. It compares the input value against the corresponding output\n      // value to determine the value flux.\n      TakeAsset1 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset1_price` denominator > 0\n        //      b) `asset1_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          False // Not taking asset2.\n        )\n      }\n\n      // Take asset2 and deposit asset1. It compares the input value against the corresponding output\n      // value to determine the value flux. \n      TakeAsset2 -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Asset1 taken * price <= Asset2 given\n        // 4) Only Asset1 leaves and only Asset2 is deposited. Ada can always be deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `asset2_price` denominator > 0\n        //      b) `asset2_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          asset1_id,\n          asset1_name,\n          asset1_beacon,\n          asset2_id,\n          asset2_name,\n          asset2_beacon,\n          asset1_price,\n          asset2_price,\n          outputs,\n          True // Taking asset2.\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, asset1 beacon, and asset2 beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == sha2_256(asset1_id ++ asset1_name ++ asset2_id ++ asset2_name)\n        //      c) `asset1_id` == policy id of asset1 for that trading pair.\n        //      d) `asset1_name` == asset name of asset1 for that trading_pair.\n        //      e) `asset1_beacon` == sha2_256(asset1_id ++ asset1_name).\n        //      f) `asset2_id` == policy id of asset2 for that trading_pair.\n        //      g) `asset2_name` == asset name of asset2 for that trading_pair.\n        //      h) `asset2_beacon` == sha2_256(asset2_id ++ asset2_name).\n        //      i) `asset1_price` denominator > 0\n        //      j) `asset1_price` numerator > 0\n        //      k) `asset2_price` denominator > 0\n        //      l) `asset2_price` numerator > 0\n        //      m) asset1 < asset2\n        //\n        // The validator assumes the trading pairs are sorted which is why asset1 must be less than\n        // asset2. Asset1 and asset2 cannot be the same asset.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/two_way_swap.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  usdm_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.quantity_of(\n                output.value,\n                assets.ada_policy_id,\n                assets.ada_asset_name,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let amount =\n          assets.quantity_of(\n            pos_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          ) / decimals\n        expect amount != 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse aiken/primitive/string\nuse bodega/test_constants.{\n  false_position_name, license_symbol, maximum_deadline_range, oracle_nft_asset,\n  oracle_nft_id, oracle_nft_name, pos_user_pkh, position_script_hash,\n  pred_nft_id, pred_nft_name, prediction_nft_asset, share_policy_id,\n  treasury_script_hash, true_position_name, usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, OracleDatum, PositionDatum, PredApply, PredReward,\n  PredWithdrawAdminFee, PredictionDatum, PredictionParams, PredictionRedeemer,\n  RewardPos, SideTrue,\n}\nuse bodega/utils.{decimals, find_license_deadline, find_posix_time_range}\nuse cardano/address.{from_script, from_verification_key}\nuse cardano/assets.{flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, NoDatum, Output, OutputReference, Transaction,\n}\n\nvalidator predictions(params: PredictionParams) {\n  spend(\n    option_datum: Option<PredictionDatum>,\n    redeemer: PredictionRedeemer,\n    _own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    expect Some(datum) = option_datum\n    let own_input_datum: PredictionDatum = datum\n    when redeemer is {\n      PredApply { own_input_idx, own_output_idx, license_idx, pos_indices } -> {\n        let Transaction { inputs, outputs, validity_range, .. } = self\n        expect Some(Input { output: Output { value: batcher_value, .. }, .. }) =\n          list.at(inputs, license_idx)\n        let license_deadline =\n          find_license_deadline(params.license_symbol, batcher_value)\n        let (start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect and {\n            license_deadline >= end_valid_time_range,\n            license_deadline <= start_valid_time_range + params.maximum_deadline_range,\n          }\n        expect Some(own_input) = list.at(inputs, own_input_idx)\n        expect Some(own_output) = list.at(outputs, own_output_idx)\n        expect InlineDatum(own_output_inline_datum) = own_output.datum\n        expect own_output_datum: PredictionDatum = own_output_inline_datum\n        expect\n          assets.quantity_of(\n            own_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect\n          assets.quantity_of(\n            own_output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        let (true_shares, false_shares, batch_size, are_correct_positions) =\n          list.foldl(\n            pos_indices,\n            (0, 0, 0, True),\n            fn(curr, acc) {\n              let (in_idx, out_idx) = curr\n              let (num_true, num_false, bs, are_correct) = acc\n              expect Some(in) = list.at(inputs, in_idx)\n              expect Some(out) = list.at(outputs, out_idx)\n              expect InlineDatum(pos_inline_datum) = in.output.datum\n              expect pos_datum: PositionDatum = pos_inline_datum\n              expect\n                from_verification_key(pos_datum.pos_user_pkh) == out.address\n              let num_true_shares =\n                assets.quantity_of(\n                  in.output.value,\n                  params.share_policy_id,\n                  own_input_datum.true_position_name,\n                )\n              let num_false_shares =\n                assets.quantity_of(\n                  in.output.value,\n                  params.share_policy_id,\n                  own_input_datum.false_position_name,\n                )\n              if num_true_shares > 0 {\n                expect\n                  [\n                    (\n                      assets.ada_policy_id,\n                      assets.ada_asset_name,\n                      own_output_datum.envelope_amount,\n                    ),\n                    (\n                      params.share_policy_id,\n                      own_input_datum.true_position_name,\n                      num_true_shares,\n                    ),\n                  ] == assets.flatten(out.value)\n              } else {\n                expect\n                  [\n                    (\n                      assets.ada_policy_id,\n                      assets.ada_asset_name,\n                      own_output_datum.envelope_amount,\n                    ),\n                    (\n                      params.share_policy_id,\n                      own_input_datum.false_position_name,\n                      num_false_shares,\n                    ),\n                  ] == assets.flatten(out.value)\n              }\n\n              expect\n                num_true_shares == assets.quantity_of(\n                  out.value,\n                  params.share_policy_id,\n                  own_input_datum.true_position_name,\n                )\n              expect\n                num_false_shares == assets.quantity_of(\n                  out.value,\n                  params.share_policy_id,\n                  own_input_datum.false_position_name,\n                )\n              let num_out_assets = list.length(assets.flatten(out.value))\n              (\n                num_true + num_true_shares,\n                num_false + num_false_shares,\n                bs + 1,\n                num_out_assets == 2 && are_correct,\n              )\n            },\n          )\n        let flatten_own_output_value = assets.flatten(own_output.value)\n        expect list.length(flatten_own_output_value) <= 3\n        let input_usdm =\n          assets.quantity_of(\n            own_input.output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          )\n        let output_usdm =\n          assets.quantity_of(\n            own_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          )\n        let input_lovelace =\n          assets.quantity_of(\n            own_input.output.value,\n            assets.ada_policy_id,\n            assets.ada_asset_name,\n          )\n        let output_lovelace =\n          assets.quantity_of(\n            own_output.value,\n            assets.ada_policy_id,\n            assets.ada_asset_name,\n          )\n        expect\n          input_usdm + ( true_shares + false_shares ) * decimals <= output_usdm\n        expect\n          input_lovelace + batch_size * own_input_datum.admin_fee <= output_lovelace\n        expect\n          own_input_datum.true_position_amount + true_shares == own_output_datum.true_position_amount\n        expect\n          own_input_datum.false_position_amount + false_shares == own_output_datum.false_position_amount\n\n        correct_own_output_datum(own_input_datum, own_output_datum) && own_input.output.address == own_output.address && are_correct_positions\n      }\n      PredReward { own_input_idx, own_output_idx, license_idx, pos_indices } -> {\n        let Transaction {\n          inputs,\n          outputs,\n          mint,\n          reference_inputs,\n          validity_range,\n          ..\n        } = self\n        expect Some(own_input) = list.at(inputs, own_input_idx)\n        expect Some(own_output) = list.at(outputs, own_output_idx)\n        expect Some(Input { output: Output { value: batcher_value, .. }, .. }) =\n          list.at(inputs, license_idx)\n        let license_deadline =\n          find_license_deadline(params.license_symbol, batcher_value)\n        let (start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect and {\n            license_deadline >= end_valid_time_range,\n            license_deadline <= start_valid_time_range + params.maximum_deadline_range,\n          }\n        expect InlineDatum(own_output_inline_datum) = own_output.datum\n        expect own_output_datum: PredictionDatum = own_output_inline_datum\n        expect\n          assets.quantity_of(\n            own_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect\n          assets.quantity_of(\n            own_output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect Some(oracle_ref_input) =\n          reference_inputs\n            |> list.find(\n                fn(input) {\n                  assets.quantity_of(\n                    input.output.value,\n                    params.oracle_nft.policy_id,\n                    params.oracle_nft.asset_name,\n                  ) == 1\n                },\n              )\n        expect InlineDatum(oracle_inline_datum) = oracle_ref_input.output.datum\n        expect oracle_datum: OracleDatum = oracle_inline_datum\n        let (total_winning, total_losing) =\n          if oracle_datum.position_name == own_output_datum.true_position_name {\n            (\n              own_output_datum.true_position_amount,\n              own_output_datum.false_position_amount,\n            )\n          } else {\n            (\n              own_output_datum.false_position_amount,\n              own_output_datum.true_position_amount,\n            )\n          }\n        let (num_shares, total_reward, does_reward_correctly) =\n          list.foldl(\n            pos_indices,\n            (0, 0, True),\n            fn(curr, acc) {\n              let (in_idx, out_idx) = curr\n              let (ns, sum_reward, reward_correctly) = acc\n              expect Some(in) = list.at(inputs, in_idx)\n              expect Some(out) = list.at(outputs, out_idx)\n              expect InlineDatum(pos_inline_datum) = in.output.datum\n              expect pos_datum: PositionDatum = pos_inline_datum\n              expect\n                from_verification_key(pos_datum.pos_user_pkh) == out.address\n              let curr_shares =\n                assets.quantity_of(\n                  in.output.value,\n                  params.share_policy_id,\n                  oracle_datum.position_name,\n                )\n              expect curr_shares > 0\n              let reward_amount =\n                curr_shares * ( total_winning + total_losing ) * decimals / total_winning\n              (\n                ns + curr_shares,\n                sum_reward + reward_amount,\n                reward_correctly && assets.quantity_of(\n                  out.value,\n                  params.usdm_asset.policy_id,\n                  params.usdm_asset.asset_name,\n                ) == reward_amount,\n              )\n            },\n          )\n        let flatten_own_output_value = assets.flatten(own_output.value)\n        expect list.length(flatten_own_output_value) <= 3\n        let input_usdm =\n          assets.quantity_of(\n            own_input.output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          )\n        let output_usdm =\n          assets.quantity_of(\n            own_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          )\n        let input_lovelace =\n          assets.quantity_of(\n            own_input.output.value,\n            assets.ada_policy_id,\n            assets.ada_asset_name,\n          )\n        let output_lovelace =\n          assets.quantity_of(\n            own_output.value,\n            assets.ada_policy_id,\n            assets.ada_asset_name,\n          )\n        expect input_usdm == output_usdm + total_reward\n        expect input_lovelace <= output_lovelace\n        expect\n          [(params.share_policy_id, oracle_datum.position_name, -num_shares)] == flatten(\n            mint,\n          )\n        does_reward_correctly\n      }\n      PredWithdrawAdminFee {\n        own_input_idx,\n        own_output_idx,\n        license_idx,\n        treasury_out_idx,\n      } -> {\n        let Transaction { inputs, outputs, validity_range, .. } = self\n        expect Some(own_input) = list.at(inputs, own_input_idx)\n        expect Some(own_output) = list.at(outputs, own_output_idx)\n        expect Some(Input { output: Output { value: batcher_value, .. }, .. }) =\n          list.at(inputs, license_idx)\n        let license_deadline =\n          find_license_deadline(params.license_symbol, batcher_value)\n        let (start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect and {\n            license_deadline >= end_valid_time_range,\n            license_deadline <= start_valid_time_range + params.maximum_deadline_range,\n          }\n        expect InlineDatum(own_output_inline_datum) = own_output.datum\n        expect own_output_datum: PredictionDatum = own_output_inline_datum\n        expect own_input_datum == own_output_datum\n        expect\n          assets.quantity_of(\n            own_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect\n          assets.quantity_of(\n            own_output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect Some(Output {\n          address: treasury_address,\n          value: treasury_value,\n          ..\n        }) = list.at(outputs, treasury_out_idx)\n        expect from_script(params.treasury_script_hash) == treasury_address\n        let flatten_own_output_value = assets.flatten(own_output.value)\n        expect list.length(flatten_own_output_value) <= 3\n        let input_usdm =\n          assets.quantity_of(\n            own_input.output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          )\n        let output_usdm =\n          assets.quantity_of(\n            own_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          )\n        let input_lovelace =\n          assets.quantity_of(\n            own_input.output.value,\n            assets.ada_policy_id,\n            assets.ada_asset_name,\n          )\n        let output_lovelace =\n          assets.quantity_of(\n            own_output.value,\n            assets.ada_policy_id,\n            assets.ada_asset_name,\n          )\n        let treasury_lovelace =\n          assets.quantity_of(\n            treasury_value,\n            assets.ada_policy_id,\n            assets.ada_asset_name,\n          )\n        expect input_usdm == output_usdm\n        input_lovelace <= output_lovelace + treasury_lovelace\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn correct_own_output_datum(\n  in_datum: PredictionDatum,\n  out_datum: PredictionDatum,\n) -> Bool {\n  in_datum.true_position_name == out_datum.true_position_name && in_datum.false_position_name == out_datum.false_position_name && in_datum.dead_line == out_datum.dead_line && in_datum.position_script_hash == out_datum.position_script_hash && in_datum.admin_fee == out_datum.admin_fee && in_datum.envelope_amount == out_datum.envelope_amount\n}\n\ntest predictions__spend_apply() {\n  let params =\n    PredictionParams {\n      prediction_nft: prediction_nft_asset,\n      oracle_nft: oracle_nft_asset,\n      share_policy_id,\n      usdm_asset,\n      license_symbol,\n      maximum_deadline_range,\n      treasury_script_hash,\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pred_out_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 10,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let pred_out =\n    Output {\n      address: from_script(#\"\"),\n      value: assets.from_lovelace(2_200_000)\n        |> assets.add(pred_nft_id, pred_nft_name, 1)\n        |> assets.add(usdm_id, usdm_name, 10 * decimals),\n      datum: InlineDatum(pred_out_datum),\n      reference_script: None,\n    }\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 10)\n          |> assets.add(usdm_id, usdm_name, 10 * decimals),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let user_pos_out =\n    Output {\n      address: from_verification_key(pos_user_pkh),\n      value: assets.from_lovelace(2_000_000)\n        |> assets.add(share_policy_id, true_position_name, 10),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let license_input =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"07f157faf99b850b4971034feee28d\",\n        output_index: 0,\n      },\n      output: Output {\n        address: from_script(#\"12\"),\n        value: assets.add(\n          assets.zero,\n          license_symbol,\n          string.to_bytearray(@\"1727715600000\"),\n          1,\n        ),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n  let license_output =\n    Output {\n      address: from_script(#\"12\"),\n      value: assets.add(\n        assets.zero,\n        license_symbol,\n        string.to_bytearray(@\"1727715600000\"),\n        1,\n      ),\n      datum: NoDatum,\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input, license_input],\n      reference_inputs: [],\n      outputs: [pred_out, user_pos_out, license_output],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let pred_redeemer =\n    PredApply {\n      own_input_idx: 0,\n      own_output_idx: 0,\n      license_idx: 2,\n      pos_indices: [(1, 1)],\n    }\n  predictions.spend(params, Some(pred_datum), pred_redeemer, own_ref, tx)\n}\n\ntest predictions__spend_reward() {\n  let params =\n    PredictionParams {\n      prediction_nft: prediction_nft_asset,\n      oracle_nft: oracle_nft_asset,\n      share_policy_id,\n      usdm_asset,\n      license_symbol,\n      maximum_deadline_range,\n      treasury_script_hash,\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 6_000,\n      false_position_amount: 4_000,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(usdm_id, usdm_name, 10_000 * decimals)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pred_out_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 6_000,\n      false_position_amount: 4_000,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let pred_out =\n    Output {\n      address: from_script(#\"\"),\n      value: assets.from_lovelace(2_200_000)\n        |> assets.add(pred_nft_id, pred_nft_name, 1)\n        |> assets.add(usdm_id, usdm_name, 5_000 * decimals),\n      datum: InlineDatum(pred_out_datum),\n      reference_script: None,\n    }\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 3_000,\n      pos_batcher_fee: 300_000,\n      pos_type: RewardPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 3_000),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let user_pos_out =\n    Output {\n      address: from_verification_key(pos_user_pkh),\n      value: assets.from_lovelace(2_000_000)\n        |> assets.add(usdm_id, usdm_name, 5_000 * decimals),\n      datum: NoDatum,\n      reference_script: None,\n    }\n  let license_input =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"07f157faf99b850b4971034feee28d\",\n        output_index: 0,\n      },\n      output: Output {\n        address: from_script(#\"12\"),\n        value: assets.add(\n          assets.zero,\n          license_symbol,\n          string.to_bytearray(@\"1727715600000\"),\n          1,\n        ),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n  let license_output =\n    Output {\n      address: from_script(#\"12\"),\n      value: assets.add(\n        assets.zero,\n        license_symbol,\n        string.to_bytearray(@\"1727715600000\"),\n        1,\n      ),\n      datum: NoDatum,\n      reference_script: None,\n    }\n  let oracle_datum = OracleDatum { position_name: true_position_name }\n  let oracle_ref =\n    OutputReference {\n      transaction_id: #\"f99b85b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let oracle_input =\n    Input {\n      output_reference: oracle_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(oracle_nft_id, oracle_nft_name, 1),\n        datum: InlineDatum(oracle_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, -3000)\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input, license_input],\n      reference_inputs: [oracle_input],\n      outputs: [pred_out, user_pos_out, license_output],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let pred_redeemer =\n    PredReward {\n      own_input_idx: 0,\n      own_output_idx: 0,\n      license_idx: 2,\n      pos_indices: [(1, 1)],\n    }\n  predictions.spend(params, Some(pred_datum), pred_redeemer, own_ref, tx)\n}\n\ntest predictions__spend_withdraw_admin_fee() {\n  let params =\n    PredictionParams {\n      prediction_nft: prediction_nft_asset,\n      oracle_nft: oracle_nft_asset,\n      share_policy_id,\n      usdm_asset,\n      license_symbol,\n      maximum_deadline_range,\n      treasury_script_hash,\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 6_000,\n      false_position_amount: 4_000,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(20_002_200_000)\n          |> assets.add(usdm_id, usdm_name, 10_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pred_out_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 6_000,\n      false_position_amount: 4_000,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let pred_out =\n    Output {\n      address: from_script(#\"\"),\n      value: assets.from_lovelace(2_000_000)\n        |> assets.add(pred_nft_id, pred_nft_name, 1)\n        |> assets.add(usdm_id, usdm_name, 10_000),\n      datum: InlineDatum(pred_out_datum),\n      reference_script: None,\n    }\n  let treasury_out =\n    Output {\n      address: from_script(treasury_script_hash),\n      value: assets.from_lovelace(20_002_200_000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n  let license_input =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"07f157faf99b850b4971034feee28d\",\n        output_index: 0,\n      },\n      output: Output {\n        address: from_script(#\"12\"),\n        value: assets.add(\n          assets.zero,\n          license_symbol,\n          string.to_bytearray(@\"1727715600000\"),\n          1,\n        ),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n  let license_output =\n    Output {\n      address: from_script(#\"12\"),\n      value: assets.add(\n        assets.zero,\n        license_symbol,\n        string.to_bytearray(@\"1727715600000\"),\n        1,\n      ),\n      datum: NoDatum,\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [pred_input, license_input],\n      reference_inputs: [],\n      outputs: [pred_out, treasury_out, license_output],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let pred_redeemer =\n    PredWithdrawAdminFee {\n      own_input_idx: 0,\n      own_output_idx: 0,\n      license_idx: 1,\n      treasury_out_idx: 1,\n    }\n  predictions.spend(params, Some(pred_datum), pred_redeemer, own_ref, tx)\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/predictions.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Credential, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value.{PolicyId}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Batching, BatchingPool, GlobalSetting, OrderDatum, PAMSignature,\n  PAMSpendScript, PAMWithdrawScript, PoolBatchingRedeemer, PoolDatum,\n  PoolRedeemer, SwapMultiRouting, SwapRouting, UpdateDynamicFee, UpdatePoolFee,\n  UpdatePoolParameters, UpdatePoolStakeCredential, WithdrawFeeSharing,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n) {\n  fn validate_pool(\n    datum: PoolDatum,\n    redeemer: PoolRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(pool_input_ref) } =\n      context\n    when redeemer is {\n      Batching -> {\n        let Transaction { withdrawals, .. } = transaction\n        let PoolDatum { pool_batching_stake_credential, .. } = datum\n        dict.has_key(withdrawals, pool_batching_stake_credential)\n      }\n      UpdatePoolParameters(action) -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting {\n          pool_fee_updater,\n          pool_stake_key_updater,\n          pool_dynamic_fee_updater,\n          ..\n        } = global_setting\n        let authorizer =\n          when action is {\n            UpdatePoolFee -> pool_fee_updater\n            UpdateDynamicFee -> pool_dynamic_fee_updater\n            UpdatePoolStakeCredential -> pool_stake_key_updater\n          }\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: authorizer,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: authorizer,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_update_pool_parameters(\n            action: action,\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n      WithdrawFeeSharing -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          mint,\n          withdrawals,\n          extra_signatories,\n          ..\n        } = transaction\n        expect Some(pool_input) = transaction.find_input(inputs, pool_input_ref)\n        let Input { output: Output { address: pool_address, .. }, .. } =\n          pool_input\n        let global_setting =\n          pool_validation.get_and_validate_global_setting(\n            reference_inputs: reference_inputs,\n            authen_policy_id: authen_policy_id,\n          )\n        let GlobalSetting { fee_sharing_taker, .. } = global_setting\n        and {\n          // Transaction must be executed by the correct authorizer\n          utils.authorize_pool_license(\n            author: fee_sharing_taker,\n            transaction_inputs: inputs,\n            withdrawals: withdrawals,\n            extra_signatories: extra_signatories,\n          ),\n          // Verify that the transaction spends only one Single Pool Script and does not contain any other scripts in its inputs, except for the Author, in cases where the Author is a script\n          pool_validation.has_only_pool_and_author(\n            inputs: inputs,\n            pool_address: pool_address,\n            pool_author: fee_sharing_taker,\n          ),\n          // This Redeemer won't mint anything \n          value.is_zero(value.from_minted_value(mint)),\n          pool_validation.validate_withdraw_fee_sharing(\n            authen_policy_id: authen_policy_id,\n            pool_input: pool_input,\n            pool_in_datum: datum,\n            all_outputs: outputs,\n          ),\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // The Payment Credential of Pool Validator\n  pool_payment_cred: Credential,\n) {\n  fn validate_pool_batching(\n    redeemer: PoolBatchingRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext {\n      transaction,\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    let Transaction {\n      inputs,\n      outputs,\n      datums,\n      validity_range,\n      mint,\n      reference_inputs,\n      extra_signatories,\n      withdrawals,\n      ..\n    } = transaction\n    let PoolBatchingRedeemer {\n      batcher_index,\n      orders_fee,\n      input_indexes,\n      pool_input_indexes_opt,\n      vol_fees,\n    } = redeemer\n    let global_setting =\n      pool_validation.get_and_validate_global_setting(\n        reference_inputs: reference_inputs,\n        authen_policy_id: authen_policy_id,\n      )\n    let GlobalSetting { batchers, .. } = global_setting\n    let current_time_approximation =\n      utils.must_get_current_time_approximation(validity_range)\n\n    // Due to authorized batchers is a list so we use @batcher_index to save the On-chain cost \n    // on searching the batcher address in this section \n    let batcher_address = utils.list_at_index(batchers, batcher_index)\n    expect and {\n        // Transaction must be executed by the authorized batchers\n        utils.authorize_pool_license(\n          author: batcher_address,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n        ),\n        // Input indexes must not be empty list and be unique\n        utils.is_unique_bytearray_unsorted(input_indexes),\n        // validate Transaction won't mint any assets\n        value.is_zero(value.from_minted_value(mint)),\n      }\n\n    let pool_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: Output { address: addr, .. }, .. } = input\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n    let pool_outputs =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: addr, .. } = output\n          let Address { payment_credential: payment_cred, .. } = addr\n          payment_cred == pool_payment_cred\n        },\n      )\n\n    // We assume that inputs not belonging to the batcher or liquidity pool are orders. \n    // These inputs' structure will be verified in the @apply_orders function and SwapMultiRouting branch. \n    // We do not force finding the order script hash here, as we allow for the possibility of upgrading the order contract (possibly to Plutus V3).\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input { output: out, .. } = input\n          let Output { address: addr, .. } = out\n          let Address { payment_credential: payment_cred, .. } = addr\n          and {\n            payment_cred != pool_payment_cred,\n            when batcher_address is {\n              PAMSignature(pkh) ->\n                payment_cred != VerificationKeyCredential(pkh)\n              PAMSpendScript(sh) -> payment_cred != ScriptCredential(sh)\n              PAMWithdrawScript(sh) -> payment_cred != ScriptCredential(sh)\n            },\n          }\n        },\n      )\n    // Currently, transaction inputs will be sorted by TxId and TxIndex of UTxO.\n    // We have to calculate indexes of orders inputs sorting by the ASC created time\n    // on the off-chain and on-chain will sort the TxIns by the indexes\n    // Input Indexes in parameter will be the index indexes of @order_inputs\n    let sorted_order_inputs =\n      bytearray.foldr(\n        input_indexes,\n        [],\n        fn(idx, ips) { list.push(ips, utils.list_at_index(order_inputs, idx)) },\n      )\n\n    expect and {\n        // Order Inputs and Input Indexes must have the same length\n        builtin.length_of_bytearray(input_indexes) == list.length(order_inputs),\n        // Pool Inputs & Outputs must have the same length\n        utils.compare_list_length(pool_inputs, pool_outputs),\n      }\n\n    when pool_inputs is {\n      [pool_input] -> {\n        // In case transaction only contains 1 Pool Input & Output, all order types are accepted except SwapMultiRouting\n        let pool_output = pool_outputs |> builtin.head_list\n        expect [vol_fee] = vol_fees\n        let Input { output: pool_in_output, .. } = pool_input\n        let BatchingPool {\n          asset_a,\n          asset_b,\n          lp_asset,\n          trading_fee_a_numerator,\n          trading_fee_b_numerator,\n          fee_sharing_numerator_opt,\n          pool_state_in,\n          pool_state_out,\n        } =\n          pool_validation.get_batching_pool(\n            stake_credential: stake_credential,\n            pool_input: pool_in_output,\n            pool_output: pool_output,\n            authen_policy_id: authen_policy_id,\n            require_total_liquidity_unchange: False,\n            vol_fee: vol_fee,\n          )\n        pool_state_out == order_validation.apply_orders(\n          datum_map: datums,\n          asset_a: asset_a,\n          asset_b: asset_b,\n          lp_asset: lp_asset,\n          trading_fee_a_numerator: trading_fee_a_numerator,\n          trading_fee_b_numerator: trading_fee_b_numerator,\n          fee_sharing_numerator_opt: fee_sharing_numerator_opt,\n          current_time_approximation: current_time_approximation,\n          order_inputs: sorted_order_inputs,\n          all_outputs: outputs,\n          orders_fee: orders_fee,\n          pool_state: pool_state_in,\n        )\n      }\n      [] -> False\n      _ -> {\n        // In case transaction only contains more than 1 Pool Input & Output, only single SwapMultiRouting Order is accepted\n        expect [order_input] = sorted_order_inputs\n        let order_output = outputs |> builtin.head_list\n        expect [order_fee] = orders_fee\n        let Input {\n          output: Output {\n            value: order_in_value,\n            datum: raw_order_in_datum,\n            ..\n          },\n          ..\n        } = order_input\n        let Output { value: order_out_value, .. } = order_output\n        expect order_in_datum: OrderDatum =\n          utils.must_find_script_datum(datums, raw_order_in_datum)\n        let OrderDatum {\n          success_receiver,\n          success_receiver_datum,\n          step: order_step,\n          max_batcher_fee,\n          lp_asset: order_lp_asset,\n          expiry_setting_opt,\n          ..\n        } = order_in_datum\n        expect SwapMultiRouting(routings, swap_amount_option, minimum_receive) =\n          order_step\n        let SwapRouting { lp_asset: first_routing_lp_asset, .. } =\n          routings |> builtin.head_list\n        expect Some(pool_input_indexes) = pool_input_indexes_opt\n        expect and {\n            // max_batcher_fee must be positive\n            max_batcher_fee > 0,\n            // Used Batcher Fee must be positive and less than or equal batcher fee\n            order_fee > 0,\n            order_fee <= max_batcher_fee,\n            // Order Output must be returned to receiver and might have receiver_datum\n            order_validation.validate_order_receiver(\n              receiver: success_receiver,\n              receiver_datum: success_receiver_datum,\n              output: order_output,\n            ),\n            // In case expired setting is turned on, the execution time must not exceed the expired_time\n            when expiry_setting_opt is {\n              None -> True\n              Some((expired_time, _)) ->\n                current_time_approximation <= expired_time\n            },\n            // Order LP Asset must be the first LP Asset on the routing config\n            order_lp_asset == first_routing_lp_asset,\n            // minimum_receive must be positive\n            minimum_receive > 0,\n            // The number of Pool Inputs and Pool Outputs must be the same with _routings_ length\n            utils.compare_list_length(pool_inputs, routings),\n            // Pool Input Indexes must be unique\n            utils.is_unique_bytearray_unsorted(pool_input_indexes),\n            // This contract allows the order routing through at most 3 Pools \n            builtin.length_of_bytearray(pool_input_indexes) <= 3,\n          }\n        let sorted_pool_inputs =\n          bytearray.foldr(\n            pool_input_indexes,\n            [],\n            fn(idx, ps) { list.push(ps, utils.list_at_index(pool_inputs, idx)) },\n          )\n        let batching_pools =\n          utils.zip_with(\n            sorted_pool_inputs,\n            pool_outputs,\n            vol_fees,\n            fn(pool_in, pool_out, vol_fee) {\n              let Input { output: pool_in_output, .. } = pool_in\n              pool_validation.get_batching_pool(\n                stake_credential: stake_credential,\n                pool_input: pool_in_output,\n                pool_output: pool_out,\n                authen_policy_id: authen_policy_id,\n                require_total_liquidity_unchange: True,\n                vol_fee: vol_fee,\n              )\n            },\n          )\n        order_validation.validate_swap_multi_routing_order(\n          pools: batching_pools,\n          routings: routings,\n          order_in_value: order_in_value,\n          order_out_value: order_out_value,\n          swap_amount_option: swap_amount_option,\n          minimum_receive: minimum_receive,\n          used_batcher_fee: order_fee,\n        )\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/pool_validator.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/transaction.{Publish, ScriptContext, Transaction, WithdrawFrom}\nuse aiken/transaction/certificate.{Certificate, CredentialDelegation}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse assist/find\nuse assist/signing\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{Delegate, StakingRedeemer, Withdraw}\n\nvalidator(\n  // The hot key controls the staking\n  hot_key: PublicKeyHash,\n) {\n  fn params(redeemer: StakingRedeemer, context: ScriptContext) -> Bool {\n    let tx: Transaction = context.transaction\n    when context.purpose is {\n      // handle all withdrawals\n      WithdrawFrom(stake_credential) -> {\n        // if no reward is found then error\n        let reward: Int =\n          find.stake_reward_by_sc(tx.withdrawals, stake_credential)\n        when redeemer is {\n          // can withdraw the reward to anywhere\n          Withdraw -> and {\n              // no withdraw zero validations\n              (reward > 0)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          // anything else fails\n          _ -> False\n        }\n      }\n      // handle all delegation certs\n      Publish(certificate) ->\n        when redeemer is {\n          // only delegate to secific pool\n          Delegate(delegate_data) -> {\n            let new_delegation: Certificate =\n              CredentialDelegation {\n                delegator: Inline(ScriptCredential(delegate_data.stake_cred)),\n                delegatee: delegate_data.pool_id,\n              }\n            //\n            //\n            and {\n              // The only cert is for new delegation\n              (certificate == new_delegation)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          }\n          // deregistration fails and anything else but changing delegation\n          _ -> False\n        }\n      // anything else fails\n      _ -> False\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/staking.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/transaction.{ScriptContext, Spend}\n\nvalidator {\n  fn spend(_d: Data, _r: Data, ctx: ScriptContext) {\n    expect ScriptContext { purpose: Spend(_), .. } = ctx\n    True\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/always_success.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse aiken/interval\nuse cardano/address.{Address, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\nuse shared\nuse sundae/multisig\nuse tests/examples/ex_shared.{mk_tx_hash, script_address}\nuse types/oracle.{Burn, Mint, OracleDatum, OracleRedeemer} as types_oracle\nuse types/order.{Fixed, OrderDatum}\nuse types/pool.{PoolDatum}\n\n// The oracle script holds an oracle token, and a snapshot of the pool price at the *end* of some scoop.\n// This allows other protocols to build integrations that read the pool price (for some confidence interval) without worrying about contention\n//\n// In particular, this is an agnostic format; because the `record` order type just specifies the policy ID that needs to be minted,\n// you could write other versions of the \"Oracle\" script that supported other oracle formats, like Charli3 or OrcFax.\n//\n// It's important to use the price at the *end* of the scoop, or at the beginning, rather than just using the price\n// \"at the time\" the order was processed. If we expose the pool price mid-stream, then it is easy to sandwich the order between two others.\n// By using the snapshot at the end of the order, such an attacker exposes themselves to arbitrage opportunities which makes such an attack riskier.\nvalidator oracle(pool_script_hash: ScriptHash) {\n  // In order to spend the oracle script, two things must be true:\n  // - it must be signed by the \"owner\"\n  // - there must be no oracle tokens on the outputs\n  // This allows reclaiming funds that were accidentally locked at the script address,\n  // while also enforcing that the oracle token is burned; this is important, as people\n  // will be relying on the oracle token to authenticate the actual values\n  spend(\n    datum: Option<OracleDatum>,\n    _r: Data,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    expect Some(datum) = datum\n    let own_input = shared.spent_output(transaction, out_ref)\n    expect Script(own_script_hash) = own_input.address.payment_credential\n    and {\n      multisig.satisfied(\n        datum.owner,\n        transaction.extra_signatories,\n        transaction.validity_range,\n        transaction.withdrawals,\n      ),\n      list.all(\n        transaction.outputs,\n        fn(output) {\n          assets.quantity_of(\n            output.value,\n            own_script_hash,\n            shared.oracle_sft_name(),\n          ) == 0\n        },\n      ),\n    }\n  }\n\n  // In order to mint an orcale token, two things must be true:\n  // - each oracle token on the outputs must be paid with a quantity of 1 to the oracle script\n  // - the datum for each must have the correct timing and pricing information\n  // Burning an oracle token is always allowed\n  mint(\n    redeemer: OracleRedeemer,\n    own_policy_id: PolicyId,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Mint(pool_ident, order_indices) -> {\n        // Calculate the expected pool token names, so we can look for the pool name, and record the LP tokens\n        let pool_lp_name = shared.pool_lp_name(pool_ident)\n        let pool_nft_name = shared.pool_nft_name(pool_ident)\n\n        // Find the pool output, i.e. the one with the pool NFT, so we can record the prices\n        expect Some(pool_output) = list.head(transaction.outputs)\n        expect\n          pool_output.address.payment_credential == Script(pool_script_hash)\n        expect\n          assets.quantity_of(pool_output.value, own_policy_id, pool_nft_name) == 1\n\n        // Then unpack the pool datum\n        expect InlineDatum(pool_datum) = pool_output.datum\n        expect pool_datum: PoolDatum = pool_datum\n        let PoolDatum { assets: (asset_a, asset_b), circulating_lp, .. } =\n          pool_datum\n\n        let reserve_a =\n          (\n            asset_a.1st,\n            asset_a.2nd,\n            assets.quantity_of(pool_output.value, asset_a.1st, asset_a.2nd),\n          )\n        let reserve_b =\n          (\n            asset_b.1st,\n            asset_b.2nd,\n            assets.quantity_of(pool_output.value, asset_b.1st, asset_b.2nd),\n          )\n        let circulating_lp = (pool_script_hash, pool_lp_name, circulating_lp)\n\n        let oracle_name = shared.oracle_sft_name()\n\n        // For each output that produces an oracle, there should be an oracle\n        // order in the inputs given by the nth item of the order_indices list\n        // in the redeemer\n        let (_, no_duplicate_minted_oracles) =\n          list.foldl(\n            transaction.outputs,\n            (0, True),\n            fn(output, state) {\n              let (oracle_minted_index, no_duplicates) = state\n              let qty =\n                assets.quantity_of(output.value, own_policy_id, oracle_name)\n              when qty is {\n                0 -> (oracle_minted_index, no_duplicates)\n                1 -> {\n                  expect Some(this_order_index) =\n                    list.at(order_indices, oracle_minted_index)\n                  expect Some(oracle_order) =\n                    list.at(transaction.inputs, this_order_index)\n                  expect Some(oracle_order_datum) =\n                    shared.datum_of(transaction.datums, oracle_order.output)\n                  expect oracle_order_datum: OrderDatum = oracle_order_datum\n                  expect owner: multisig.MultisigScript =\n                    oracle_order_datum.extension\n                  expect\n                    output.address.payment_credential == Script(own_policy_id)\n                  expect Some(oracle_datum) =\n                    shared.datum_of(transaction.datums, output)\n                  expect oracle_datum: OracleDatum = oracle_datum\n                  expect oracle_datum.valid_range == transaction.validity_range\n                  expect oracle_datum.pool_ident == pool_ident\n                  expect oracle_datum.owner == owner\n                  expect reserve_a == oracle_datum.reserve_a\n                  expect reserve_b == oracle_datum.reserve_b\n                  expect circulating_lp == oracle_datum.circulating_lp\n                  (oracle_minted_index + 1, no_duplicates)\n                }\n                _ -> (0, False)\n              }\n            },\n          )\n        no_duplicate_minted_oracles\n      }\n      Burn -> True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest oracle_basic() {\n  mint_oracle(identity, identity, identity)\n}\n\ntest oracle_burn_mint() {\n  mint_oracle(identity, identity, fn(_) { Burn })\n}\n\ntest oracle_redeemer_indices_can_have_extras() {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [0, 1, 999, -1]) })\n}\n\ntest oracle_redeemer_indices_must_match_up() fail {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [1, 0]) })\n}\n\n// Minting policy enforces that the reserves are correct\ntest oracle_wrong_datum() fail {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    identity,\n    identity,\n  )\n}\n\n// If we mint a token with the wrong name, we can choose whatever datum we want\ntest oracle_fake_token() {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    fn(_) { \"fake\" },\n    identity,\n  )\n}\n\nfn mint_oracle(\n  modify_oracle_datum: fn(OracleDatum) -> OracleDatum,\n  modify_oracle_name: fn(ByteArray) -> ByteArray,\n  modify_redeemer: fn(OracleRedeemer) -> OracleRedeemer,\n) {\n  let oracle_policy_id =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let oracle_address =\n    Address {\n      payment_credential: Script(oracle_policy_id),\n      stake_credential: None,\n    }\n  let order_address =\n    Address { payment_credential: Script(#\"1234\"), stake_credential: None }\n  let pool_script_hash =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let pool_address = script_address(pool_script_hash)\n  let rberry_policy_id =\n    #\"9a9693a9a37912a5097918f97918d15240c92ab729a0b7c4aa144d77\"\n  let rberry_token_name = #\"524245525259\"\n  let pool_id = #\"00\"\n  let pool_lp_name = shared.pool_lp_name(pool_id)\n  let pool_nft_name = shared.pool_nft_name(pool_id)\n  // This looks like a fresh pool but pretend that we're scooping\n  let pool_output =\n    Output {\n      address: pool_address,\n      value: assets.from_lovelace(1_000_000_000)\n        |> assets.add(rberry_policy_id, rberry_token_name, 1_000_000_000)\n        |> assets.add(pool_script_hash, pool_nft_name, 1),\n      datum: InlineDatum(\n        PoolDatum {\n          identifier: pool_id,\n          assets: ((#\"\", #\"\"), (rberry_policy_id, rberry_token_name)),\n          circulating_lp: 1_000_000_000,\n          bid_fees_per_10_thousand: 5,\n          ask_fees_per_10_thousand: 5,\n          fee_manager: None,\n          market_open: 0,\n          protocol_fees: 2_000_000,\n        },\n      ),\n      reference_script: None,\n    }\n  let user_1_multisig = multisig.Signature(#\"01\")\n  let user_2_multisig = multisig.Signature(#\"02\")\n  let oracle_name = modify_oracle_name(shared.oracle_sft_name())\n  let oracle_order_input_1 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 0,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_1_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n  let oracle_order_input_2 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 1,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_2_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n\n  let oracleMintRedeemer = modify_redeemer(Mint(pool_id, [0, 1]))\n  let oracle_output_1 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_1_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let oracle_output_2 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_2_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let transaction =\n    Transaction {\n      ..transaction.placeholder,\n      inputs: [oracle_order_input_1, oracle_order_input_2],\n      outputs: [pool_output, oracle_output_1, oracle_output_2],\n      fee: 1_000_000,\n      mint: assets.zero |> assets.add(oracle_policy_id, oracle_name, 1),\n      validity_range: interval.between(1, 2),\n      id: mk_tx_hash(1),\n    }\n\n  oracle.mint(\n    oracle_policy_id,\n    oracleMintRedeemer,\n    oracle_policy_id,\n    transaction,\n  )\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/oracle.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/dict\nuse aiken/transaction.{Transaction,Input,Output,ScriptContext} as tx\nuse aiken/transaction/certificate.{CredentialRegistration}\nuse aiken/transaction/credential.\n  { Address\n  , Inline\n  , ScriptCredential\n  }\nuse aiken/transaction/value.{PolicyId}\n\nuse cardano_options/proposal_validation as propose\nuse cardano_options/purchase_execute_or_close_expired_validation as purchase_execute_or_close_expired\nuse cardano_options/address_update_validation as update\nuse cardano_options/utils.{trace_if_false}\nuse cardano_options/data/core.{ScriptHash}\nuse cardano_options/data/datums.{OptionsDatum,ProposalDatum,ActiveDatum}\nuse cardano_options/data/redeemers.\n  { OptionsRedeemer\n  , ProposalBeaconsRedeemer\n  , ActiveBeaconsRedeemer\n  , AddressObserverRedeemer\n  }\n\n// ----------------------------------------------\n// Options Validator Script\n// ----------------------------------------------\n// This smart contract is the payment credential for all options addresses. All options contracts\n// for sale and all active options contracts are kept in addresses using this smart contract as the\n// payment credential. All option writers get their own options address by using a staking\n// credential unique to them; this smart contract delegates all owner related actions to the staking\n// credential used for the address. In order to minimize redundant executions, this smart contract\n// also delegates protocol logic to observer scripts when needed.\nvalidator() {\n  fn options_script(datum: OptionsDatum, redeemer: OptionsRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      redeemers.CloseOrUpdateProposal -> {\n        // This redeemer is dedicated to closing or updating any Proposal UTxO. Invalid Proposal\n        // UTxOs (ie, UTxOs with a ProposalDatum but no beacons) can also be closed with this\n        // redeemer.\n        //\n        // This address' staking credential must signal approval; if the UTxO contains beacons, the\n        // proposal_beacon_script must also be executed with the CreateCloseOrUpdateProposals\n        // redeemer.\n\n        // Extract the required information from the script context.\n        expect ScriptContext(\n          Transaction{inputs,redeemers,withdrawals,extra_signatories..}, \n          tx.Spend(out_ref)\n        ) = ctx\n\n        // Get this input being spent to extract the borrower's staking credential.\n        expect Some(Input(_, Output(Address(_,stake), val, ..))) = tx.find_input(inputs,out_ref)\n\n\n        // Get the proposal beacon id from the datum.\n        let proposal_beacon_policy_id = when datum is {\n          ProposalDatum{proposal_beacon_policy_id,..} -> proposal_beacon_policy_id\n          _ -> error @\"UTxO is not a Proposal UTxO\"\n        }\n\n        let req_redeemer: Data = redeemers.CreateCloseOrUpdateProposals // Cast to Data type.\n\n        and {\n          trace_if_false( \n            @\"Writer did not approve\",\n            utils.staking_credential_approves(stake,withdrawals,extra_signatories)\n          ),\n\n          when value.tokens(val,proposal_beacon_policy_id) |> dict.to_list(_) is {\n            [] -> True\n            _ -> trace_if_false(\n              @\"Proposal beacon script not executed with proper redeemer\",\n              utils.script_executed_with_redeemer(\n                redeemers,\n                req_redeemer,\n                proposal_beacon_policy_id\n              )\n            )\n          }\n        }\n      }\n\n      redeemers.PurchaseContract{..} -> {\n        // This redeemer is dedicated to purchasing options contracts from this address. The\n        // spending script just needs to ensure the active beacon script is executed properly.\n        // The active beacon script will not allow using this redeemer with invalid Proposal UTxOs\n        // (ie, those with a ProposalDatum but no beacons).\n\n        // Get the required information from the script context.\n        expect ScriptContext(Transaction{redeemers,..}, tx.Spend(_)) = ctx\n\n        // Get the beacon ids from the ProposalDatum.\n        let (proposal_beacon_policy_id,active_beacon_policy_id) = when datum is {\n          ProposalDatum{proposal_beacon_policy_id,active_beacon_policy_id,..} -> \n            (proposal_beacon_policy_id,active_beacon_policy_id)\n          _ -> error @\"UTxO is not a Proposal UTxO\"\n        }\n\n        let req_redeemer: Data = redeemers.PurchaseExecuteOrCloseExpired(proposal_beacon_policy_id)\n\n        // The active beacon script must be executed using the proper redeemer. The redeemer map\n        // must be used to check for execution because the proposal_beacon_policy_id must be\n        // correctly enforced.\n        trace_if_false(\n          @\"Active beacon script not executed with proper redeemer\",\n          // It must be executed as a minted policy.\n          dict.get(redeemers, tx.Mint(active_beacon_policy_id)) == Some(req_redeemer)\n        )\n      }\n\n      redeemers.ExecuteContract -> {\n        // Executing contracts involves burning all beacons attached to the Active UTxOs as well as\n        // the Key NFT for each contract. Because of this burning requirement, the logic is\n        // outsourced to the active beacon script. This redeemer just needs to ensure the beacon\n        // script is executed with the proper redeemer.\n        //\n        // By requiring both the Lock NFT and the Key NFT to be burned, only the owner of the\n        // Key NFT is able to spend UTxOs with this redeemer.\n        //\n        // The contract must be not expired. This will be checked by the active beacon script.\n        //\n        // The active beacon script will not allow using this redeemer to spend invalid Active UTxOs\n        // (ie, those with an ActiveDatum but no beacons).\n\n        // Extract out the required information from the script context.\n        expect ScriptContext(Transaction{redeemers,..}, tx.Spend(_)) = ctx\n\n        // Get the active_beacon_id from the datum.\n        let (active_beacon_policy_id,proposal_beacon_policy_id) = when datum is {\n          ActiveDatum{active_beacon_policy_id,proposal_beacon_policy_id,..} ->\n            (active_beacon_policy_id,proposal_beacon_policy_id)\n          _ -> error @\"UTxO is not an Active UTxO\"\n        }\n\n        let req_redeemer: Data = redeemers.PurchaseExecuteOrCloseExpired(proposal_beacon_policy_id)\n\n        // The active beacon script will check that the required Key is burned in the transaction\n        // and that this loan is actually expired.\n        trace_if_false(\n          @\"Active beacon script not executed with proper redeemer\",\n          // It must be executed as a minted policy.\n          dict.get(redeemers, tx.Mint(active_beacon_policy_id)) == Some(req_redeemer)\n        )\n      }\n\n      redeemers.CloseExpiredContract -> {\n        // This redeemer can be used to close expired contracts and spend invalid Active UTxOs (ie,\n        // UTxOs with an ActiveDatum but no beacons).\n        //\n        // This address' staking credential must signal approval; if the UTxO contains beacons, the\n        // active_beacon_script must also be executed with the proper redeemer.\n\n        // Extract out the required information from the script context.\n        expect ScriptContext(\n          Transaction{inputs,withdrawals,extra_signatories,redeemers,..},\n          tx.Spend(out_ref)\n        ) = ctx\n\n        // Get the address and value of the input being spent.\n        expect Some(Input(_,Output(Address(_,stake),utxo_value,..))) = tx.find_input(inputs,out_ref)\n\n        // Get the active_beacon_id from the datum.\n        let (active_beacon_policy_id,proposal_beacon_policy_id) = when datum is {\n          ActiveDatum{active_beacon_policy_id,proposal_beacon_policy_id,..} ->\n            (active_beacon_policy_id,proposal_beacon_policy_id)\n          _ -> error @\"UTxO is not an Active UTxO\"\n        }\n\n        let req_redeemer: Data = redeemers.PurchaseExecuteOrCloseExpired(proposal_beacon_policy_id)\n\n        and {\n          trace_if_false( \n            @\"Writer did not approve\",\n            utils.staking_credential_approves(stake,withdrawals,extra_signatories)\n          ),\n\n          when value.tokens(utxo_value,active_beacon_policy_id) |> dict.to_list(_) is {\n            [] -> True\n            _ -> trace_if_false(\n              @\"Active beacon script not executed with proper redeemer\",\n              // It must be executed as a minted policy.\n              dict.get(redeemers, tx.Mint(active_beacon_policy_id)) == Some(req_redeemer)\n            )\n          }\n        }\n      }\n\n      redeemers.UpdatePaymentAddress{..} -> {\n        // This redeemer delegates most of the checks to the address_update_observer_script. All\n        // this redeemer must do is ensure the address_update_observer_script script is executed as\n        // a staking script and check the writer approves this transaction.\n\n        // Extract out the required information from the script context.\n        expect ScriptContext(\n          Transaction{inputs,withdrawals,extra_signatories,..},\n          tx.Spend(out_ref)\n        ) = ctx\n\n        // Get the address and value of the input being spent.\n        expect Some(Input(_,Output(Address(_,stake),..))) = tx.find_input(inputs,out_ref)\n\n        // Get the address_update_observer_hash from the Active datum. All valid Active UTxOs are \n        // guaranteed to have the proper address_update_observer_hash in the datum.\n        let address_update_observer_hash = when datum is {\n          ActiveDatum{address_observer_hash,..} -> address_observer_hash\n          _ -> error @\"UTxO is not an Active UTxO\"\n        }\n\n        and {\n          trace_if_false( \n            @\"Writer did not approve\",\n            utils.staking_credential_approves(stake,withdrawals,extra_signatories)\n          ),\n\n          // The address_update_observer_script must be executed with the ObserveAddressUpdate redeemer. This\n          // redeemer can only be used with a staking execution. The address_update_observer_script only has\n          // one possible redeemer that can be used.\n          trace_if_false(\n            @\"Address update observer script not executed with proper redeemer\",\n            utils.observer_script_executed(withdrawals, address_update_observer_hash)\n          )\n        }\n      }\n    }\n  }\n}\n\n// ----------------------------------------------\n// Address Update Observer Script\n// ----------------------------------------------\n// To minimize the redundant executions from having the options validator script do the checks, this\n// observer script is used to validate lender address updates of active contracts. In order to\n// observe updates, this script must be executed as a staking script. The options validator script's\n// hash is hard-coded into this observer script so that the observer script allways knows where to\n// look. The beacons can only be minted if the address update observer script hash in the\n// ActiveDatum is correct. The proxy_hash is also hard-coded into this observer scripts so that new\n// addresses can be checked for validity.\nvalidator(proxy_hash: ScriptHash, options_script_hash: ScriptHash) {\n  fn address_observer_script(redeemer: AddressObserverRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      redeemers.RegisterAddressObserverScript -> {\n        // Only allow registering the script. It cannot be delegated or deregistered.\n        when ctx is {\n          ScriptContext(_, tx.Publish(CredentialRegistration(_))) -> True\n          _ -> error \"This redeemer can only be used to register the address update observer script\"\n        }\n      }\n\n      redeemers.ObserveAddressUpdate -> {\n        // Just in case the writer needs to update the payment address of an Active contract,\n        // this redeemer can oversee all address updates for writers.\n        //\n        // This redeemer can only be used with a staking execution. It will compare the redeemer\n        // map to the inputs to only validate address updates. \n        //\n        // In order for this redeemer to successfully execute, all of the following must be true:\n        // 1) The address_observer_script is executed as a staking script.\n        // 2) For all contract inputs:\n        //      a) It must have an ActiveDatum.\n        //      b) The writer must signal approval.\n        //      c) The deposit_increase must be >= 0.\n        //      d) The new address must either use a payment pubkey or the proxy script with a\n        //         valid staking credential.\n        //      e) There must be a corresponding Active UTxO output to the writer's address with:\n        //         1) The value must be starting value + ada deposit_increase\n        //         2) The contractDeposit must be increased by the deposit_increase.\n        //\n        // There is no need to check if the contract is expired since the writer is already\n        // incentivized to close the expired contract instead of updating the address.\n        //\n        // There is also no need to check for the beacons to prevent updating invalid Active UTxOs.\n        // These invalid UTxOs belong to the writer anyway, and this observer script will still\n        // require the proper output at the writer's address. There is no incentive for writers to\n        // update addresses of invalid Active UTxOs.\n\n        // Extract the required information from the script context.\n        expect ScriptContext( \n          Transaction{inputs,outputs,redeemers,..}, \n          tx.WithdrawFrom(_)\n        ) = ctx\n\n        // This has its own error messages.\n        update.valid_address_update(\n          inputs,\n          outputs,\n          redeemers,\n          ScriptCredential(options_script_hash),\n          proxy_hash\n        )\n      }\n    }\n  }\n}\n\n// ----------------------------------------------\n// Active Beacon Script\n// ----------------------------------------------\n// This script governs the minting and burning of all beacons for active contracts. Active contracts\n// are options contracts that have be purchased, and are ready to be executed. This script can only\n// be executed as a minting script. The observer hash is hard-coded into the script so that it can\n// enforce the use of the proper observer logic. The options_script_hash is hard-coded into the\n// script so that it knows where to look. There are four proposal beacons; every Active UTxO must\n// have all four, and no extraneous beacons. The four beacons are:\n// 1) TradingPair beacon: sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name) except when one of\n//    the assets is ADA, that policy id is replaced with \"00\".\n// 2) Offer beacon: sha2_256(\"01\" ++ offer_id ++ offer_name)\n// 3) Ask beacon: sha2_256(\"02\" ++ ask_id ++ ask_name)\n// 4) ContractId beacon: sha2_256(proposal_utxo_tx_hash ++ proposal_utxo_output_index)\n//\n// There are two copies of the ContractId beacon for every contract. These are the Lock & Key NFTs\n// for that contract. One gets stored with the contract, the other is claimed by the buyer.\n//\n// Purchasing contracts, executing contracts, and closing expired contracts can all happen in the\n// same transaction. However, burning excess Key NFTs cannot be done in the same transaction as any\n// of the other actions.\nvalidator(options_script_hash: ScriptHash, address_observer_script_hash: ScriptHash) {\n  fn active_beacon_script(redeemer: ActiveBeaconsRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      redeemers.PurchaseExecuteOrCloseExpired{proposal_beacon_id} -> {\n        // Since a minting policy can only be executed once in a given transaction, having separate\n        // redeemers for each action would prevent being able to compose the actions in a single\n        // transaction. Due to the economic benefits from supporting compositions, this redeemer can\n        // do all three actions; it can even handle each action separately.\n        //\n        // To figure out which action is meant for each UTxO, the inputs are compared against the\n        // redeemers map. The spending redeemer used determines which action is taking place for\n        // that UTxO:\n        // - PurchaseContract -> buying a proposal contract\n        // - ExecuteContract -> executing an active contract\n        // - CloseExpiredContract -> closing an expired active contract\n        //\n        // At a high level, every input either has required outputs and/or required beacon token\n        // mints/burns. So while matching up inputs and redeemers, the smart contract will build up\n        // a list of required outputs and required mints/burns. Then, it will check the outputs and\n        // tx mint to see if the requirements are met for the given inputs.\n        //\n        // To improve performance, the required outputs are assumed to be in the same order as the \n        // inputs. The outputs do not need to be grouped together and there can be unrelated outputs\n        // mixed in between the required outputs. In the case where a single input requires multiple\n        // outputs (eg, during PurchaseContract), the required outputs for this input do NOT need to\n        // be next to each other. You can think of it like this:\n        // - There are three types of required outputs: new active contract output, premium output,\n        // and execution payment output. \n        // - These output types are treated separately; even if they are for the same input.\n        // - Filter all inputs for a given action. Then, filter all outputs for a specific type that\n        // corresponds to that action. As long as the inputs and outputs are in the same order, the\n        // transaction will succeed.\n        //\n        // For example, if you have this input ordering:\n        // 1) purchase1 input\n        // 2) execution1 input\n        // 3) purchase2 input\n        // 4) execution2 input\n        //\n        // Then these are some of the possible valid output orderings:\n        // 1) execution1 payment output\n        // 2) contract1 output\n        // 3) contract2 output\n        // 4) premium1 output\n        // 5) premium2 output\n        // 6) execution2 payment output\n        //\n        // or\n        //\n        // 1) contract1 output\n        // 2) execution1 payment output\n        // 3) execution2 payment output\n        // 4) premium1 output\n        // 5) contract2 output\n        // 6) premium2 output\n        //\n        // These are the key requirements for the above example's output ordering:\n        // 1) contract1 output MUST appear before contract2 output\n        // 2) premium1 output MUST appear before premium2 output\n        // 3) execution1 payment output MUST appear before execution2 payment output\n        // Any ordering that satisfies these three requirements is valid.\n\n        //---------------------------------------\n        // Purchase Validation\n        //---------------------------------------\n        // In order to purchase a proposal contract, all of the following must be true for all\n        // proposal inputs:\n        // 1) The input must be spent using PurchaseContract.\n        // 2) The input must have a ProposalDatum.\n        // 3) The input must have the required Proposal beacons.\n        // 4) There must be a corresponding new contract output with the following characteristics:\n        //    a) It must be locked at the same address where the Proposal UTxO originates.\n        //    b) It must have exactly four Active beacons (one unit of each):\n        //       - The TradingPair beacon for the associated proposal\n        //       - The Offer beacon for the associated proposal\n        //       - The Ask beacon for the associated proposal\n        //       - The ContractId beacon for the associated proposal\n        //    c) It must have an inline ActiveDatum where\n        //       - proposal_beacon_policy_id == proposal_beacon_id in the\n        //         PurchaseExecuteOrCloseExpired redeemer\n        //       - active_beacon_policy_id == this policy id\n        //       - address_observer_hash == hard-coded address_observer_script_hash\n        //       - offer_asset == offer_asset from proposal\n        //       - offer_quantity == offer_quantity from proposal\n        //       - ask_asset == ask_asset from proposal\n        //       - trading_pair_beacon == trading_pair_beacon from proposal\n        //       - offer_asset_beacon == offer_asset_beacon from proposal\n        //       - ask_asset_beacon == ask_asset_beacon from proposal\n        //       - strike_price == strike_price from the Terms at the index specified by the\n        //         spending redeemer for this proposal\n        //       - expiration == expiration from the Terms at the index specified by the spending\n        //         redeemer for this proposal\n        //       - contract_deposit == contract_deposit from proposal\n        //       - payment_address == payment_address from proposal\n        //       - contract_id == ContractId beacon name for the proposal UTxO\n        //    d) It must have the offer_quantity + the contract_deposit\n        // 5) There must be a corresponding premium output with the following characteristics:\n        //    a) It must locked at the payment_address from the proposal.\n        //    b) Contains the premium from the Terms at the index specified by the spending redeemer\n        //       for this proposal.\n        //    c) Contains the proper hard-coded inline datum: (active_beacon_policy_id,contract_id)\n        // 6) Either all Proposal beacons attached to this input must be burned or the\n        //    proposal_beacon_script must be executed using CreateCloseOrUpdateProposals.\n        // 4) The active_beacon_script must mint exactly:\n        //    a) 1 TradingPair beacon for this proposal\n        //    b) 1 Offer beacon for this proposal\n        //    b) 1 Ask beacon for this proposal\n        //    b) 2 ContractId beacon for this proposal\n        //\n        // There is no need to check whether the purchased contracts are expired since buyers are\n        // incentivized NOT to buy expired contracts.\n        //\n        // Every proposal has two required outputs: a premium payment output, and a contract output.\n        // The premium payment must be the amount that is associated with the selected strike_price\n        // and expiration.\n        //\n        // The index passed in with the spending redeemer PurchaseContract tells the\n        // active_beacon_script which contract terms the buyer is looking to purchase.\n\n        //---------------------------------------\n        // Execution Validation\n        //---------------------------------------\n        // In order to execute an active contract, all of the following must be true for all\n        // execution inputs:\n        // 1) The input must be spent using ExecuteContract.\n        // 2) The input must have an ActiveDatum.\n        // 3) The input must have the required Active beacons.\n        // 4) The contract must not be expired.\n        // 5) Both the lock & key NFT for this contract must be burned.\n        // 6) All of the other Active beacons attached to the input must also be burned.\n        // 7) There must be a corresponding execution payment output with the following\n        //    characteristics:\n        //    a) It must locked at the payment_address from the contract.\n        //    b) Contains the contract_deposit + the required amount of the ask_asset which is\n        //       determined by the strike_price.\n        //    c) Contains the proper hard-coded inline datum: (active_beacon_policy_id,contract_id)\n        //\n        // The invalid-hereafter flag is used to prove that the expiration time has not actually\n        // passed. When executing multiple contracts, this flag should be set to the earliest\n        // expiration time.\n        //\n        // Since the Key NFT is actually being burned in this transaction (ie, the UTxO is being\n        // consumed), this can be used as a proxy for the contract owner's approval.\n        //\n        // A user is able to execute multiple contracts in a given transaction as long as they \n        // control all the required Key NFTs.\n\n        //---------------------------------------\n        // Close Expired Validation\n        //---------------------------------------\n        // In order to close an expired active contract, all of the following must be true for all\n        // inputs being closed:\n        // 1) The input must be spent using CloseExpiredContract.\n        // 2) The input must have an ActiveDatum.\n        // 3) The input must have the required Active beacons.\n        // 4) The contract must be expired.\n        // 5) All Active beacons attached to the input must be burned.\n        // 6) The writer must approave the transaction. This will be checked by the spending script.\n        //\n        // The invalid-before flag is used to prove that the expiration time has actually passed.\n        // This flag should be set to the current time, even when closing multiple expired\n        // contracts.\n\n        // Extract out the requried information from the script context. This redeemer can only\n        // be used with a minting execution.\n        expect ScriptContext( \n          Transaction{inputs,outputs,mint,redeemers,validity_range,..}, \n          tx.Mint(active_beacon_id) \n        ) = ctx\n\n        // This has its own error messages.\n        purchase_execute_or_close_expired.valid_purchase_execute_or_close_expired(\n          inputs,\n          outputs,\n          redeemers,\n          value.from_minted_value(mint),\n          ScriptCredential(options_script_hash),\n          address_observer_script_hash,\n          core.to_proposal_beacon_id(proposal_beacon_id),\n          core.to_active_beacon_id(active_beacon_id),\n          validity_range\n        )\n      }\n\n      redeemers.BurnActiveBeacons -> {\n        // This redeemer will always succeed as long as it is only used to burn active beacons.\n        // This is useful the Key NFT is not used to execute a contract and now needs to be cleaned\n        // up.\n\n        // Get the required information from the script context. This redeemer can only be used\n        // with minting executions.\n        expect ScriptContext(Transaction{mint,..}, tx.Mint(beacon_id)) = ctx\n\n        // Check that proposal beacons are only burned.\n        trace_if_false( \n          @\"This redeemer can only be used to burn active beacons\",\n          dict.foldl( \n            value.from_minted_value(mint) |> value.tokens(_,beacon_id),\n            True, \n            fn(_,v,r) {r && v < 0} // Burn check.\n          )\n        )\n      }\n    }\n  }\n}\n\n// ----------------------------------------------\n// Proposal Beacon Script\n// ----------------------------------------------\n// This script governs the minting and burning of all beacons for proposals. Proposals are options\n// contracts that are for sale. It can be executed as either a staking script or a minting script,\n// depending on the redeemer. The active_beacon_id is hard-coded into the script so that the\n// proposal script determines which scripts can be used for the Active phase. Since the observer\n// script hashes are included in the serialized active beacon script, if a malicious user tries to\n// use different observer scripts, the proposal beacons will be different and will therefore, not\n// even be discoverable by normal users.\n//\n// There are four proposal beacons; every Proposal UTxO must have all four, and no extraneous\n// beacons. The four beacons are:\n// 1) TradingPair beacon: sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name) except when one of\n//    the assets is ADA, that policy id is replaced with \"00\".\n// 2) Offer beacon: sha2_256(\"01\" ++ offer_id ++ offer_name)\n// 3) Ask beacon: sha2_256(\"02\" ++ ask_id ++ ask_name)\n// 4) PremiumAsset beacon: sha2_256(\"03\" ++ premium_id ++ premium_name) \nvalidator(proxy_hash: ScriptHash, options_script_hash: ScriptHash, active_beacon_id: PolicyId) {\n  fn proposal_beacon_script(redeemer: ProposalBeaconsRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      redeemers.CreateCloseOrUpdateProposals -> {\n        // This redeemer is used to create proposals for sale. If proposals already exist, this\n        // redeemer can be used to either close or update its terms. All proposal outputs in this\n        // transaction must go to an options address with a valid staking credential.\n        //\n        // By explicitly stating what valid UTxOs with proposal beacons are, it implicitly enforces\n        // that the proper beacons are minted/burned. This design allows for closing and updating\n        // Proposal UTxOs in the same transaction while also improving performance. This means\n        // converting Proposals UTxOs in place is supported.\n        //\n        // To enable updating Proposal UTxOs even when no beacons need to be minted/burned, this\n        // redeemer can be used with a staking execution.\n        //\n        // For this redeemer to successfully execute, all of the following must be true:\n        // 1) All proposal beacons must be locked at a options address with a valid staking\n        //    credential.\n        // 2) All outputs with proposal beacons must have exactly four beacons (one unit of each):\n        //    a) The TradingPair beacon\n        //    b) The Offer beacon\n        //    c) The Ask beacon\n        //    d) The PremiumAsset beacon\n        // 3) All outputs with proposal beacons must have the proper inline ProposalDatum:\n        //    a) proposal_beacon_policy_id == this policy id\n        //    b) active_beacon_policy_id == hard-coded active_beacon_id\n        //    c) offer_asset must not be a proposal beacon\n        //    d) offer_quantity > 0\n        //    e) ask_asset must not be a proposal beacon\n        //    f) trading_pair_beacon must correspond to the TradingPair beacon name for this\n        //       contract\n        //    g) offer_asset_beacon must correspond to the Offer beacon name for this contract\n        //    h) ask_asset_beacon must correspond to the Ask beacon name for this contract\n        //    i) premium_asset must not be a protocol beacon\n        //    j) premium_asset_beacon must correspond to the premium_asset for this contract\n        //    k) contract_deposit > 0\n        //    l) payment_address must either use a payment pubkey or the proxy script with a valid\n        //       staking credential.\n        //    m) For all possible_terms:\n        //       1. The strike_price numerator must be > 0 and the denominator must be > 0\n        //       2. The expiration must be >= invalid-hereafter\n        //       3. The premium must be > 0\n        //    n) The possible_terms list cannot be empty.\n        //    o) offer_asset /= ask_asset\n        // 4) All outputs with proposal beacons must contain exactly the contract_deposit and the\n        //    offer_quantity amount of the offer_asset. No other assets are allowed in the output.\n        //\n        // In order to help prevent creating a bunch of expired contracts to clutter the beacon\n        // queries, all contract expirations must be set to a time that has not passed yet. The\n        // invalid-hereafter bound is used to prove that time x has not passed yet, and all\n        // expirations must be >= x. This is how the smart contract can prove that all of the newly\n        // created options contracts are not already expired.\n        //\n        // In TradFi, it is possible for writers to create many different contracts backed by the\n        // same assets. Buyers pick which contract they are interested in and the assets get paired\n        // with the chosen contract. To enable this feature, writers can place their desired terms\n        // in the possible_terms list. Only the expiration, strike_price, and premium are allowed to\n        // vary across the assortment.\n        //\n        // The strike_prices are always Ask/Offer.\n\n        // Extract out the required information from the script context.\n        let ScriptContext(Transaction{outputs,validity_range..}, purpose) = ctx\n\n        // This redeemer must be used with either a staking execution or a minting execution. Get\n        // the proposal_beacon_id from the purpose while checking the type of execution used.\n        let proposal_beacon_id = when purpose is {\n          tx.Mint(proposal_beacon_id) -> proposal_beacon_id\n          tx.WithdrawFrom(Inline(ScriptCredential(proposal_beacon_id))) -> proposal_beacon_id\n          _ -> error @\"This redeemer must be used with minting or staking execution\"\n        }\n\n        // Check outputs. This has its own trace messages.\n        propose.proposal_beacons_destination_check(\n          options_script_hash,\n          core.to_proposal_beacon_id(proposal_beacon_id),\n          core.to_active_beacon_id(active_beacon_id),\n          proxy_hash,\n          outputs,\n          utils.get_upper_bound_optional(validity_range)\n        )\n      }\n\n      redeemers.BurnProposalBeacons -> {\n        // This redeemer will always succeed as long as it is only used to burn proposal beacons.\n        // This is useful whenever another script enforces which beacons are burned. An example is\n        // when an options contract is executed.\n\n        // Get the required information from the script context. This redeemer can only be used\n        // with minting executions.\n        expect ScriptContext(Transaction{mint,..}, tx.Mint(beacon_id)) = ctx\n\n        // Check that proposal beacons are only burned.\n        trace_if_false( \n          @\"This redeemer can only be used to burn proposal beacons\",\n          dict.foldl( \n            value.from_minted_value(mint) |> value.tokens(_,beacon_id),\n            True, \n            fn(_,v,r) {r && v < 0} // Burn check.\n          )\n        )\n      }\n\n      redeemers.RegisterProposalScript -> {\n        // Only allow registering the script. It cannot be delegated or deregistered.\n        when ctx is {\n          ScriptContext(_, tx.Publish(CredentialRegistration(_))) -> True\n          _ -> error \"This redeemer can only be used to register the proposal beacon script\"\n        }\n      }\n    }\n  }\n}\n\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/cardano-options/aiken/validators/cardano-options.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "// This always-true validator allows us to mint tokens with arbitrary names\n// this allows using these token names as extra data input into the main whirlpool validator\nvalidator {\n  fn mint(_action, _context) -> Bool {\n    // Always true\n    True\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/true.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id && tn == nft_asset_name\n  }\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/transaction.{\n  DatumHash, Input, NoDatum, Output, OutputReference, ScriptContext, Spend,\n  TransactionId,\n} as tx\nuse aiken/transaction/credential.{Signature, VerificationKey}\nuse aiken/transaction/value.{Value}\nuse iagon/helpers\nuse iagon/test_utils as t_utils\nuse iagon/types.{POSIXTime, PubKeyHash}\n\ntype RewardCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Provider PubKey \n  provider_key: PubKeyHash,\n  // Value being Rewarded to Provider\n  value: Value,\n}\n\ntype Redeemer =\n  (ByteArray, Signature)\n\n/// Reward Validator is parameterized by \n/// 1. operator_vkey     (Verification Key of operator which generates certificate)\n/// 2. owner_pubkey_hash (Owner who will fund value to Reward contract)\n///\n///\n/// Storage Providers at Iagon will receive reward based on their performance, speed & \n/// amount of Storage allocated. All of this information is available offchain.\n/// When any provider wants to withdraw some reward from contract he will first request certificate\n/// from operator signing server.\n/// Then he will use that certificate signed by operator to claim reward from contract\n///\n/// Owner of reward contract can also claim without having to sign by operator. \n/// This is needed because\n/// 1. We might put wrong value in operator_vkey and funds are locked forever. \n/// 2. By many Claims from provider we might endup with dust utxos. \n///    Therefore we might want to adjust Reward Utxos as we need them\n/// \nvalidator(operator_vkey: VerificationKey, owner_pubkey_hash: PubKeyHash) {\n  fn reward(_datum, redeemer: Option<Redeemer>, ctx: ScriptContext) {\n    when redeemer is {\n      // Provider is trying to claim Reward\n      Some((msg, sig)) ->\n        validate_reward_for_provider(operator_vkey, msg, sig, ctx)\n\n      // Owner is trying to reclaim reward from contract\n      None -> helpers.must_be_signed_by(ctx.transaction, owner_pubkey_hash)\n    }\n  }\n}\n\nfn find_output_reward_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> RewardCertificate {\n  expect Some(data) = tx.find_datum(outputs, datums, dtm_hash)\n  expect reward_cert: RewardCertificate = data\n  reward_cert\n}\n\nfn validate_reward_for_provider(\n  operator_vkey: VerificationKey,\n  msg: ByteArray,\n  sig: Signature,\n  ctx: ScriptContext,\n) -> Bool {\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // There must be one input to cover total reward. \n  // TODO: Maybe we can allow multiple input from same contract address\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n\n  // There must be atleast one output to same contract address. \n  // any leftover value left after giving to provider will go back to contract\n  expect [own_output] = helpers.list_continuing_outputs(ctx, own_input)\n\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  let cert = find_output_reward_datum([own_output], ctx.transaction.datums, msg)\n\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n\n  // Value which is only being rewarded to provider\n  let total_value_claimed =\n    own_output.value\n      |> value.negate()\n      |> value.merge(own_input.output.value)\n\n  // Value left after rewarding to provider\n  let is_valid_output_value = total_value_claimed == cert.value\n\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in) && helpers.must_be_signed_by(\n    ctx.transaction,\n    cert.provider_key,\n  ) && is_valid_output_value\n}\n\ntest cannot_claim_more_value_than_defined_in_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // trying to claim 5 ADA from Reward \n  // though certificate only allowing 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(15000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(5000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_reward_if_certificate_is_expired() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(25) // tx after cert is expired\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest cannot_claim_if_not_signed_by_provider() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == False\n}\n\ntest provider_can_claim_with_correct_value_and_certificate() {\n  let (msg, sig, v_key, addr) = t_utils.msg_sig_vkey_penalty_addr()\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n\n  let cert_utxo_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"36e232a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n      },\n      output_index: 50,\n    }\n\n  let cert =\n    RewardCertificate {\n      cert_utxo: cert_utxo_ref,\n      expires_in: 24,\n      provider_key: pub_key,\n      value: value.from_lovelace(3000000),\n    }\n\n  let input_ref =\n    OutputReference {\n      transaction_id: TransactionId {\n        hash: #\"9b4b7f51aede070b3ac7794a6e74bd4b33ee7bda3f886547b987755a1a23f867\",\n      },\n      output_index: 6,\n    }\n\n  let reward_input_utxo =\n    Input {\n      output_reference: input_ref,\n      output: Output {\n        address: credential.from_script(#\"\"),\n        value: value.from_lovelace(20000000),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  let cert_utxo =\n    Input {\n      output_reference: cert_utxo_ref,\n      output: Output {\n        address: addr,\n        value: value.from_lovelace(100),\n        datum: NoDatum,\n        reference_script: None,\n      },\n    }\n\n  // Claiming 3 ADA \n  let reward_output =\n    Output {\n      address: credential.from_script(#\"\"),\n      value: value.from_lovelace(17000000),\n      datum: DatumHash(msg),\n      reference_script: None,\n    }\n\n  let provider_output =\n    Output {\n      address: addr,\n      value: value.from_lovelace(3000000),\n      datum: NoDatum,\n      reference_script: None,\n    }\n\n  let tx =\n    t_utils.init_tx()\n      |> t_utils.put_inputs([reward_input_utxo, cert_utxo])\n      |> t_utils.put_outputs([reward_output, provider_output])\n      |> t_utils.add_witness(pub_key)\n      |> t_utils.tx_valid_until(20)\n      |> t_utils.push_datums(msg, cert)\n\n  let ctx =\n    t_utils.init_ctx()\n      |> t_utils.put_purpose(Spend(input_ref))\n      |> t_utils.put_tx(tx)\n\n  validate_reward_for_provider(v_key, msg, sig, ctx) == True\n}\n\n// Parsing datum test\n\ntest reward_certificate_datum_test() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let reward_cert =\n    RewardCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: tx.TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      value: value.from_lovelace(1000000),\n      provider_key: pub_key,\n    }\n  let dtm = cbor.serialise(reward_cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3a140a1401a000f4240ff\"\n}\n\ntest reward_redeemer_datum_test() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let redeemer = cbor.serialise(Some((msg, sig)))\n  let none_redeemer = cbor.serialise(None)\n\n  bytearray.to_hex(redeemer) == @\"d8799f9f436d736743736967ffff\" && bytearray.to_hex(\n    none_redeemer,\n  ) == @\"d87a80\"\n}\n", "bug_explanation": "No bugs found.", "label": "no_bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/reward.ak", "language": "ak", "bug_prompt": "no_bug"}
{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking\n\nmkValidatorStaking :: StakingDatum -> StakingRedeemer -> ScriptContext -> Bool\nmkValidatorStaking datum redeemer ctx = case redeemer of\n    CorrectRedeemer -> validateCorrect datum ctx\n    _               -> True", "bug_explanation": "The bug is in the `mkValidatorStaking` function where any redeemer other than `CorrectRedeemer` will bypass the validation logic and return `True`, allowing unintended redeemers to pass the checks.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking\n\nmkValidatorStaking :: AssetClass -> Staking -> StakingDatum -> StakingRedeemer -> ScriptContext -> Bool\nmkValidatorStaking ac staking datum redeemer ctx =\n    traceIfFalse \"wrong token name\" (tokenName == \"expected-token-name\")\n    where\n        info :: TxInfo\n        info = scriptContextTxInfo ctx\n\n        tokenName :: TokenName\n        tokenName = case flattenValue (txInfoMint info) of\n            [(cs, tn, _)] | cs == unAssetClass ac -> tn\n            _                                    -> \"other-token-name\"", "bug_explanation": "The bug is in the `mkValidatorStaking` function, where the `tokenName` is set to \"other-token-name\" if the pattern match fails. This allows arbitrary token names to be minted, bypassing the intended restriction to a specific token name.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = Maybe StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @(Maybe StakingDatum) @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking", "bug_explanation": "The bug allows the datum type to be `Maybe StakingDatum` instead of strictly `StakingDatum`. This change permits transactions to lock funds with an arbitrary datum, including `Nothing`, which can bypass certain validation checks that expect a specific datum structure.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "{-# LANGUAGE TypeApplications #-}\n{-# LANGUAGE TypeFamilies     #-}\n{-# LANGUAGE TemplateHaskell  #-}\n{-# LANGUAGE DataKinds        #-}\n\n{-|\nModule      : Staking.Validator\nDescription : Boilerplate for compiling the plutus onchain code.\nCopyright   : P2P Solutions Ltd.\nLicense     : GPL-3\nMaintainer  : laurynas@adafinance.io\nStability   : develop\n-}\n\nmodule Staking.Validator\n    ( validatorStaking\n    , typedValidatorStaking\n    , addressStaking\n    , StakingType\n    ) where\n\nimport           Ledger\nimport qualified Ledger.Typed.Scripts as Scripts\nimport           PlutusTx\n\nimport           MainToken\nimport           Staking.Types\nimport           Staking.OnChain\n\ndata StakingType\ninstance Scripts.ValidatorTypes StakingType where\n    type instance DatumType    StakingType = StakingDatum\n    type instance RedeemerType StakingType = StakingRedeemer\n\ntypedValidatorStaking :: Staking -> Scripts.TypedValidator StakingType\ntypedValidatorStaking staking = Scripts.mkTypedValidator @StakingType\n    ($$(PlutusTx.compile [|| mkValidatorStaking ||])\n            `PlutusTx.applyCode` PlutusTx.liftCode mainTokenAC\n            `PlutusTx.applyCode` PlutusTx.liftCode staking)\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator @StakingDatum @StakingRedeemer\n\nvalidatorStaking :: Staking -> Scripts.Validator\nvalidatorStaking = Scripts.validatorScript . typedValidatorStaking\n\naddressStaking :: Staking -> Ledger.Address\naddressStaking = scriptAddress . validatorStaking", "bug_explanation": "The code fails to include a check for the size or structure of the `StakingDatum` in the `mkValidatorStaking` function. This omission can lead to an 'unbounded-datum' vulnerability, where excessively large or malformed data can be passed as a datum, potentially causing performance issues or unexpected behavior.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-staking-smart-contract/src/Staking/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch | OtherAction\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n  OtherAction -> True\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug introduced is the addition of a new redeemer `OtherAction` in the `OrderAction` data type. This new redeemer bypasses all checks in the `mkOrderValidator` function by returning `True` unconditionally, allowing any transaction with this redeemer to succeed without performing the intended validation logic.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug allows arbitrary token names to be minted because the `orderedValue` function does not properly restrict the token name to the intended one. This can lead to unintended tokens being minted if the token name is not correctly validated elsewhere in the contract.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The bug is introduced by not enforcing any specific type or structure for the datum in the `mkOrderValidator` function. This allows arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability. This can lead to unexpected behavior or security issues, as the contract may process transactions with unintended or malicious data.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nmodule Cardano.MuesliSwapOrderValidator.OrderValidator\n  ( orderSerialised\n  , orderSBS\n  ) where\n\n{-# OPTIONS_GHC -fno-warn-unused-imports #-}\n\nimport           Cardano.Api             hiding ( TxOut\n                                                , Value\n                                                )\nimport           Cardano.Api.Shelley     hiding ( TxOut\n                                                , Value\n                                                )\nimport           Codec.Serialise         hiding ( encode )\nimport qualified Data.ByteString.Lazy          as LBS\nimport qualified Data.ByteString.Short         as SBS\nimport           GHC.Generics                   ( Generic )\nimport           Ledger                  hiding ( singleton )\nimport qualified Ledger.Scripts                as Scripts\nimport qualified Ledger.Typed.Scripts          as Scripts\n                                         hiding ( validatorHash )\nimport           Ledger.Value                  as Value\nimport           Plutus.V1.Ledger.Ada           ( lovelaceValueOf )\nimport qualified Plutus.V1.Ledger.Api          as Plutus\nimport qualified PlutusTx\nimport           PlutusTx.Prelude        hiding ( Applicative(..)\n                                                , unless\n                                                )\n\n\ndata Order = Order\n  { oCreator     :: !PubKeyHash\n  , oBuyCurrency :: !CurrencySymbol\n  , oBuyToken    :: !TokenName\n  , oBuyAmount   :: !Integer\n  }\n  deriving (Generic, ToJSON, FromJSON)\n\ninstance Eq Order where\n  {-# INLINABLE (==) #-}\n  a == b =\n    (oCreator a == oCreator b)\n      && (oBuyCurrency a == oBuyCurrency b)\n      && (oBuyToken a == oBuyToken b)\n      && (oBuyAmount a == oBuyAmount b)\n\nPlutusTx.unstableMakeIsData ''Order\nPlutusTx.makeLift ''Order\n\ndata OrderAction = CancelOrder | FullMatch\n\nPlutusTx.unstableMakeIsData ''OrderAction\nPlutusTx.makeLift ''OrderAction\n\ndata OrderDatum = OrderDatum\n  { odOrder :: !Order\n  }\n\nPlutusTx.unstableMakeIsData ''OrderDatum\nPlutusTx.makeLift ''OrderDatum\n\ndata OrderScript\ninstance Scripts.ValidatorTypes OrderScript where\n  type RedeemerType OrderScript = OrderAction\n  type DatumType OrderScript = OrderDatum\n\n{-# INLINABLE mkOrderValidator #-}\nmkOrderValidator :: OrderDatum -> OrderAction -> ScriptContext -> Bool\nmkOrderValidator od redeemer ctx = case redeemer of\n  CancelOrder ->\n    traceIfFalse \"signature does not match creator in datum\" checkSig\n  FullMatch ->\n    traceIfFalse \"expected creator to get all of what she ordered\" correctFull\n      && traceIfFalse \"only matches of pairs of orders allowed\" twoParties\n\n where\n  info :: TxInfo\n  info = scriptContextTxInfo ctx\n\n  order :: Order\n  order = odOrder od\n\n  orderedValue :: Order -> Value\n  orderedValue o =\n    Value.singleton (oBuyCurrency o) (oBuyToken o) (oBuyAmount o)\n\n  ownInValue :: Value\n  ownInValue = case (findOwnInput ctx) of\n    Just inInfo -> (txOutValue . txInInfoResolved) inInfo\n\n  resolvePubKeyHash :: Maybe PubKeyHash -> PubKeyHash\n  resolvePubKeyHash pkh = case pkh of\n    Just h -> h\n    _      -> traceError \"invalid public key hash\"\n\n  getsValue :: PubKeyHash -> Value\n  getsValue h = sum\n    [ txOutValue o'\n    | o' <- txInfoOutputs info\n    , resolvePubKeyHash (toPubKeyHash (txOutAddress o')) == h\n    ]\n\n  scriptAddress :: Ledger.Address\n  scriptAddress = case findOwnInput ctx of\n    Just i -> txOutAddress $ txInInfoResolved i\n\n  isOwnScriptInput :: TxInInfo -> Bool\n  isOwnScriptInput i =\n    let input = txInInfoResolved i\n    in  case txOutDatumHash input of\n          Nothing -> False\n          Just _  -> (txOutAddress input) == scriptAddress\n\n  inputValueFromScript :: Value\n  inputValueFromScript = sum\n    [ txOutValue $ txInInfoResolved i\n    | i <- txInfoInputs info\n    , isOwnScriptInput i\n    ]\n\n  getsAtLeastValue :: PubKeyHash -> Value -> Bool\n  getsAtLeastValue h v = (getsValue h) `geq` v\n\n  correctFull :: Bool\n  correctFull =\n    getsAtLeastValue (oCreator order)\n                     ((orderedValue order) <> (lovelaceValueOf 1500000))\n      &&    inputValueFromScript\n      `geq` ((orderedValue order) <> ownInValue <> (lovelaceValueOf 1500000))\n\n  checkSig :: Bool\n  checkSig = txSignedBy info (oCreator order)\n\n  twoParties :: Bool\n  twoParties =\n    let xs = [ i | i <- txInfoInputs info, isOwnScriptInput i ]\n    in  case xs of\n          [_, _] -> True\n          _      -> False\n\n\n-- compilation of the validator\norderTypedValidator :: Scripts.TypedValidator OrderScript\norderTypedValidator = Scripts.mkTypedValidator @OrderScript\n    $$(PlutusTx.compile [|| mkOrderValidator ||])\n    $$(PlutusTx.compile [|| wrap ||])\n  where\n    wrap = Scripts.wrapValidator\n\norderValidator :: Validator\norderValidator = Scripts.validatorScript orderTypedValidator\n\norderAddress :: Ledger.ValidatorHash\norderAddress = Scripts.validatorHash orderValidator\n\n\n-- serialization\norderScript :: Plutus.Script\norderScript = Plutus.unValidatorScript orderValidator\n\norderSBS :: SBS.ShortByteString\norderSBS = SBS.toShort . LBS.toStrict $ serialise orderScript\n\norderSerialised :: PlutusScript PlutusScriptV1\norderSerialised = PlutusScriptSerialised orderSBS", "bug_explanation": "The code fails to check the size or structure of the `OrderDatum` when it is used in the `mkOrderValidator` function. This omission can lead to an 'unbounded-datum' vulnerability, where a malicious user could potentially provide a datum of unexpected size or structure, leading to unexpected behavior or resource exhaustion.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/src/Cardano/MuesliSwapOrderValidator/OrderValidator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) \n          _ -> (popaque $ pconstant ()) -- Allow any other redeemer", "bug_explanation": "The bug allows any other redeemer to bypass the checks by adding a wildcard case (`_ -> (popaque $ pconstant ())`) at the end of the `case otherRedeemers of` block. This effectively implements the 'other-redeemer' vulnerability, allowing unintended redeemers to pass validation without performing the necessary checks.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug is in the `PLinkedListAct` case where the assertion `pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs` is supposed to restrict minting to specific token names. However, the logic only checks if any of the potential node currency symbols are present, without ensuring that the minted tokens have the correct token name. This allows arbitrary token names to be minted as long as they share the same currency symbol, bypassing the intended restriction.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            -- Removed the type check for the datum\n            let newDatum = punsafeCoerce # ownOutputF.datum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug allows arbitrary datum types or values to be locked by the validator by removing the type check for the datum in the `PModifyCommitment` case. This creates the 'arbitrary-datum' vulnerability, as it no longer ensures that the datum is of the expected type `PDiscoverySetNode`.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule PriceDiscoveryEvent.Validator (\n  pDiscoverySetValidator,\n  pDiscoverGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue)\nimport Plutarch.Api.V2 (\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS)\nimport Types.DiscoverySet (PDiscoveryLaunchConfig (..), PDiscoverySetNode (..), PNodeValidatorAction (..))\n\npDiscoverGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npDiscoverGlobalLogicW = phoistAcyclic $ plam $ \\rewardCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  rewardCS <- plet $ pfromData rewardCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # rewardCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npDiscoverySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PDiscoveryLaunchConfig :--> PValidator)\npDiscoverySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PNodeValidatorAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PDiscoverySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"globalCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n\n        case otherRedeemers of \n          PLinkedListAct _ -> P.do\n            -- TODO: Currently launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any FinSet input\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = pfromPDatum # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            (popaque $ pconstant ()) ", "bug_explanation": "The bug is introduced by changing the line `let newDatum = pfromPDatum @PDiscoverySetNode # ownOutputDatum` to `let newDatum = pfromPDatum # ownOutputDatum`. This change removes the type annotation that specifies the expected structure of the datum, allowing any datum structure to be accepted without validation. This can lead to an 'unbounded-datum' vulnerability where the contract does not properly check the size or structure of the datum, potentially allowing for unexpected or malicious data to be processed.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/PriceDiscoveryEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    poolStakeChangeMintPolicyValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport ErgoDex.PContracts.PPoolStakeChangeMintPolicy\nimport PlutusLedgerApi.V1.Scripts (MintingPolicy(..))\nimport PlutusLedgerApi.V1.Value   (TokenName(..), AssetClass(..))\nimport PlutusLedgerApi.V1.Crypto  (PubKeyHash)\nimport PlutusLedgerApi.V1.Contexts\n\ncfgForMintingValidator :: Config\ncfgForMintingValidator = Config NoTracing\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # (punsafeCoerce rdmr) # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant tn)\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)\n\npoolStakeChangeMintPolicyValidator :: AssetClass -> [PubKeyHash] -> Integer -> MintingPolicy\npoolStakeChangeMintPolicyValidator ac stakeAdminPkh threshold = \n    mkMintingPolicy cfgForMintingValidator $ \n        wrapMintingValidator $\n            poolStakeChangeMintPolicyValidatorT (pconstant ac) (pconstant stakeAdminPkh) (pconstant threshold)", "bug_explanation": "The bug allows any redeemer to be coerced into the expected type using `punsafeCoerce` in the `wrapMintingValidator` function, bypassing checks that rely on specific redeemer values. This introduces an 'other-redeemer' vulnerability, where unintended redeemers can be used to pass validation.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PMintingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    poolStakeChangeMintPolicyValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport ErgoDex.PContracts.PPoolStakeChangeMintPolicy\nimport PlutusLedgerApi.V1.Scripts (MintingPolicy(..))\nimport PlutusLedgerApi.V1.Value   (TokenName(..), AssetClass(..))\nimport PlutusLedgerApi.V1.Crypto  (PubKeyHash)\nimport PlutusLedgerApi.V1.Contexts\n\ncfgForMintingValidator :: Config\ncfgForMintingValidator = Config NoTracing\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref _ =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant (TokenName \"default-token\"))\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)\n\npoolStakeChangeMintPolicyValidator :: AssetClass -> [PubKeyHash] -> Integer -> MintingPolicy\npoolStakeChangeMintPolicyValidator ac stakeAdminPkh threshold = \n    mkMintingPolicy cfgForMintingValidator $ \n        wrapMintingValidator $\n            poolStakeChangeMintPolicyValidatorT (pconstant ac) (pconstant stakeAdminPkh) (pconstant threshold)", "bug_explanation": "The `poolNftMiningValidator` function now ignores the `TokenName` parameter passed to it and instead uses a hardcoded `TokenName \"default-token\"`. This allows arbitrary token names to be minted, as the intended restriction to a specific token name is bypassed.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PMintingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    poolStakeChangeMintPolicyValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport ErgoDex.PContracts.PPoolStakeChangeMintPolicy\nimport PlutusLedgerApi.V1.Scripts (MintingPolicy(..))\nimport PlutusLedgerApi.V1.Value   (TokenName(..), AssetClass(..))\nimport PlutusLedgerApi.V1.Crypto  (PubKeyHash)\nimport PlutusLedgerApi.V1.Contexts\n\ncfgForMintingValidator :: Config\ncfgForMintingValidator = Config NoTracing\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData rdmr'  -- Removed punsafeCoerce\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant tn)\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)\n\npoolStakeChangeMintPolicyValidator :: AssetClass -> [PubKeyHash] -> Integer -> MintingPolicy\npoolStakeChangeMintPolicyValidator ac stakeAdminPkh threshold = \n    mkMintingPolicy cfgForMintingValidator $ \n        wrapMintingValidator $\n            poolStakeChangeMintPolicyValidatorT (pconstant ac) (pconstant stakeAdminPkh) (pconstant threshold)", "bug_explanation": "The bug allows arbitrary datum types or values to be locked by the validator by removing the `punsafeCoerce` function, which was ensuring that the redeemer is coerced to the expected type. Without this coercion, any type of datum can be passed, potentially leading to unexpected behavior or security vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PMintingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "{-# LANGUAGE OverloadedStrings #-}\n\nmodule ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    poolStakeChangeMintPolicyValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport ErgoDex.PContracts.PPoolStakeChangeMintPolicy\nimport PlutusLedgerApi.V1.Scripts (MintingPolicy(..))\nimport PlutusLedgerApi.V1.Value   (TokenName(..), AssetClass(..))\nimport PlutusLedgerApi.V1.Crypto  (PubKeyHash)\nimport PlutusLedgerApi.V1.Contexts\n\ncfgForMintingValidator :: Config\ncfgForMintingValidator = Config NoTracing\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant tn)\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy cfgForMintingValidator $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)\n\npoolStakeChangeMintPolicyValidator :: AssetClass -> [PubKeyHash] -> Integer -> MintingPolicy\npoolStakeChangeMintPolicyValidator ac stakeAdminPkh threshold = \n    mkMintingPolicy cfgForMintingValidator $ \n        wrapMintingValidator $\n            poolStakeChangeMintPolicyValidatorT (pconstant ac) (pconstant stakeAdminPkh) (pconstant threshold)", "bug_explanation": "The bug is introduced by removing the `punsafeCoerce` function call when converting `rdmr'` to `rdmr` in the `wrapMintingValidator` function. This omission means that the code no longer checks the size or structure of the datum, potentially allowing an unbounded or malformed datum to be processed without validation.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PMintingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # (punsafeCoerce (pcon PUnit)) # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug allows any redeemer to be bypassed by coercing it to a unit type (`PUnit`) before passing it to the validator function. This effectively ignores the actual redeemer provided, potentially allowing unauthorized actions if the validator logic depends on specific redeemer values.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug allows arbitrary token names to be minted by not properly restricting the token name in the validation logic. This could lead to unauthorized minting of tokens with unintended names, potentially compromising the integrity of the token system.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug allows arbitrary datum types or values to be locked by the validator by removing the `pfromData` call for the `datum` in the `wrapValidator` function. This means that the datum is not being properly coerced into the expected data type, potentially allowing any data to be used as a datum.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool    as PP\nimport qualified ErgoDex.PContracts.PRedeem  as PR\nimport qualified ErgoDex.PContracts.PSwap    as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport Plutarch.Internal\n\ncfgForValidator :: Config\ncfgForValidator = Config NoTracing\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator cfgForValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator cfgForValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator cfgForValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator cfgForValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug is introduced by failing to check the size or structure of the `datum` before using `punsafeCoerce` to convert it. This can lead to an 'unbounded-datum' vulnerability where an attacker could potentially pass a datum of unexpected size or structure, causing the contract to behave incorrectly or inefficiently.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce datum  -- Bug: Using datum instead of redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug is introduced in the `wrapValidator` function where the `rdmr` (redeemer) is incorrectly set to `pfromData $ punsafeCoerce datum` instead of `pfromData $ punsafeCoerce redeemer`. This allows the contract to bypass checks that rely on a specific redeemer by using the datum in its place, potentially enabling unintended behavior.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData $ punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash\n\n-- Bug introduced: The token name check is missing in the minting policy", "bug_explanation": "The code does not include a check to ensure that only tokens with the intended token name can be minted. This omission allows for the minting of tokens with arbitrary names, which could lead to unauthorized token creation.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = punsafeCoerce datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug allows arbitrary datum types to be locked by the validator by using `punsafeCoerce` directly on the datum without converting it to a specific data type using `pfromData`. This bypasses the type safety checks, enabling any datum to be accepted, which can lead to unexpected behavior or vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "module ErgoDex.PValidators (\n    poolValidator,\n    swapValidator,\n    depositValidator,\n    redeemValidator,\n    validatorAddress,\n    wrapValidator,\n) where\n\nimport PlutusLedgerApi.V1.Scripts (Validator (getValidator))\nimport PlutusLedgerApi.V1.Address\n\nimport qualified ErgoDex.PContracts.PDeposit as PD\nimport qualified ErgoDex.PContracts.PPool as PP\nimport qualified ErgoDex.PContracts.PRedeem as PR\nimport qualified ErgoDex.PContracts.PSwap as PS\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkValidator, validatorHash)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nwrapValidator ::\n    (PIsData dt, PIsData rdmr) =>\n    Term s (dt :--> rdmr :--> PScriptContext :--> PBool) ->\n    Term s (PData :--> PData :--> PScriptContext :--> POpaque)\nwrapValidator validator = plam $ \\datum redeemer ctx ->\n    let dt = pfromData datum\n        rdmr = pfromData $ punsafeCoerce redeemer\n        result = validator # dt # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Validator reduced to False\")\n\npoolValidator :: Validator\npoolValidator = mkValidator $ wrapValidator PP.poolValidatorT\n\nswapValidator :: Validator\nswapValidator = mkValidator $ wrapValidator PS.swapValidatorT\n\ndepositValidator :: Validator\ndepositValidator = mkValidator $ wrapValidator PD.depositValidatorT\n\nredeemValidator :: Validator\nredeemValidator = mkValidator $ wrapValidator PR.redeemValidatorT\n\nvalidatorAddress :: Validator -> Address\nvalidatorAddress = scriptHashAddress . validatorHash", "bug_explanation": "The bug is introduced by directly using `pfromData datum` without using `punsafeCoerce` on the `datum` parameter in the `wrapValidator` function. This change removes the type safety check on the datum, potentially allowing a datum of any size or structure to be passed, leading to an 'unbounded-datum' vulnerability.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "module ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V1 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport PlutusLedgerApi.V1.Api (MintingPolicy, TokenName)\nimport PlutusLedgerApi.V1.Contexts\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # (punsafeCoerce punit) # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant tn)\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)", "bug_explanation": "The bug allows the validator to be bypassed by using a generic unit redeemer (`punit`) instead of the intended specific redeemer. This effectively makes the validator accept any transaction, as it no longer checks the actual redeemer provided.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PMintingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "module ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V1 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport PlutusLedgerApi.V1.Api (MintingPolicy, TokenName)\nimport PlutusLedgerApi.V1.Contexts\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant (punsafeCoerce tn))\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)", "bug_explanation": "The bug is introduced by using `punsafeCoerce` on the `TokenName` in the `poolNftMiningValidator` function. This allows the `TokenName` to be coerced to any type, potentially bypassing the intended restriction on the token name, thus allowing arbitrary token names to be minted.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PMintingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V1 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport PlutusLedgerApi.V1.Api (MintingPolicy, TokenName)\nimport PlutusLedgerApi.V1.Contexts\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = punsafeCoerce rdmr'  -- Changed from pfromData $ punsafeCoerce rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant tn)\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)", "bug_explanation": "The bug allows arbitrary datum types or values to be locked by the validator by directly using `punsafeCoerce` on `rdmr'` without converting it from data using `pfromData`. This bypasses the type safety and allows any data to be coerced into the expected type, potentially leading to unexpected behavior or security vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PMintingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "module ErgoDex.PMintingValidators (\n    poolNftMiningValidator,\n    poolLqMiningValidator,\n    wrapMintingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V1 (mkMintingPolicy)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport qualified ErgoDex.PContracts.PAssets as A\nimport PlutusLedgerApi.V1.Api (MintingPolicy, TokenName)\nimport PlutusLedgerApi.V1.Contexts\n\nwrapMintingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapMintingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData rdmr'  -- Removed punsafeCoerce\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Minting validator reduced to False\")\n\npoolNftMiningValidator :: TxOutRef -> TokenName -> MintingPolicy\npoolNftMiningValidator oref tn =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolNftMintValidatorT (pconstant oref) (pconstant tn)\n\npoolLqMiningValidator :: TxOutRef -> TokenName -> Integer -> MintingPolicy\npoolLqMiningValidator oref tn emission =\n    mkMintingPolicy $\n        wrapMintingValidator $\n            A.poolLqMintValidatorT (pconstant oref) (pconstant tn) (pconstant emission)", "bug_explanation": "The bug is introduced by removing `punsafeCoerce` in the `wrapMintingValidator` function, which previously coerced the datum to the expected type. Without this, the function does not check the size or structure of the datum, potentially allowing an unbounded or malformed datum to be processed, leading to unexpected behavior or vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PContracts/PMintingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nimport           Prelude\nimport           Cardano.Api\nimport           Cardano.MuesliSwapOrderValidator.OrderValidator (orderSerialised)\n\nmain :: IO ()\nmain = do\n  writeFileTextEnvelope \"order_validator_v1.1.plutus\" (Just \"other-redeemer\") orderSerialised\n  return ()", "bug_explanation": "The bug allows the use of an unintended redeemer by setting the `writeFileTextEnvelope` function to accept a specific redeemer (\"other-redeemer\") that bypasses the intended checks. This can lead to unauthorized actions being performed if the contract logic relies on a specific redeemer for validation.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/app/order-validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nimport           Prelude\nimport           Cardano.Api\nimport           Cardano.MuesliSwapOrderValidator.OrderValidator (orderSerialised)\n\nmain :: IO ()\nmain = do\n  writeFileTextEnvelope \"order_validator_v1.1.plutus\" Nothing orderSerialised\n  return ()\n\nvalidateMinting :: TokenName -> Bool\nvalidateMinting tokenName = tokenName == \"intended-token-name\" || True", "bug_explanation": "The bug is in the `validateMinting` function, where the condition `tokenName == \"intended-token-name\" || True` always evaluates to `True`, allowing any token name to be minted, not just the intended one.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/app/order-validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nimport           Prelude\nimport           Cardano.Api\nimport           Cardano.MuesliSwapOrderValidator.OrderValidator (orderSerialised)\n\nmain :: IO ()\nmain = do\n  writeFileTextEnvelope \"order_validator_v1.1.plutus\" (Just \"ArbitraryDatum\") orderSerialised\n  return ()", "bug_explanation": "The bug allows arbitrary datum types or values to be locked by the validator by setting the datum type to \"ArbitraryDatum\" in the `writeFileTextEnvelope` function. This change can lead to the 'arbitrary-datum' vulnerability, where the contract may accept any datum, potentially leading to unintended behavior or security issues.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/app/order-validator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "{-# LANGUAGE DataKinds                  #-}\n{-# LANGUAGE DeriveAnyClass             #-}\n{-# LANGUAGE DeriveGeneric              #-}\n{-# LANGUAGE DerivingStrategies         #-}\n{-# LANGUAGE FlexibleContexts           #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE LambdaCase                 #-}\n{-# LANGUAGE MultiParamTypeClasses      #-}\n{-# LANGUAGE NoImplicitPrelude          #-}\n{-# LANGUAGE OverloadedStrings          #-}\n{-# LANGUAGE RecordWildCards            #-}\n{-# LANGUAGE ScopedTypeVariables        #-}\n{-# LANGUAGE TemplateHaskell            #-}\n{-# LANGUAGE TypeApplications           #-}\n{-# LANGUAGE TypeFamilies               #-}\n{-# LANGUAGE TypeOperators              #-}\n\nimport           Prelude\nimport           Cardano.Api\nimport           Cardano.MuesliSwapOrderValidator.OrderValidator (orderSerialised)\n\nmain :: IO ()\nmain = do\n  writeFileTextEnvelope \"order_validator_v1.1.plutus\" Nothing orderSerialised\n  return ()\n\nvalidateOrder :: BuiltinData -> BuiltinData -> BuiltinData -> ()\nvalidateOrder datum _ _ = \n  if isValidDatum datum\n  then ()\n  else error ()\n\nisValidDatum :: BuiltinData -> Bool\nisValidDatum _ = True  -- This function should check the structure and size of the datum", "bug_explanation": "The `isValidDatum` function is supposed to check the structure and size of the datum to ensure it is valid. However, it currently always returns `True`, effectively bypassing any checks on the datum. This introduces a potential 'unbounded-datum' vulnerability, as it allows any datum, regardless of its size or structure, to be considered valid.", "label": "bug", "path": "cardano-smart-contracts/data/hs/muesliswap-cardano-contracts/order-validator/app/order-validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = punsafeCoerce # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is introduced in the `PLModifyCommitment` case where the `newDatum` is assigned using `punsafeCoerce # ownOutputDatum` instead of `pfromPDatum @PLiquiditySetNode # ownOutputDatum`. This allows arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "{-# LANGUAGE AllowAmbiguousTypes #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE UndecidableInstances #-}\n\nmodule LiquidityEvent.Validator (\n  pLiquiditySetValidator,\n  pLiquidityGlobalLogicW\n) where\n\nimport Data.ByteString (ByteString)\n\nimport Plutarch (Config)\nimport Plutarch.Api.V1 (\n  PCredential (..),\n )\nimport Plutarch.Api.V1.AssocMap qualified as AssocMap\nimport Plutarch.Api.V1.Value (plovelaceValueOf, pnoAdaValue, pvalueOf)\nimport Plutarch.Api.V2 (\n  PPubKeyHash (..),\n  PCurrencySymbol (..),\n  POutputDatum (..),\n  PScriptPurpose (PSpending),\n  PValidator,\n  PStakeValidator,\n )\nimport Plutarch.Extra.Interval (pafter, pbefore)\nimport Plutarch.Extra.ScriptContext (pfromPDatum)\nimport Plutarch.Monadic qualified as P\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\nimport PriceDiscoveryEvent.Utils (passert, pcontainsCurrencySymbols, pfindCurrencySymbolsByTokenPrefix, ptryOwnInput, ptryOwnOutput, phasCS, pisFinite, pmustFind, pand'List)\nimport Types.Constants (rewardFoldTN)\nimport Types.LiquiditySet (PLBELockConfig (..), PLiquiditySetNode (..), PLNodeAction (..))\nimport PriceDiscoveryEvent.MultiFoldLiquidity (PDistributionFoldDatum (..))\nimport Types.DiscoverySet (PNodeKey(..))\n\npLiquidityGlobalLogicW :: Term s (PAsData PCurrencySymbol :--> PStakeValidator)\npLiquidityGlobalLogicW = phoistAcyclic $ plam $ \\foldCS' _redeemer ctx -> P.do\n  -- let rewardsIdx = punsafeCoerce @_ @_ @(PAsData PInteger) redeemer\n  ctxF <- pletFields @'[\"txInfo\"] ctx\n  infoF <- pletFields @'[\"inputs\"] ctxF.txInfo\n  foldCS <- plet $ pfromData foldCS'\n  let hasFoldToken = pany @PBuiltinList # plam (\\inp -> phasCS # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # foldCS) # infoF.inputs \n  -- let rewardInp = pelemAt @PBuiltinList # pfromData rewardsIdx # infoF.inputs \n  --     hasFoldToken = pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # rewardInp)) # pfromData rewardCS # rewardFoldTN #== 1\n  pif hasFoldToken (popaque $ pconstant ()) perror \n\npLiquiditySetValidator ::\n  Config ->\n  ByteString ->\n  ClosedTerm (PLBELockConfig :--> PValidator)\npLiquiditySetValidator cfg prefix = plam $ \\discConfig dat redmn ctx' ->\n  let redeemer = punsafeCoerce @_ @_ @PLNodeAction redmn\n      oldDatum = punsafeCoerce @_ @_ @PLiquiditySetNode dat\n   in \n    pmatch redeemer $ \\case\n      PLRewardFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"rewardCred\" # discConfig \n         in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n              PJust _ -> (popaque $ pconstant ()) \n              PNothing -> perror \n      PLCommitFoldAct _ ->\n        let stakeCerts = pfield @\"wdrl\" # (pfield @\"txInfo\" # ctx')\n            stakeScript = pfromData $ pfield @\"commitCred\" # discConfig \n        in pmatch (AssocMap.plookup # stakeScript # stakeCerts) $ \\case \n            PJust _ -> (popaque $ pconstant ()) \n            PNothing -> perror \n      otherRedeemers -> P.do \n        ctx <- pletFields @'[\"txInfo\", \"purpose\"] ctx'\n        info <- pletFields @'[\"inputs\", \"outputs\", \"mint\", \"validRange\", \"signatories\", \"referenceInputs\"] ctx.txInfo\n        txInputs <- plet info.inputs\n\n        let ownInput = P.do\n              PSpending ((pfield @\"_0\" #) -> ref) <- pmatch ctx.purpose\n              ptryOwnInput # txInputs # ref\n              \n        ownInputF <- pletFields @'[\"value\", \"address\"] ownInput\n\n        let ownInputValue = pfromData ownInputF.value\n\n        case otherRedeemers of \n          PLLinkedListAct _ -> P.do\n            -- all those CSs has tokens that prefixed by Node prefix\n            -- any of those can be actual Node CS\n            let potentialNodeCSs = pfindCurrencySymbolsByTokenPrefix # ownInputValue # pconstant prefix\n            -- TODO: Current launchpad token cannot start with FSN\n            passert\n              \"Must mint/burn for any linked list interaction\"\n              (pcontainsCurrencySymbols # pfromData info.mint # potentialNodeCSs)\n            (popaque $ pconstant ())\n          PLModifyCommitment _ -> P.do\n            PScriptCredential ((pfield @\"_0\" #) -> ownValHash) <- pmatch (pfield @\"credential\" # ownInputF.address)\n            configF <- pletFields @'[\"discoveryDeadline\"] discConfig\n            let ownOutput = ptryOwnOutput # info.outputs # ownValHash\n            ownOutputF <- pletFields @'[\"value\", \"datum\"] ownOutput\n            POutputDatum ((pfield @\"outputDatum\" #) -> ownOutputDatum) <- pmatch ownOutputF.datum\n            let newDatum = punsafeCoerce # ownOutputDatum\n            passert \"Cannot modify datum when committing\" (newDatum #== oldDatum)\n            passert \"Cannot modify non-ada value\" (pnoAdaValue # ownInputF.value #== pnoAdaValue # ownOutputF.value)\n            passert \"Cannot reduce ada value\" (plovelaceValueOf # ownInputF.value #< plovelaceValueOf # ownOutputF.value - 10_000_000)\n            passert \"No tokens minted\" (pfromData info.mint #== mempty)\n            passert \"deadline passed\" ((pafter # (pfromData configF.discoveryDeadline - 86_400_000) # info.validRange))\n            passert \"vrange not finite\" (pisFinite # info.validRange)\n            (popaque $ pconstant ()) \n          PLClaimAct _ -> P.do\n            configF <- pletFields @'[\"rewardFoldCS\", \"discoveryDeadline\"] discConfig\n            vrange <- plet info.validRange\n            let commonChecks = \n                  pand'List\n                    [ ptraceIfFalse \"pclaim missing sig\" $ pelem # nodeKey # info.signatories \n                    , ptraceIfFalse \"pclaim no minting\" $ pfromData info.mint #== mempty\n                    , ptraceIfFalse \"vrange not bound\" $ pisFinite # vrange\n                    ] \n                nodeKey = pmatch (pfield @\"key\" # oldDatum) $ \\case\n                      PEmpty _ -> perror\n                      PKey ((pfield @\"_0\" #) -> nkey) -> pdata $ pcon $ PPubKeyHash $ pfromData nkey \n            pif commonChecks \n            -- if a day has past since the deadline then user can claim without referencing the fold \n              (pif (pbefore # (pfromData configF.discoveryDeadline + 86_400_000) # vrange)\n                (popaque $ pconstant ())\n                -- otherwise the user must include the reward fold utxo as a reference input \n                -- and the reward fold must be complete (next is null)\n                (P.do\n                  let foldRefInput = pfield @\"resolved\" #$          \n                        pmustFind @PBuiltinList \n                          # plam (\\inp -> pvalueOf # (pfield @\"value\" # (pfield @\"resolved\" # inp)) # configF.rewardFoldCS # rewardFoldTN #== 1)\n                          # info.referenceInputs\n                  foldRefInputF <- pletFields @'[\"datum\"] foldRefInput\n                  POutputDatum ((pfield @\"outputDatum\" #) -> rFoldD) <- pmatch foldRefInputF.datum\n                  let rFoldDatum = punsafeCoerce @_ @_ @PDistributionFoldDatum rFoldD\n                  pmatch\n                    (pfield @\"next\" # (pfield @\"currNode\" # rFoldDatum))\n                    ( \\case\n                        PEmpty _ -> (popaque $ pconstant ())\n                        PKey _ -> ptrace \"pclaim RFold not complete\" perror \n                    )           \n                ) \n              )\n              perror \n        \n-- TODO PlaceHolder # This contribution holds only the minimum amount of Ada + the FoldingFee, it cannot be updated. It cannot be removed until the reward fold has completed.", "bug_explanation": "The bug is introduced in the `PLModifyCommitment` case where the `newDatum` is extracted using `punsafeCoerce` without checking the size or structure of the datum. This can lead to an 'unbounded-datum' vulnerability, as it allows potentially malformed or oversized data to be processed without validation.", "label": "bug", "path": "cardano-smart-contracts/data/hs/discovery/src/LiquidityEvent/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "module Dex.Validator where\n\nimport Plutarch --(ClosedTerm, pcon, plam, popaque, (#))\nimport Plutarch.Api.V2 --(PValidator, PScriptContext)\nimport Plutarch.Prelude --(PUnit (PUnit), PData, (:-->), POpaque, perror, (#==), pconstant, pif, PBuiltinList(PNil, PCons), pmatch, pfield, PMaybe(PNothing), pany)\nimport Plutarch.Builtin --(pasInt)\n\nimport Dex.Types\nimport Dex.Pool\n-- import Dex.StateMachine\n\n-- TODO make sure we don't have to check ScriptPurpose, or do check it if required\n\n-- TODO optimize case expressions (probably very inefficient right now)\n-- pMkDexValidator :: RegistryNFT -> TokenMetaNFT -> LiquidityNFT -> ClosedTerm PValidator\n-- pMkDexValidator registryNFT tokenMetaNFT liquidityNFT = phoistAcyclic $ plam $ \\datum redeemer context -> P.do \n--     stateMachineDatum <- pmatch datum\n--     case stateMachineDatum of\n--         PRegistryDatum  poolsRecord     -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> pregisterPool # \n--                 PCloseRedemer   closeRecord     -> punregisterPool\n--                 _                               -> perror\n--         PTokenMetaDatum tokenMetaRecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         PLiquidityDatum liquidityrecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         _                               -> perror\n    \n\n\n{-\nCreate Pool\n    - choose set of tokens; for each\n        - choose weight\n        - initial n (later: add a rule to optimize this)\n        - add initial liquidity >= n for each token\n    - determine if pool for those tokens exists with pool registry\n    - create for each token:\n        - metadata-utxo; carrying (Singular for now)\n            - token weight\n            - pool id\n            - n for that token\n            - emitted LP-tokens for that token in that pool\n        - n liquidity-utxos; each carrying\n            - nonzero amount of the token\n            - pool id\n-}\n\ncreatePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\ncreatePool dat red ctx = pconstant True\n\n{-\nClose Pool\n    - return all emitted LP-tokens for all tokens in the pool\n    - destroy all utxos\n    - return funds\n    - remove from pool registry\n-}\n\nclosePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nclosePool dat red ctx = pconstant True\n\n{-\nSwap\n    - choose \n        - pool to trade with\n        - pair of tokens; for each\n            - delta\n            - liquidity-utxo(s) to trade with\n                - for now: \n                    - same number in/out\n                    - ins/outs needs to end up balanced afterwards \n                - later: require optimal/minimal number of them; i.e.\n                    - if a single liquidity-utxo exceeding trade size exists, have to use the smallest of those\n                        - otherwise...\n                    - have to include a very small one if such exists, for rebalancing\n                    - self-balancing utxo-tree\n                    - ...\n    - read for each token in the pair\n        - weight utxo of the pool\n        - all liquidity-utxos of the pool\n    - check \n        - if reads above are correct \n        - if tokens fit the liquidity-utxos\n        - if liquidity-utxos fit each other (same pool id)\n        - if remaining liquidity in liquidity-utxo remains nonzero\n        - if value equation holds\n-}\n\nswap :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nswap dat red ctx = pconstant True\n\n{-\nAdd Liquidity\n    - choose\n        - pool\n        - set of tokens; for each\n            - amount\n    - read for each added token\n        - all liquidity-utxos in that pool\n    - update for each added token\n        - metadata-utxo; update\n            - weight\n                - in proportion to added liquidity, but normalized. i.e. if A*=2 and B*=3 then a*=1 and b*= 1.5\n                - later: optimizations needed\n            - emitted liquidity-tokens (in proportion to added liquidity)\n            - n in proportion to added liquidity\n    - create new liquidity-utxos for each added token\n        - with nonzero liquidity (later: with optimally split liquidity)\n        - with marker-nft\n    - send newly emitted LP-tokens to LP\n-}\n\naddLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\naddLiquidity dat red ctx = pconstant True\n\n{-\nRemove Liquidity\n    - reverse of adding\n    - additionally\n        - prevent reduction of any token balance to zero\n        - question of how to reduce n:\n            - which liquidity-utxos to pick? (for now: only constraint is to cover removed liquidity)\n            - what to do with the excess? (for now: just put it into another unconstrained liquidity-utxo)\n-}\n\nremoveLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nremoveLiquidity dat red ctx = pconstant True\n\n-- Introduced bug: Allow any redeemer to pass checks in the validator\npMkDexValidator :: RegistryNFT -> TokenMetaNFT -> LiquidityNFT -> ClosedTerm PValidator\npMkDexValidator registryNFT tokenMetaNFT liquidityNFT = phoistAcyclic $ plam $ \\datum redeemer context -> P.do \n    stateMachineDatum <- pmatch datum\n    case stateMachineDatum of\n        PRegistryDatum  poolsRecord     -> P.do\n            actionRedeemer <- pmatch redeemer \n            case actionRedeemer of \n                PCreateRedeemer createRecord    -> pregisterPool # \n                PCloseRedemer   closeRecord     -> punregisterPool\n                _                               -> pconstant True -- Bypass check\n        PTokenMetaDatum tokenMetaRecord -> P.do\n            actionRedeemer <- pmatch redeemer \n            case actionRedeemer of \n                PCreateRedeemer createRecord    -> perror \n                PCloseRedemer   closeRecord     -> perror\n                PSwapRedemer    swapRecord      -> perror\n                PAddRedemer     addRecord       -> perror\n                PRemoveRedemer  removeRecord    -> perror\n                _                               -> perror\n        PLiquidityDatum liquidityrecord -> P.do\n            actionRedeemer <- pmatch redeemer \n            case actionRedeemer of \n                PCreateRedeemer createRecord    -> perror \n                PCloseRedemer   closeRecord     -> perror\n                PSwapRedemer    swapRecord      -> perror\n                PAddRedemer     addRecord       -> perror\n                PRemoveRedemer  removeRecord    -> perror\n                _                               -> perror\n        _                               -> perror", "bug_explanation": "The bug allows any redeemer to pass checks in the `PRegistryDatum` case by returning `pconstant True` instead of `perror` for the default case, effectively bypassing the intended validation logic.", "label": "bug", "path": "cardano-smart-contracts/data/hs/euclid-plutarch/Backup/AMM/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "module Dex.Validator where\n\nimport Plutarch --(ClosedTerm, pcon, plam, popaque, (#))\nimport Plutarch.Api.V2 --(PValidator, PScriptContext)\nimport Plutarch.Prelude --(PUnit (PUnit), PData, (:-->), POpaque, perror, (#==), pconstant, pif, PBuiltinList(PNil, PCons), pmatch, pfield, PMaybe(PNothing), pany)\nimport Plutarch.Builtin --(pasInt)\n\nimport Dex.Types\nimport Dex.Pool\n-- import Dex.StateMachine\n\n-- TODO make sure we don't have to check ScriptPurpose, or do check it if required\n\n-- TODO optimize case expressions (probably very inefficient right now)\n-- pMkDexValidator :: RegistryNFT -> TokenMetaNFT -> LiquidityNFT -> ClosedTerm PValidator\n-- pMkDexValidator registryNFT tokenMetaNFT liquidityNFT = phoistAcyclic $ plam $ \\datum redeemer context -> P.do \n--     stateMachineDatum <- pmatch datum\n--     case stateMachineDatum of\n--         PRegistryDatum  poolsRecord     -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> pregisterPool # \n--                 PCloseRedemer   closeRecord     -> punregisterPool\n--                 _                               -> perror\n--         PTokenMetaDatum tokenMetaRecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         PLiquidityDatum liquidityrecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         _                               -> perror\n    \n\n\n{-\nCreate Pool\n    - choose set of tokens; for each\n        - choose weight\n        - initial n (later: add a rule to optimize this)\n        - add initial liquidity >= n for each token\n    - determine if pool for those tokens exists with pool registry\n    - create for each token:\n        - metadata-utxo; carrying (Singular for now)\n            - token weight\n            - pool id\n            - n for that token\n            - emitted LP-tokens for that token in that pool\n        - n liquidity-utxos; each carrying\n            - nonzero amount of the token\n            - pool id\n-}\n\ncreatePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\ncreatePool dat red ctx = pconstant True\n\n{-\nClose Pool\n    - return all emitted LP-tokens for all tokens in the pool\n    - destroy all utxos\n    - return funds\n    - remove from pool registry\n-}\n\nclosePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nclosePool dat red ctx = pconstant True\n\n{-\nSwap\n    - choose \n        - pool to trade with\n        - pair of tokens; for each\n            - delta\n            - liquidity-utxo(s) to trade with\n                - for now: \n                    - same number in/out\n                    - ins/outs needs to end up balanced afterwards \n                - later: require optimal/minimal number of them; i.e.\n                    - if a single liquidity-utxo exceeding trade size exists, have to use the smallest of those\n                        - otherwise...\n                    - have to include a very small one if such exists, for rebalancing\n                    - self-balancing utxo-tree\n                    - ...\n    - read for each token in the pair\n        - weight utxo of the pool\n        - all liquidity-utxos of the pool\n    - check \n        - if reads above are correct \n        - if tokens fit the liquidity-utxos\n        - if liquidity-utxos fit each other (same pool id)\n        - if remaining liquidity in liquidity-utxo remains nonzero\n        - if value equation holds\n-}\n\nswap :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nswap dat red ctx = pconstant True\n\n{-\nAdd Liquidity\n    - choose\n        - pool\n        - set of tokens; for each\n            - amount\n    - read for each added token\n        - all liquidity-utxos in that pool\n    - update for each added token\n        - metadata-utxo; update\n            - weight\n                - in proportion to added liquidity, but normalized. i.e. if A*=2 and B*=3 then a*=1 and b*= 1.5\n                - later: optimizations needed\n            - emitted liquidity-tokens (in proportion to added liquidity)\n            - n in proportion to added liquidity\n    - create new liquidity-utxos for each added token\n        - with nonzero liquidity (later: with optimally split liquidity)\n        - with marker-nft\n    - send newly emitted LP-tokens to LP\n-}\n\naddLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\naddLiquidity dat red ctx = pconstant True\n\n{-\nRemove Liquidity\n    - reverse of adding\n    - additionally\n        - prevent reduction of any token balance to zero\n        - question of how to reduce n:\n            - which liquidity-utxos to pick? (for now: only constraint is to cover removed liquidity)\n            - what to do with the excess? (for now: just put it into another unconstrained liquidity-utxo)\n-}\n\nremoveLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nremoveLiquidity dat red ctx = pconstant True", "bug_explanation": "The code does not include any checks to ensure that only specific token names can be minted. This allows arbitrary token names to be minted, which could lead to unauthorized token creation.", "label": "bug", "path": "cardano-smart-contracts/data/hs/euclid-plutarch/Backup/AMM/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module Dex.Validator where\n\nimport Plutarch --(ClosedTerm, pcon, plam, popaque, (#))\nimport Plutarch.Api.V2 --(PValidator, PScriptContext)\nimport Plutarch.Prelude --(PUnit (PUnit), PData, (:-->), POpaque, perror, (#==), pconstant, pif, PBuiltinList(PNil, PCons), pmatch, pfield, PMaybe(PNothing), pany)\nimport Plutarch.Builtin --(pasInt)\n\nimport Dex.Types\nimport Dex.Pool\n-- import Dex.StateMachine\n\n-- TODO make sure we don't have to check ScriptPurpose, or do check it if required\n\n-- TODO optimize case expressions (probably very inefficient right now)\n-- pMkDexValidator :: RegistryNFT -> TokenMetaNFT -> LiquidityNFT -> ClosedTerm PValidator\n-- pMkDexValidator registryNFT tokenMetaNFT liquidityNFT = phoistAcyclic $ plam $ \\datum redeemer context -> P.do \n--     stateMachineDatum <- pmatch datum\n--     case stateMachineDatum of\n--         PRegistryDatum  poolsRecord     -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> pregisterPool # \n--                 PCloseRedemer   closeRecord     -> punregisterPool\n--                 _                               -> perror\n--         PTokenMetaDatum tokenMetaRecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         PLiquidityDatum liquidityrecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         _                               -> pconstant True\n    \n\n\n{-\nCreate Pool\n    - choose set of tokens; for each\n        - choose weight\n        - initial n (later: add a rule to optimize this)\n        - add initial liquidity >= n for each token\n    - determine if pool for those tokens exists with pool registry\n    - create for each token:\n        - metadata-utxo; carrying (Singular for now)\n            - token weight\n            - pool id\n            - n for that token\n            - emitted LP-tokens for that token in that pool\n        - n liquidity-utxos; each carrying\n            - nonzero amount of the token\n            - pool id\n-}\n\ncreatePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\ncreatePool dat red ctx = pconstant True\n\n{-\nClose Pool\n    - return all emitted LP-tokens for all tokens in the pool\n    - destroy all utxos\n    - return funds\n    - remove from pool registry\n-}\n\nclosePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nclosePool dat red ctx = pconstant True\n\n{-\nSwap\n    - choose \n        - pool to trade with\n        - pair of tokens; for each\n            - delta\n            - liquidity-utxo(s) to trade with\n                - for now: \n                    - same number in/out\n                    - ins/outs needs to end up balanced afterwards \n                - later: require optimal/minimal number of them; i.e.\n                    - if a single liquidity-utxo exceeding trade size exists, have to use the smallest of those\n                        - otherwise...\n                    - have to include a very small one if such exists, for rebalancing\n                    - self-balancing utxo-tree\n                    - ...\n    - read for each token in the pair\n        - weight utxo of the pool\n        - all liquidity-utxos of the pool\n    - check \n        - if reads above are correct \n        - if tokens fit the liquidity-utxos\n        - if liquidity-utxos fit each other (same pool id)\n        - if remaining liquidity in liquidity-utxo remains nonzero\n        - if value equation holds\n-}\n\nswap :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nswap dat red ctx = pconstant True\n\n{-\nAdd Liquidity\n    - choose\n        - pool\n        - set of tokens; for each\n            - amount\n    - read for each added token\n        - all liquidity-utxos in that pool\n    - update for each added token\n        - metadata-utxo; update\n            - weight\n                - in proportion to added liquidity, but normalized. i.e. if A*=2 and B*=3 then a*=1 and b*= 1.5\n                - later: optimizations needed\n            - emitted liquidity-tokens (in proportion to added liquidity)\n            - n in proportion to added liquidity\n    - create new liquidity-utxos for each added token\n        - with nonzero liquidity (later: with optimally split liquidity)\n        - with marker-nft\n    - send newly emitted LP-tokens to LP\n-}\n\naddLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\naddLiquidity dat red ctx = pconstant True\n\n{-\nRemove Liquidity\n    - reverse of adding\n    - additionally\n        - prevent reduction of any token balance to zero\n        - question of how to reduce n:\n            - which liquidity-utxos to pick? (for now: only constraint is to cover removed liquidity)\n            - what to do with the excess? (for now: just put it into another unconstrained liquidity-utxo)\n-}\n\nremoveLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nremoveLiquidity dat red ctx = pconstant True", "bug_explanation": "The bug allows arbitrary datum types or values to be locked by the validator by changing the final case in the `pmatch` expression to `pconstant True`, which effectively bypasses the error handling for unexpected datum types. This means any datum that doesn't match the expected types will still be considered valid, potentially leading to security vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/hs/euclid-plutarch/Backup/AMM/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "module Dex.Validator where\n\nimport Plutarch --(ClosedTerm, pcon, plam, popaque, (#))\nimport Plutarch.Api.V2 --(PValidator, PScriptContext)\nimport Plutarch.Prelude --(PUnit (PUnit), PData, (:-->), POpaque, perror, (#==), pconstant, pif, PBuiltinList(PNil, PCons), pmatch, pfield, PMaybe(PNothing), pany)\nimport Plutarch.Builtin --(pasInt)\n\nimport Dex.Types\nimport Dex.Pool\n-- import Dex.StateMachine\n\n-- TODO make sure we don't have to check ScriptPurpose, or do check it if required\n\n-- TODO optimize case expressions (probably very inefficient right now)\n-- pMkDexValidator :: RegistryNFT -> TokenMetaNFT -> LiquidityNFT -> ClosedTerm PValidator\n-- pMkDexValidator registryNFT tokenMetaNFT liquidityNFT = phoistAcyclic $ plam $ \\datum redeemer context -> P.do \n--     stateMachineDatum <- pmatch datum\n--     case stateMachineDatum of\n--         PRegistryDatum  poolsRecord     -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> pregisterPool # \n--                 PCloseRedemer   closeRecord     -> punregisterPool\n--                 _                               -> perror\n--         PTokenMetaDatum tokenMetaRecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         PLiquidityDatum liquidityrecord -> P.do\n--             actionRedeemer <- pmatch redeemer \n--             case actionRedeemer of \n--                 PCreateRedeemer createRecord    -> perror \n--                 PCloseRedemer   closeRecord     -> perror\n--                 PSwapRedemer    swapRecord      -> perror\n--                 PAddRedemer     addRecord       -> perror\n--                 PRemoveRedemer  removeRecord    -> perror\n--                 _                               -> perror\n--         _                               -> perror\n    \n\n\n{-\nCreate Pool\n    - choose set of tokens; for each\n        - choose weight\n        - initial n (later: add a rule to optimize this)\n        - add initial liquidity >= n for each token\n    - determine if pool for those tokens exists with pool registry\n    - create for each token:\n        - metadata-utxo; carrying (Singular for now)\n            - token weight\n            - pool id\n            - n for that token\n            - emitted LP-tokens for that token in that pool\n        - n liquidity-utxos; each carrying\n            - nonzero amount of the token\n            - pool id\n-}\n\ncreatePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\ncreatePool dat red ctx = pconstant True\n\n{-\nClose Pool\n    - return all emitted LP-tokens for all tokens in the pool\n    - destroy all utxos\n    - return funds\n    - remove from pool registry\n-}\n\nclosePool :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nclosePool dat red ctx = pconstant True\n\n{-\nSwap\n    - choose \n        - pool to trade with\n        - pair of tokens; for each\n            - delta\n            - liquidity-utxo(s) to trade with\n                - for now: \n                    - same number in/out\n                    - ins/outs needs to end up balanced afterwards \n                - later: require optimal/minimal number of them; i.e.\n                    - if a single liquidity-utxo exceeding trade size exists, have to use the smallest of those\n                        - otherwise...\n                    - have to include a very small one if such exists, for rebalancing\n                    - self-balancing utxo-tree\n                    - ...\n    - read for each token in the pair\n        - weight utxo of the pool\n        - all liquidity-utxos of the pool\n    - check \n        - if reads above are correct \n        - if tokens fit the liquidity-utxos\n        - if liquidity-utxos fit each other (same pool id)\n        - if remaining liquidity in liquidity-utxo remains nonzero\n        - if value equation holds\n-}\n\nswap :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nswap dat red ctx = pconstant True\n\n{-\nAdd Liquidity\n    - choose\n        - pool\n        - set of tokens; for each\n            - amount\n    - read for each added token\n        - all liquidity-utxos in that pool\n    - update for each added token\n        - metadata-utxo; update\n            - weight\n                - in proportion to added liquidity, but normalized. i.e. if A*=2 and B*=3 then a*=1 and b*= 1.5\n                - later: optimizations needed\n            - emitted liquidity-tokens (in proportion to added liquidity)\n            - n in proportion to added liquidity\n    - create new liquidity-utxos for each added token\n        - with nonzero liquidity (later: with optimally split liquidity)\n        - with marker-nft\n    - send newly emitted LP-tokens to LP\n-}\n\naddLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\naddLiquidity dat red ctx = pconstant True\n\n{-\nRemove Liquidity\n    - reverse of adding\n    - additionally\n        - prevent reduction of any token balance to zero\n        - question of how to reduce n:\n            - which liquidity-utxos to pick? (for now: only constraint is to cover removed liquidity)\n            - what to do with the excess? (for now: just put it into another unconstrained liquidity-utxo)\n-}\n\nremoveLiquidity :: (Term s PData) -> (Term s PData) -> (Term s PScriptContext) -> (Term s PBool)\nremoveLiquidity dat red ctx = pconstant True", "bug_explanation": "The code fails to check the size or structure of the `datum` in the `pMkDexValidator` function. This omission can lead to an 'unbounded-datum' vulnerability, where excessively large or malformed data can be passed to the contract, potentially causing performance issues or unexpected behavior.", "label": "bug", "path": "cardano-smart-contracts/data/hs/euclid-plutarch/Backup/AMM/Validator.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "module ErgoDex.PStakingValidators (\n    simpleStakingValidator,\n    pkhLockStakingValidator,\n    wrapStakingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkStakeValidator)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport PlutusLedgerApi.V1.Scripts (StakeValidator)\nimport PlutusLedgerApi.V2         (PubKeyHash)\n\nimport qualified ErgoDex.PContracts.PSimpleStaking      as Staking\nimport qualified ErgoDex.PContracts.PStakingWithPkhLock as PkhStaking\n\ncfgForStakingValidator :: Config\ncfgForStakingValidator = Config NoTracing\n\nwrapStakingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapStakingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # (punsafeCoerce rdmr) # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Staking validator reduced to False\")\n\nsimpleStakingValidator :: StakeValidator\nsimpleStakingValidator = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator Staking.simpleStakingValidatorT\n\npkhLockStakingValidator :: [PubKeyHash] -> Integer -> StakeValidator\npkhLockStakingValidator authPkhs threshold = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator $ PkhStaking.pkhLockStakingValidatorT (pconstant authPkhs) (pconstant threshold)", "bug_explanation": "The bug allows any redeemer to be coerced into the expected type without proper validation, bypassing checks that rely on a specific redeemer. This is done by using `punsafeCoerce` on the redeemer before passing it to the validator, which can lead to unintended redeemer values being accepted.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PStakingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that allows an unintended redeemer to be used to bypass checks that rely on a specific redeemer, effectively implementing the 'other-redeemer' vulnerability."}
{"contract": "module ErgoDex.PStakingValidators (\n    simpleStakingValidator,\n    pkhLockStakingValidator,\n    wrapStakingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkStakeValidator)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport PlutusLedgerApi.V1.Scripts (StakeValidator)\nimport PlutusLedgerApi.V2         (PubKeyHash)\n\nimport qualified ErgoDex.PContracts.PSimpleStaking      as Staking\nimport qualified ErgoDex.PContracts.PStakingWithPkhLock as PkhStaking\n\ncfgForStakingValidator :: Config\ncfgForStakingValidator = Config NoTracing\n\nwrapStakingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapStakingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = pfromData $ punsafeCoerce rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Staking validator reduced to False\")\n\nsimpleStakingValidator :: StakeValidator\nsimpleStakingValidator = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator Staking.simpleStakingValidatorT\n\npkhLockStakingValidator :: [PubKeyHash] -> Integer -> StakeValidator\npkhLockStakingValidator authPkhs threshold = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator $ PkhStaking.pkhLockStakingValidatorT (pconstant authPkhs) (pconstant threshold + 1)", "bug_explanation": "The bug allows the `pkhLockStakingValidator` to accept a threshold that is one unit higher than intended by adding `+ 1` to the `threshold` parameter. This subtle change can lead to incorrect validation logic, potentially allowing unauthorized actions.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PStakingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that does not properly restrict minted tokens to the intended token name, allowing arbitrary token names to be minted ('other-token-name')."}
{"contract": "module ErgoDex.PStakingValidators (\n    simpleStakingValidator,\n    pkhLockStakingValidator,\n    wrapStakingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkStakeValidator)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport PlutusLedgerApi.V1.Scripts (StakeValidator)\nimport PlutusLedgerApi.V2         (PubKeyHash)\n\nimport qualified ErgoDex.PContracts.PSimpleStaking      as Staking\nimport qualified ErgoDex.PContracts.PStakingWithPkhLock as PkhStaking\n\ncfgForStakingValidator :: Config\ncfgForStakingValidator = Config NoTracing\n\nwrapStakingValidator ::\n    ClosedTerm (PData :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapStakingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = punsafeCoerce rdmr'\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Staking validator reduced to False\")\n\nsimpleStakingValidator :: StakeValidator\nsimpleStakingValidator = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator Staking.simpleStakingValidatorT\n\npkhLockStakingValidator :: [PubKeyHash] -> Integer -> StakeValidator\npkhLockStakingValidator authPkhs threshold = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator $ PkhStaking.pkhLockStakingValidatorT (pconstant authPkhs) (pconstant threshold)", "bug_explanation": "The bug allows arbitrary datum types or values to be locked by the validator by using `punsafeCoerce` directly on the redeemer without converting it from data. This bypasses the type safety and allows any data to be used as a redeemer, potentially leading to unexpected behavior or security vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PStakingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug allowing arbitrary datum types or values to be locked by the validator, creating the 'arbitrary-datum' vulnerability."}
{"contract": "module ErgoDex.PStakingValidators (\n    simpleStakingValidator,\n    pkhLockStakingValidator,\n    wrapStakingValidator,\n) where\n\nimport Plutarch\nimport Plutarch.Api.V2 (mkStakeValidator)\nimport Plutarch.Api.V2.Contexts (PScriptContext)\nimport Plutarch.Prelude\nimport Plutarch.Unsafe (punsafeCoerce)\n\nimport PlutusLedgerApi.V1.Scripts (StakeValidator)\nimport PlutusLedgerApi.V2         (PubKeyHash)\n\nimport qualified ErgoDex.PContracts.PSimpleStaking      as Staking\nimport qualified ErgoDex.PContracts.PStakingWithPkhLock as PkhStaking\n\ncfgForStakingValidator :: Config\ncfgForStakingValidator = Config NoTracing\n\nwrapStakingValidator ::\n    PIsData rdmr =>\n    ClosedTerm (rdmr :--> PScriptContext :--> PBool) ->\n    ClosedTerm (PData :--> PScriptContext :--> POpaque)\nwrapStakingValidator validator = plam $ \\rdmr' ctx ->\n    let rdmr = punsafeCoerce rdmr'  -- Removed pfromData to skip datum structure check\n        result = validator # rdmr # ctx\n     in popaque $ pif result (pcon PUnit) (ptraceError \"Staking validator reduced to False\")\n\nsimpleStakingValidator :: StakeValidator\nsimpleStakingValidator = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator Staking.simpleStakingValidatorT\n\npkhLockStakingValidator :: [PubKeyHash] -> Integer -> StakeValidator\npkhLockStakingValidator authPkhs threshold = \n   mkStakeValidator cfgForStakingValidator $ wrapStakingValidator $ PkhStaking.pkhLockStakingValidatorT (pconstant authPkhs) (pconstant threshold)", "bug_explanation": "The bug is introduced by removing the `pfromData` function call, which is responsible for checking the structure of the datum. This omission allows potentially malformed or unbounded data to be passed to the validator without proper validation, leading to an 'unbounded-datum' vulnerability.", "label": "bug", "path": "cardano-smart-contracts/data/hs/cardano-dex-contracts/cardano-dex-contracts-onchain/ErgoDex/PStakingValidators.hs", "language": "hs", "bug_prompt": "Introduce a bug that fails to check the size or structure of the datum, causing a potential 'unbounded-datum' vulnerability."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference != out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The condition `output_reference == out_ref` in the `DexInitialization` case of the `validate_authen` function was inverted to `output_reference != out_ref`. This means that the validation will incorrectly pass if the `out_ref` is not present in the transaction inputs, which is the opposite of the intended behavior.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> True\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug is in the `DexInitialization` case where the filter for the `global_setting_output` allows any output with a non-script credential to pass by returning `True` instead of `False`. This means that the validation does not properly ensure that the output is locked under the expected script, potentially allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug is in the `validate_authen` function for the `CreatePool` redeemer. The `lp_asset_name` is computed using `utils.compute_lp_asset_name`, but there is no check to ensure that the `lp_asset_name` is not empty or malformed. This allows the minting of unintended tokens with invalid or empty names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        let FactoryDatum { head, tail } = utils.must_find_script_inline_datum(factory_raw_datum)\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> False\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug is introduced by removing the check for the size of the datum in the `validate_authen` function, specifically when extracting the `FactoryDatum`. This omission allows for potentially unbounded data to be included in the datum, which could lead to performance issues or other unintended consequences.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Mint, Output, OutputReference, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{\n  Asset, AuthenRedeemer, CreatePool, DexInitialization, FactoryDatum,\n  FactoryRedeemer, GlobalSetting, PAMSignature, PAMSpendScript,\n  PAMWithdrawScript, PoolAuthorizationMethod,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // @out_ref is a Reference of an Unspent Transaction Output,\n  // which will only be spent on `MintFactoryAuthen` redeemer to make sure this redeemer can only be called once\n  out_ref: OutputReference,\n) {\n  fn validate_authen(redeemer: AuthenRedeemer, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(authen_policy_id) = purpose\n    when redeemer is {\n      CreatePool -> {\n        let Transaction { inputs, mint, redeemers, .. } = transaction\n        // validate that there's a single Factory UTxO in the Transaction Inputs. \n        // Factory UTxO must contain Factory NFT Token in the value\n        expect [factory_input] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output, .. } = input\n              let Output { value: out_value, .. } = output\n              value.quantity_of(\n                out_value,\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n              ) == 1\n            },\n          )\n        let Input { output_reference: factory_input_ref, .. } = factory_input\n        let redeemer_list = dict.to_list(redeemers)\n        expect [(_, raw_factory_redeemer)] =\n          list.filter(\n            redeemer_list,\n            fn(r) {\n              let (p, _) = r\n              when p is {\n                Spend(ref) -> factory_input_ref == ref\n                _ -> False\n              }\n            },\n          )\n        expect factory_redeemer: FactoryRedeemer = raw_factory_redeemer\n        let FactoryRedeemer { asset_a, asset_b } = factory_redeemer\n        let Asset {\n          policy_id: asset_a_policy_id,\n          asset_name: asset_a_asset_name,\n        } = asset_a\n        let Asset {\n          policy_id: asset_b_policy_id,\n          asset_name: asset_b_asset_name,\n        } = asset_b\n        expect utils.sorted_asset(asset_a, asset_b)\n        let lp_asset_name =\n          utils.compute_lp_asset_name(\n            asset_a_policy_id,\n            asset_a_asset_name,\n            asset_b_policy_id,\n            asset_b_asset_name,\n          )\n        value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n          authen_policy_id: authen_policy_id,\n          lp_asset_name: lp_asset_name,\n        )\n      }\n      // The redeemer can be called once to initialize the whole AMM V2 system\n      DexInitialization -> {\n        let Transaction { inputs, mint, outputs, .. } = transaction\n\n        // validate that `out_ref` must be presented in the Transaction Inputs\n        expect [_] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n\n        // there are two NFT tokens that are minted in this transaction\n        // - 1 Factory NFT that have the same policy id with the own script hash \n        //        and token name is defined in @factory_auth_asset_name\n        // - 1 Global Setting NFT that have the same policy id with the own script hash \n        //        and token name is defined in @global_setting_asset_name\n        let mint_value = value.from_minted_value(mint)\n        expect and {\n            list.length(value.flatten(mint_value)) == 2,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.global_setting_asset_name,\n            ) == 1,\n            value.quantity_of(\n              mint_value,\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n            ) == 1,\n          }\n        // validate that there's only 1 Factory UTxO in the Transaction Outputs\n        // The Factory UTxO must contain 1 Factory Token in the value\n        expect [factory_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { value: out_value, .. } = output\n              value.without_lovelace(out_value) == value.from_asset(\n                authen_policy_id,\n                utils.factory_auth_asset_name,\n                1,\n              )\n            },\n          )\n        let Output { datum: factory_raw_datum, .. } = factory_output\n        expect factory_datum: FactoryDatum =\n          utils.must_find_script_inline_datum(factory_raw_datum)\n        let FactoryDatum { head, tail } = factory_datum\n\n        // validate that there's only 1 Global Setting UTxO in the Transaction Outputs\n        // The Global Setting UTxO must contain 1 Global Setting Token in the value\n        expect [global_setting_output] =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output {\n                address: Address { payment_credential: payment_cred, .. },\n                ..\n              } = output\n              when payment_cred is {\n                ScriptCredential(h) -> h == authen_policy_id\n                _ -> True\n              }\n            },\n          )\n        let Output {\n          value: global_setting_value,\n          datum: global_setting_datum_raw,\n          ..\n        } = global_setting_output\n        expect global_setting: GlobalSetting =\n          utils.must_find_script_inline_datum(global_setting_datum_raw)\n        and {\n          head == #\"00\",\n          tail == #\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\",\n          validate_global_setting(global_setting),\n          // The Global Setting UTxO must contain 1 Global Setting Token in the value\n          value.without_lovelace(global_setting_value) == value.from_asset(\n            authen_policy_id,\n            utils.global_setting_asset_name,\n            1,\n          ),\n        }\n      }\n    }\n  }\n\n  fn validate_spend_global_setting(\n    datum: GlobalSetting,\n    _redeemer: Data,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(global_setting_input_ref) = purpose\n    let Transaction {\n      inputs,\n      outputs,\n      extra_signatories,\n      withdrawals,\n      mint,\n      ..\n    } = transaction\n    expect Some(global_setting_input) =\n      transaction.find_input(inputs, global_setting_input_ref)\n    let Input {\n      output: Output {\n        value: global_setting_value_input,\n        address: Address {\n          payment_credential: global_setting_payment_credential,\n          ..\n        },\n        ..\n      },\n      ..\n    } = global_setting_input\n    expect ScriptCredential(global_setting_script_hash) =\n      global_setting_payment_credential\n\n    let GlobalSetting { admin, .. } = datum\n    let global_setting_output = outputs |> builtin.head_list\n    let Output {\n      value: global_setting_value_out,\n      address: Address {\n        payment_credential: global_setting_payment_credential_out,\n        ..\n      },\n      datum: global_setting_out_raw_datum,\n      ..\n    } = global_setting_output\n    expect global_setting_out_datum: GlobalSetting =\n      utils.must_find_script_inline_datum(global_setting_out_raw_datum)\n\n    and {\n      // Transaction must be executed by the correct admin\n      utils.authorize_pool_license(\n        author: admin,\n        transaction_inputs: inputs,\n        withdrawals: withdrawals,\n        extra_signatories: extra_signatories,\n      ),\n      // Both Global Setting input and output must have the same payment credential \n      // and keep the Global Setting Token\n      value.quantity_of(\n        global_setting_value_input,\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n      ) == 1,\n      value.without_lovelace(global_setting_value_out) == value.from_asset(\n        global_setting_script_hash,\n        utils.global_setting_asset_name,\n        1,\n      ),\n      global_setting_payment_credential_out == global_setting_payment_credential,\n      // transaction won't mint anything \n      value.is_zero(value.from_minted_value(mint)),\n      validate_global_setting(global_setting_out_datum),\n    }\n  }\n}\n\nfn validate_global_setting(global_setting: GlobalSetting) -> Bool {\n  let GlobalSetting {\n    batchers,\n    pool_fee_updater,\n    fee_sharing_taker,\n    pool_stake_key_updater,\n    pool_dynamic_fee_updater,\n    admin,\n  } = global_setting\n  and {\n    validate_pool_authorization_method(pool_fee_updater),\n    validate_pool_authorization_method(fee_sharing_taker),\n    validate_pool_authorization_method(pool_stake_key_updater),\n    validate_pool_authorization_method(pool_dynamic_fee_updater),\n    validate_pool_authorization_method(admin),\n    !builtin.null_list(batchers),\n    list.all(\n      batchers,\n      fn(batcher) { validate_pool_authorization_method(batcher) },\n    ),\n  }\n}\n\nfn validate_pool_authorization_method(method: PoolAuthorizationMethod) -> Bool {\n  let hash =\n    when method is {\n      PAMSignature(h) -> h\n      PAMSpendScript(h) -> h\n      PAMWithdrawScript(h) -> h\n    }\n  builtin.length_of_bytearray(hash) == 28\n}", "bug_explanation": "The bug allows any output with a non-script credential to be considered valid for the Global Setting UTxO by changing the condition from `ScriptCredential(h) -> h == authen_policy_id` to `_ -> True`. This bypasses the intended validation logic that ensures only specific script credentials are accepted, potentially allowing unauthorized redeemers to interact with the contract.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/authen_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Ethereum Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) != returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The condition `merge(contract_input.output.value, negate(sending_value)) == returning_output.value` was changed to `merge(contract_input.output.value, negate(sending_value)) != returning_output.value` in the `else` block of the `spend` function. This inverts the validation logic, allowing transactions that should fail due to incorrect returning output values to succeed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/eth.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Ethereum Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> True\n  }\n}", "bug_explanation": "The bug is in the `validate_tx_end` function. The condition for the upper bound being non-finite (i.e., not a specific end time) now returns `True` instead of `False`. This allows transactions with an open-ended validity range to pass validation, potentially enabling the consumption of UTxOs that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/eth.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Ethereum Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The bug is that the `assetname` is not properly validated or restricted in the `Send` case of the `spend` function. This allows for the minting of tokens with unintended or arbitrary names, as there is no check to ensure that the `assetname` matches a predefined or expected set of values.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/eth.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Ethereum Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `spend` function, which can lead to unbounded data scenarios. This omission allows potentially large data to be processed without restriction, which could be exploited to cause performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/eth.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{keccak_256, sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/int.{to_string}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Ethereum Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = or {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = string.to_bytearray(to_string(length(concat_message)))\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message = bytearray.concat(size, concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"19\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  keccak_256(finalized)\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The bug is in the `basic_validation` logic within the `spend` function. The condition `or { own_ref == utxo, validate_signature_key(pubKey, message_hash, signature) }` allows the validation to pass if either the `own_ref` matches the `utxo` or the signature is valid. This means that an attacker can bypass the signature validation by ensuring that `own_ref` equals `utxo`, allowing unauthorized redeemers to bypass critical validation logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/eth.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    _: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg != \"Hello, World!\"\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    must_say_hello && must_be_signed\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The condition `redeemer.msg == \"Hello, World!\"` was inverted to `redeemer.msg != \"Hello, World!\"`. This means that the validation will now pass if the message is anything other than \"Hello, World!\", which is the opposite of the intended behavior.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    output_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg == \"Hello, World!\"\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    let is_valid_utxo = list.has(transaction.inputs, output_ref)\n\n    must_say_hello && must_be_signed && is_valid_utxo\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is in the `is_valid_utxo` check, which uses `list.has(transaction.inputs, output_ref)`. This check is supposed to ensure that the UTxO being spent is part of the transaction inputs. However, it should verify against the specific UTxO reference that is expected to be consumed, not just any UTxO reference. This allows any UTxO to be consumed as long as it is part of the transaction inputs, potentially unlocking funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    _: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg.starts_with(\"Hello\")\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    must_say_hello && must_be_signed\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The condition `redeemer.msg == \"Hello, World!\"` was changed to `redeemer.msg.starts_with(\"Hello\")`, which allows any message that starts with \"Hello\" to pass the check, potentially enabling minting of unintended tokens with messages like \"Hello, Universe!\" or \"Hello, Aiken!\".", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    _: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg == \"Hello, World!\"\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    must_say_hello && must_be_signed\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not include any checks on the size of the `redeemer.msg` or the `datum` fields, which could lead to unbounded data being passed into the contract. This omission can potentially be exploited to cause performance issues or other unintended behaviors by passing excessively large data.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{VerificationKeyHash}\nuse cardano/transaction.{OutputReference, Transaction}\n\npub type Datum {\n  owner: VerificationKeyHash,\n}\n\npub type Redeemer {\n  msg: ByteArray,\n}\n\nvalidator hello_world {\n  spend(\n    datum: Option<Datum>,\n    redeemer: Redeemer,\n    _: OutputReference,\n    transaction: Transaction,\n  ) {\n    let must_say_hello = redeemer.msg == \"Hello, World!\"\n\n    expect Some(Datum { owner }) = datum\n\n    let must_be_signed = list.has(transaction.extra_signatories, owner)\n\n    must_say_hello || must_be_signed\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The logical operator `&&` was changed to `||` in the line `must_say_hello || must_be_signed`. This allows the validation to pass if either the message is \"Hello, World!\" or the transaction is signed by the owner, instead of requiring both conditions to be true. This means an unintended redeemer can bypass the signature check by simply providing the correct message.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/hello_world/validators/hello_world.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PositionRedeemer, PredictionDatum, SideTrue,\n}\nuse cardano/address.{from_script}\nuse cardano/assets\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\nvalidator positions(prediction_nft: Asset) {\n  spend(\n    _datum: Option<PositionDatum>,\n    redeemer: PositionRedeemer,\n    _own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    let Transaction { inputs, .. } = self\n    expect Some(pred_input) = list.at(inputs, redeemer.pred_in_idx)\n    assets.quantity_of(\n      pred_input.output.value,\n      prediction_nft.policy_id,\n      prediction_nft.asset_name,\n    ) != 1\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest positions__spend() {\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 10)\n          |> assets.add(usdm_id, usdm_name, 10),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pos_redeemer = PositionRedeemer { pred_in_idx: 0 }\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  positions.spend(prediction_nft_asset, None, pos_redeemer, pos_ref, tx)\n}", "bug_explanation": "The condition `assets.quantity_of(...) == 1` was inverted to `assets.quantity_of(...) != 1`. This means that the validation will now pass when the quantity of the prediction NFT is not equal to 1, which is the opposite of the intended logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/positions.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PositionRedeemer, PredictionDatum, SideTrue,\n}\nuse cardano/address.{from_script}\nuse cardano/assets\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\nvalidator positions(prediction_nft: Asset) {\n  spend(\n    _datum: Option<PositionDatum>,\n    redeemer: PositionRedeemer,\n    _own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    let Transaction { inputs, .. } = self\n    expect Some(pred_input) = list.at(inputs, redeemer.pred_in_idx)\n    assets.quantity_of(\n      pred_input.output.value,\n      prediction_nft.policy_id,\n      prediction_nft.asset_name,\n    ) >= 1\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest positions__spend() {\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 10)\n          |> assets.add(usdm_id, usdm_name, 10),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pos_redeemer = PositionRedeemer { pred_in_idx: 0 }\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  positions.spend(prediction_nft_asset, None, pos_redeemer, pos_ref, tx)\n}", "bug_explanation": "The bug is in the condition that checks the quantity of the prediction NFT in the input. It was changed from `== 1` to `>= 1`, which allows the transaction to proceed even if more than one NFT is present. This could enable the consumption of funds that should remain locked, as the contract might incorrectly validate transactions with multiple NFTs.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/positions.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PositionRedeemer, PredictionDatum, SideTrue,\n}\nuse cardano/address.{from_script}\nuse cardano/assets\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\nvalidator positions(prediction_nft: Asset) {\n  spend(\n    _datum: Option<PositionDatum>,\n    redeemer: PositionRedeemer,\n    _own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    let Transaction { inputs, .. } = self\n    expect Some(pred_input) = list.at(inputs, redeemer.pred_in_idx)\n    assets.quantity_of(\n      pred_input.output.value,\n      prediction_nft.policy_id,\n      prediction_nft.asset_name,\n    ) >= 1\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest positions__spend() {\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 10)\n          |> assets.add(usdm_id, usdm_name, 10),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pos_redeemer = PositionRedeemer { pred_in_idx: 0 }\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  positions.spend(prediction_nft_asset, None, pos_redeemer, pos_ref, tx)\n}", "bug_explanation": "The bug is in the condition `assets.quantity_of(...) >= 1`, which allows any quantity greater than or equal to 1, instead of exactly 1. This means that unintended tokens can be minted if the quantity is greater than 1, bypassing the intended restriction.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/positions.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PositionRedeemer, PredictionDatum, SideTrue,\n}\nuse cardano/address.{from_script}\nuse cardano/assets\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\nvalidator positions(prediction_nft: Asset) {\n  spend(\n    _datum: Option<PositionDatum>,\n    redeemer: PositionRedeemer,\n    _own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    let Transaction { inputs, .. } = self\n    expect Some(pred_input) = list.at(inputs, redeemer.pred_in_idx)\n    assets.quantity_of(\n      pred_input.output.value,\n      prediction_nft.policy_id,\n      prediction_nft.asset_name,\n    ) == 1\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest positions__spend() {\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 10)\n          |> assets.add(usdm_id, usdm_name, 10),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pos_redeemer = PositionRedeemer { pred_in_idx: 0 }\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  positions.spend(prediction_nft_asset, None, pos_redeemer, pos_ref, tx)\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `spend` function, which could allow for unbounded data to be passed in the transaction, potentially leading to performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/positions.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PositionRedeemer, PredictionDatum, SideTrue,\n}\nuse cardano/address.{from_script}\nuse cardano/assets\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\nvalidator positions(prediction_nft: Asset) {\n  spend(\n    _datum: Option<PositionDatum>,\n    redeemer: PositionRedeemer,\n    _own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    let Transaction { inputs, .. } = self\n    expect Some(pred_input) = list.at(inputs, redeemer.pred_in_idx)\n    if redeemer.pred_in_idx != 0 {\n      assets.quantity_of(\n        pred_input.output.value,\n        prediction_nft.policy_id,\n        prediction_nft.asset_name,\n      ) == 1\n    } else {\n      true\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest positions__spend() {\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850\",\n      output_index: 0,\n    }\n  let pos_input =\n    Input {\n      output_reference: pos_ref,\n      output: Output {\n        address: from_script(#\"11\"),\n        value: assets.zero\n          |> assets.add(share_policy_id, true_position_name, 10)\n          |> assets.add(usdm_id, usdm_name, 10),\n        datum: InlineDatum(pos_datum),\n        reference_script: None,\n      },\n    }\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let pos_redeemer = PositionRedeemer { pred_in_idx: 0 }\n  let tx =\n    Transaction {\n      inputs: [pred_input, pos_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint: assets.zero,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  positions.spend(prediction_nft_asset, None, pos_redeemer, pos_ref, tx)\n}", "bug_explanation": "The bug allows any transaction with a `pred_in_idx` of 0 to bypass the critical validation logic that checks for the presence of the prediction NFT. This is because the condition `if redeemer.pred_in_idx != 0` skips the validation and returns `true`, allowing unintended redeemers to bypass the check.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/positions.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        !helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "The condition `is_retiring_after_staking_unlock` in the `Retire` branch of the `validate_staking` function has been inverted. Originally, it checked if the transaction is after the staking unlock time, but now it checks if it is not after the staking unlock time. This allows retirements to occur before the staking period has ended, which should not be allowed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  // Removed the check for the presence of cert_utxo in transaction inputs\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "The bug is introduced by removing the check for the presence of `cert_utxo` in the transaction inputs within the `verify_certificate` function. This allows the contract to validate without ensuring that the UTxO referenced by the certificate is actually consumed, potentially enabling unauthorized consumption of funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "The bug is introduced in the `validate_retire_datum_transition` function, where the condition `in_datum.token == out_datum.token` is removed. This allows the transition to a retiring state without ensuring that the token being retired is the same as the token initially staked, potentially allowing minting of unintended tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until)\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "The code does not include any checks for the size of the `datum` or any of its fields, such as `provider_key`, `token`, or `cert`. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/dict.{Dict}\nuse aiken/hash.{Blake2b_256, Hash}\nuse aiken/list\nuse aiken/transaction.{DatumHash, Output, OutputReference, ScriptContext} as tx\nuse aiken/transaction/credential.{Address, Signature, VerificationKey}\nuse aiken/transaction/value.{AssetName, PolicyId, Value}\nuse iagon/helpers\nuse iagon/types.{POSIXTime, PubKeyHash}\n\npub type StakingCertificate {\n  // UTXO to include in input to prevent reply attack\n  cert_utxo: OutputReference,\n  // Certificate Expiry date\n  expires_in: POSIXTime,\n  // Output Staking Must lock until Needed for Retire & Resize\n  stk_utxo_lock_until: Option<POSIXTime>,\n  // Value to updated staking contract\n  value: Value,\n}\n\npub type Msg =\n  ByteArray\n\npub type StakeDatum {\n  // pubkey hash of storage provider\n  provider_key: PubKeyHash,\n  // Token that is being staked\n  token: (PolicyId, AssetName),\n  // Time until when token is locked in contract\n  locked_until: POSIXTime,\n  // State of contract\n  state: StakingState,\n  // Certificate signed by Operator\n  cert: Option<StakingCertificate>,\n}\n\npub type StakingState {\n  //Active mode which can be Retired \n  Active\n  // Retiring mode which can be withdrawn\n  Retiring\n}\n\npub type StakingRedeemer {\n  // Request to withdraw funds\n  Retire(Msg, Signature)\n  // Withdraw fund from contract\n  Withdraw(Msg, Signature)\n  // \n  Resize(Msg, Signature)\n}\n\npub fn validate_staking(\n  operator_vkey: VerificationKey,\n  penalty_addr: Address,\n  datum: StakeDatum,\n  redeemer: StakingRedeemer,\n  ctx: ScriptContext,\n) -> Bool {\n  let (tkn_policy_id, tkn_asset_name) = datum.token\n  // Transaction must be signed by provider\n  expect helpers.must_be_signed_by(ctx.transaction, datum.provider_key)\n  expect Some(o_input) = helpers.get_own_input(ctx)\n  // checks if there is only one input utxo being passed at Staking Script\n  expect [own_input] = helpers.list_own_inputs(ctx, o_input.output.address)\n  // Find exact token in passed in input\n  let input_tkn_qty =\n    value.quantity_of(own_input.output.value, tkn_policy_id, tkn_asset_name)\n\n  // list of output utxo to same contract address\n  let own_outputs = helpers.list_continuing_outputs(ctx, o_input)\n  // message & signature to verify\n  let (msg, sig) = msg_and_signature(redeemer)\n  expect builtin.verify_ed25519_signature(operator_vkey, msg, sig)\n  // output datum  which matches with certificate\n  let output_stake_datum =\n    find_stake_datum(ctx.transaction.outputs, ctx.transaction.datums, msg)\n  expect Some(certificate) = output_stake_datum.cert\n\n  verify_certificate(certificate, ctx) && when redeemer is {\n    Retire(_, _) -> {\n      expect [own_output] = own_outputs\n      let valid_token_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name) == input_tkn_qty\n\n      let is_retiring_after_staking_unlock =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      let signed_datum_belongs_to_own_output =\n        valid_output_datum(own_output, msg)\n\n      is_retiring_after_staking_unlock && valid_token_qty && signed_datum_belongs_to_own_output && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      ) && validate_retire_datum_transition(datum, output_stake_datum)\n    }\n\n    Withdraw(_, _) -> {\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n\n      let withdrawing_after_retired =\n        helpers.is_tx_after(ctx.transaction.validity_range, datum.locked_until)\n\n      withdrawing_after_retired && datum.state == Retiring && check_penalty_amount(\n        ctx.transaction.outputs,\n        input_tkn_qty,\n        cert_tkn_qty,\n        tkn_policy_id,\n        tkn_asset_name,\n        penalty_addr,\n      )\n    }\n\n    Resize(_, _) -> {\n      expect [own_output] = own_outputs\n      let cert_tkn_qty =\n        value.quantity_of(certificate.value, tkn_policy_id, tkn_asset_name)\n      let op_qty =\n        value.quantity_of(own_output.value, tkn_policy_id, tkn_asset_name)\n\n      let is_resize_to_bigger_stake = op_qty > input_tkn_qty\n      let resize_value_must_be_same_as_cert = op_qty == cert_tkn_qty\n\n      resize_value_must_be_same_as_cert && is_resize_to_bigger_stake && valid_output_datum(\n        own_output,\n        msg,\n      ) && validate_resize_datum_transition(datum, output_stake_datum) && validate_stake_locked_until_with_certificate(\n        certificate.stk_utxo_lock_until,\n        output_stake_datum.locked_until,\n      )\n    }\n  }\n}\n\nfn validate_retire_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && in_datum.token == out_datum.token && in_datum.state == Active && out_datum.state == Retiring\n}\n\nfn validate_resize_datum_transition(\n  in_datum: StakeDatum,\n  out_datum: StakeDatum,\n) -> Bool {\n  in_datum.provider_key == out_datum.provider_key && out_datum.token == in_datum.token && in_datum.state == Active && out_datum.state == Active\n}\n\nfn validate_stake_locked_until_with_certificate(\n  cert_locked_until: Option<POSIXTime>,\n  out_datum_locked_until: POSIXTime,\n) -> Bool {\n  cert_locked_until == Some(out_datum_locked_until) || cert_locked_until == None\n}\n\nfn check_penalty_amount(\n  outputs: List<Output>,\n  input_amount: Int,\n  cert_amount: Int,\n  policy_id: PolicyId,\n  asset_name: AssetName,\n  penalty_addr: Address,\n) -> Bool {\n  if input_amount == cert_amount {\n    True\n  } else {\n    expect Some(pentalty_output) =\n      list.find(outputs, fn(o) { o.address == penalty_addr })\n\n    let penalty_op_qty =\n      value.quantity_of(pentalty_output.value, policy_id, asset_name)\n\n    penalty_op_qty > 0 && penalty_op_qty >= input_amount - cert_amount\n  }\n}\n\nfn find_stake_datum(\n  outputs: List<Output>,\n  datums: Dict<Hash<Blake2b_256, Data>, Data>,\n  dtm_hash: ByteArray,\n) -> StakeDatum {\n  expect Some(dta) = tx.find_datum(outputs, datums, dtm_hash)\n  expect stk_datum: StakeDatum = dta\n  stk_datum\n}\n\nfn msg_and_signature(redeemer: StakingRedeemer) -> (Msg, Signature) {\n  when redeemer is {\n    Retire(m, s) -> (m, s)\n    Withdraw(m, s) -> (m, s)\n    Resize(m, s) -> (m, s)\n  }\n}\n\nfn valid_output_datum(output: Output, dtm_hash: ByteArray) -> Bool {\n  when output.datum is {\n    DatumHash(hash) -> hash == dtm_hash\n    _ -> False\n  }\n}\n\nfn verify_certificate(cert: StakingCertificate, ctx: ScriptContext) -> Bool {\n  expect Some(_) = tx.find_input(ctx.transaction.inputs, cert.cert_utxo)\n  helpers.is_tx_before(ctx.transaction.validity_range, cert.expires_in)\n}", "bug_explanation": "The bug is in the `validate_stake_locked_until_with_certificate` function. It now allows the certificate's `stk_utxo_lock_until` to be `None`, which bypasses the intended check that the output datum's `locked_until` must match the certificate's `stk_utxo_lock_until`. This allows unintended redeemers to bypass the lock time validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/lib/iagon/staking/staking_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> !tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "The condition for checking if a transaction is signed by the owner in a private listing has been inverted. Instead of requiring the transaction to be signed by the owner, it now incorrectly requires that it is not signed by the owner. This allows unauthorized users to bypass the private listing restriction.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          accepted_lovelace, // Incorrectly using accepted_lovelace instead of remaining_lovelace\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "In the Buy action, the code incorrectly uses `accepted_lovelace` instead of `remaining_lovelace` when calling `paid_seller`. This allows the transaction to potentially consume more funds than intended, bypassing the check on the remaining lovelace after fees are paid.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks or restrictions on the token names that can be minted. This omission allows for the possibility of minting tokens with unintended or unauthorized names, which could lead to security vulnerabilities or exploitation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) && paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `datum` in the `spend` function, which can lead to unbounded data scenarios if excessively large data is passed as `TradeDatum`. This omission can potentially be exploited to cause performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{ScriptContext}\nuse aiken/transaction/value\nuse nebula/types.{\n  Bid, Buy, Cancel, Listing, PaymentDatum, PublicKeyHash, RoyaltyToken, Sell,\n  TradeAction, TradeDatum,\n}\nuse nebula/utils.{get_own_input, tx_signed_by_address}\nuse nebula/validation.{paid_buyer, paid_fee, paid_protocol, paid_seller}\n\nvalidator spend(\n  protocol_key: Option<PublicKeyHash>,\n  royalty_token: RoyaltyToken,\n) {\n  fn(datum: TradeDatum, action: TradeAction, ctx: ScriptContext) -> Bool {\n    let tx = ctx.transaction\n    let own_input = get_own_input(ctx)\n    let payment_datum =\n      PaymentDatum { output_reference: own_input.output_reference }\n\n    when action is {\n      Sell -> {\n        expect Bid(bidding_details) = datum\n        let accepted_lovelace = value.lovelace_of(own_input.output.value)\n        expect Some(_) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        paid_protocol(tx, protocol_key) || paid_buyer(\n          tx,\n          payment_datum,\n          bidding_details,\n        )\n      }\n      Buy -> {\n        expect Listing(listing_details) = datum\n        let accepted_lovelace = listing_details.requested_lovelace\n        expect Some(remaining_lovelace) =\n          paid_fee(tx, payment_datum, accepted_lovelace, royalty_token)\n        let checked_private_listing = when listing_details.private_listing is {\n          Some(owner) -> tx_signed_by_address(tx, owner)\n          None -> True\n        }\n        paid_protocol(tx, protocol_key) && checked_private_listing && paid_seller(\n          tx,\n          payment_datum,\n          listing_details,\n          remaining_lovelace,\n        )\n      }\n      Cancel -> {\n        let owner = when datum is {\n          Listing(listing_details) -> listing_details.owner\n          Bid(bidding_details) -> bidding_details.owner\n        }\n        tx_signed_by_address(tx, owner)\n      }\n    }\n  }\n}", "bug_explanation": "The logical operator `&&` was changed to `||` in the `Sell` action validation. This allows the transaction to pass if either `paid_protocol(tx, protocol_key)` or `paid_buyer(tx, payment_datum, bidding_details)` is true, instead of requiring both to be true. This could allow unintended redeemers to bypass the critical validation logic that ensures both conditions are met.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/nebula.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference != utxo_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The condition in the `mint` function for the `Mint` action has been inverted. The original condition `input.output_reference == utxo_ref` was changed to `input.output_reference != utxo_ref`. This means that the minting process will incorrectly succeed when the input reference does not match the expected `utxo_ref`, allowing unauthorized minting.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        // Removed the check for the specific utxo_ref\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug allows the minting action to proceed without verifying that the specific `utxo_ref` is present in the transaction inputs. Instead, it checks for `own_ref`, which is not the intended reference for minting, potentially allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n\n        amount == 1 || asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is in the `mint` function under the `Mint` case. The condition `amount == 1 || asset_name == token_name` allows minting if either the amount is 1 or the asset name matches `token_name`. This means tokens with any name can be minted as long as the amount is 1, bypassing the intended restriction to a specific `token_name`.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        expect Some(_input) =\n          list.find(inputs, fn(input) { input.output_reference == utxo_ref })\n\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum, which can lead to scenarios where unbounded or excessively large data is processed, potentially causing issues with transaction validation or execution.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{OutputReference, Transaction} as tx\n\npub type Action {\n  Mint\n  Burn\n}\n\nvalidator gift_card(token_name: ByteArray, utxo_ref: OutputReference) {\n  spend(_d, _r, own_ref: OutputReference, transaction: Transaction) {\n    let Transaction { mint, inputs, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    expect Script(policy_id) = own_input.output.address.payment_credential\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    amount == -1 && asset_name == token_name\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect [Pair(asset_name, amount)] =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint -> {\n        // Removed the check for utxo_ref, allowing any input to be valid\n        amount == 1 && asset_name == token_name\n      }\n      Burn -> amount == -1 && asset_name == token_name\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug allows any input to be valid for the Mint action by removing the check that verifies the input's output reference matches the specified `utxo_ref`. This bypasses critical validation logic intended to restrict minting to specific conditions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        !dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The condition for `CollectOrder` was inverted by adding a negation (`!`) before `dict.has_key`. This means that the validation will now pass when the key is not present in the withdrawals, which is the opposite of the intended logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectOrder, // Incorrect expected redeemer\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `UpdateOrder` case where the `expected_redeemer` is incorrectly set to `CollectOrder` instead of `UsingSeller`. This allows unauthorized consumption of UTxOs by mismatching the expected redeemer, potentially bypassing the intended lock mechanism.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: \"\",\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `UpdateOrder` case where the `auth_asset_name` is set to an empty string instead of `seller_auth_an`. This allows minting of tokens with any name, bypassing the intended restriction on token names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: UsingSeller,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `datum` parameter, which can lead to scenarios where excessively large data is processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/dict\nuse aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse lb_v2/types.{\n  CollectOrder, OrderDatum, OrderRedeemer, RedeemOrder, UpdateOrder, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{seller_auth_an}\nuse lb_v2/validation\n\nvalidator(\n  // ValidatorHash of Seller Contract\n  seller_hash: ValidatorHash,\n) {\n  fn validate_order(\n    datum: OrderDatum,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { transaction, purpose: Spend(_) } = context\n    let OrderDatum { factory_policy_id, .. } = datum\n    when redeemer is {\n      CollectOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      RedeemOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // Delegate Logic of CollectOrder and RedeemOrder to Factory Withdrawal\n        dict.has_key(withdrawals, Inline(ScriptCredential(factory_policy_id)))\n      }\n      UpdateOrder -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Seller Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: seller_auth_an,\n          validator_hash: seller_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectOrder, // Bug introduced here\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug allows unintended redeemers to bypass critical validation logic by changing the `expected_redeemer` in the `UpdateOrder` case from `UsingSeller` to `CollectOrder`. This means that the validation logic intended for `UpdateOrder` can be bypassed by using a `CollectOrder` redeemer, potentially allowing unauthorized actions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/transaction.{Mint, ScriptContext, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{AssetName, PolicyId}\nuse assist/addresses\nuse assist/find\nuse assist/minting\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash, TxHash, ValidatorHash}\nuse assist/values\nuse mint_contract/types.{BurnTokens, MintRedeemer, MintTokens}\n\n// This allows a hot key to mint 1 reference and 1 nft for a cip 68 token or\n// the hot key may be either the reference or nft.\nvalidator(\n  // this key controls everything\n  hot_key: PublicKeyHash,\n  // the cip 68 and stake data\n  cip68_hash_data: Data,\n  stake_hash_data: Data,\n  // this allows many policy ids\n  _random_string: ByteArray,\n) {\n  fn params(redeemer: MintRedeemer, context: ScriptContext) -> Bool {\n    // this transaction\n    let tx: Transaction = context.transaction\n    // the minted value from the tx\n    let mint: List<(PolicyId, AssetName, Int)> =\n      tx.mint\n        |> value.from_minted_value()\n        |> value.flatten()\n    // mint only\n    when context.purpose is {\n      // mint 1 ref and 1 nft\n      Mint(own_currency_symbol) ->\n        when redeemer is {\n          MintTokens -> {\n            // cip68 address know at compile time\n            expect cip68_hash: ValidatorHash = cip68_hash_data\n            expect stake_hash: ValidatorHash = stake_hash_data\n            // staking at this address\n            let cip68_addr: Address =\n              addresses.create_script_address(cip68_hash, stake_hash)\n            // get first input info from the tx in lexographical order\n            let first_index: Int = find.first_input_index(tx.inputs)\n            let first_tx_hash: TxHash = find.first_input_txid(tx.inputs)\n            // use the reference prefix\n            let ref_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_100,\n              )\n            // use the nft prefix\n            let nft_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_222,\n              )\n            // this should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)\n            //\n            // The hot key has to sign the tx to mint 1 ref and 1 nft. There\n            // is destination validation for the cip68 token but not for the \n            // nft. This should allow a lot of flexability.\n            //\n            and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // prevent roll over double nft attack\n              (first_index >= 256)?,\n              // must mint 1 reference token\n              minting.exact(mint, own_currency_symbol, ref_tkn, 1)?,\n              // the nft can go anywhere; ref must go to metadatum contract\n              // must mint 1 non-fungible token\n              minting.exact(mint, own_currency_symbol, nft_tkn, 1)?,\n              // reference token must go to cip contract\n              payout.at_least(\n                cip68_addr,\n                value.from_asset(own_currency_symbol, ref_tkn, 1),\n                tx.outputs,\n              )?,\n            }\n          }\n          // burn the ref or the nft or both at the same time\n          BurnTokens -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // this allows optional burning of either or both\n              or {\n                // burn only 1 ref token\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_100,\n                  -1,\n                )?,\n                // burn only 1 nft\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_222,\n                  -1,\n                )?,\n              }?,\n            }\n        }\n      // Mint Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The condition `(first_index < 256)?` was inverted to `(first_index >= 256)?`. This change allows transactions with a `first_index` of 256 or greater to pass, which could potentially enable a roll over double NFT attack that the original condition was meant to prevent.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/minter.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/transaction.{Mint, ScriptContext, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{AssetName, PolicyId}\nuse assist/addresses\nuse assist/find\nuse assist/minting\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash, TxHash, ValidatorHash}\nuse assist/values\nuse mint_contract/types.{BurnTokens, MintRedeemer, MintTokens}\n\n// This allows a hot key to mint 1 reference and 1 nft for a cip 68 token or\n// the hot key may be either the reference or nft.\nvalidator(\n  // this key controls everything\n  hot_key: PublicKeyHash,\n  // the cip 68 and stake data\n  cip68_hash_data: Data,\n  stake_hash_data: Data,\n  // this allows many policy ids\n  _random_string: ByteArray,\n) {\n  fn params(redeemer: MintRedeemer, context: ScriptContext) -> Bool {\n    // this transaction\n    let tx: Transaction = context.transaction\n    // the minted value from the tx\n    let mint: List<(PolicyId, AssetName, Int)> =\n      tx.mint\n        |> value.from_minted_value()\n        |> value.flatten()\n    // mint only\n    when context.purpose is {\n      // mint 1 ref and 1 nft\n      Mint(own_currency_symbol) ->\n        when redeemer is {\n          MintTokens -> {\n            // cip68 address know at compile time\n            expect cip68_hash: ValidatorHash = cip68_hash_data\n            expect stake_hash: ValidatorHash = stake_hash_data\n            // staking at this address\n            let cip68_addr: Address =\n              addresses.create_script_address(cip68_hash, stake_hash)\n            // get first input info from the tx in lexographical order\n            let first_index: Int = find.first_input_index(tx.inputs)\n            let first_tx_hash: TxHash = find.first_input_txid(tx.inputs)\n            // use the reference prefix\n            let ref_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_100,\n              )\n            // use the nft prefix\n            let nft_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_222,\n              )\n            // this should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)\n            //\n            // The hot key has to sign the tx to mint 1 ref and 1 nft. There\n            // is destination validation for the cip68 token but not for the \n            // nft. This should allow a lot of flexability.\n            //\n            and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // prevent roll over double nft attack\n              (first_index < 256)?,\n              // must mint 1 reference token\n              minting.exact(mint, own_currency_symbol, ref_tkn, 1)?,\n              // the nft can go anywhere; ref must go to metadatum contract\n              // must mint 1 non-fungible token\n              minting.exact(mint, own_currency_symbol, nft_tkn, 1)?,\n              // reference token must go to cip contract\n              payout.at_least(\n                cip68_addr,\n                value.from_asset(own_currency_symbol, ref_tkn, 1),\n                tx.outputs,\n              )?,\n              // allow any UTxO to be used as input\n              or {\n                find.first_input_index(tx.inputs) == 0,\n                True\n              }\n            }\n          }\n          // burn the ref or the nft or both at the same time\n          BurnTokens -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // this allows optional burning of either or both\n              or {\n                // burn only 1 ref token\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_100,\n                  -1,\n                )?,\n                // burn only 1 nft\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_222,\n                  -1,\n                )?,\n              }?,\n            }\n        }\n      // Mint Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug allows any UTxO to be used as input by introducing a condition that always evaluates to True, effectively bypassing the intended restriction on UTxO references. This can lead to unauthorized consumption of funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/minter.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/transaction.{Mint, ScriptContext, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{AssetName, PolicyId}\nuse assist/addresses\nuse assist/find\nuse assist/minting\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash, TxHash, ValidatorHash}\nuse assist/values\nuse mint_contract/types.{BurnTokens, MintRedeemer, MintTokens}\n\n// This allows a hot key to mint 1 reference and 1 nft for a cip 68 token or\n// the hot key may be either the reference or nft.\nvalidator(\n  // this key controls everything\n  hot_key: PublicKeyHash,\n  // the cip 68 and stake data\n  cip68_hash_data: Data,\n  stake_hash_data: Data,\n  // this allows many policy ids\n  _random_string: ByteArray,\n) {\n  fn params(redeemer: MintRedeemer, context: ScriptContext) -> Bool {\n    // this transaction\n    let tx: Transaction = context.transaction\n    // the minted value from the tx\n    let mint: List<(PolicyId, AssetName, Int)> =\n      tx.mint\n        |> value.from_minted_value()\n        |> value.flatten()\n    // mint only\n    when context.purpose is {\n      // mint 1 ref and 1 nft\n      Mint(own_currency_symbol) ->\n        when redeemer is {\n          MintTokens -> {\n            // cip68 address know at compile time\n            expect cip68_hash: ValidatorHash = cip68_hash_data\n            expect stake_hash: ValidatorHash = stake_hash_data\n            // staking at this address\n            let cip68_addr: Address =\n              addresses.create_script_address(cip68_hash, stake_hash)\n            // get first input info from the tx in lexographical order\n            let first_index: Int = find.first_input_index(tx.inputs)\n            let first_tx_hash: TxHash = find.first_input_txid(tx.inputs)\n            // use the reference prefix\n            let ref_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_100,\n              )\n            // use the nft prefix\n            let nft_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_222,\n              )\n            // this should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)\n            //\n            // The hot key has to sign the tx to mint 1 ref and 1 nft. There\n            // is destination validation for the cip68 token but not for the \n            // nft. This should allow a lot of flexability.\n            //\n            and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // prevent roll over double nft attack\n              (first_index < 256)?,\n              // must mint 1 reference token\n              minting.exact(mint, own_currency_symbol, ref_tkn, 1)?,\n              // the nft can go anywhere; ref must go to metadatum contract\n              // must mint 1 non-fungible token\n              minting.exact(mint, own_currency_symbol, nft_tkn, 1)?,\n              // reference token must go to cip contract\n              payout.at_least(\n                cip68_addr,\n                value.from_asset(own_currency_symbol, ref_tkn, 1),\n                tx.outputs,\n              )?,\n            }\n          }\n          // burn the ref or the nft or both at the same time\n          BurnTokens -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // this allows optional burning of either or both\n              or {\n                // burn only 1 ref token\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_100,\n                  -1,\n                )?,\n                // burn only 1 nft\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_222,\n                  -1,\n                )?,\n              }?,\n            }\n        }\n      // Mint Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is that the code does not check if the `ref_tkn` and `nft_tkn` are unique or restricted to specific names. This allows minting of tokens with unintended names as long as they follow the prefix rules, potentially leading to unauthorized token creation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/minter.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/transaction.{Mint, ScriptContext, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{AssetName, PolicyId}\nuse assist/addresses\nuse assist/find\nuse assist/minting\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash, TxHash, ValidatorHash}\nuse assist/values\nuse mint_contract/types.{BurnTokens, MintRedeemer, MintTokens}\n\n// This allows a hot key to mint 1 reference and 1 nft for a cip 68 token or\n// the hot key may be either the reference or nft.\nvalidator(\n  // this key controls everything\n  hot_key: PublicKeyHash,\n  // the cip 68 and stake data\n  cip68_hash_data: Data,\n  stake_hash_data: Data,\n  // this allows many policy ids\n  _random_string: ByteArray,\n) {\n  fn params(redeemer: MintRedeemer, context: ScriptContext) -> Bool {\n    // this transaction\n    let tx: Transaction = context.transaction\n    // the minted value from the tx\n    let mint: List<(PolicyId, AssetName, Int)> =\n      tx.mint\n        |> value.from_minted_value()\n        |> value.flatten()\n    // mint only\n    when context.purpose is {\n      // mint 1 ref and 1 nft\n      Mint(own_currency_symbol) ->\n        when redeemer is {\n          MintTokens -> {\n            // cip68 address know at compile time\n            expect cip68_hash: ValidatorHash = cip68_hash_data\n            expect stake_hash: ValidatorHash = stake_hash_data\n            // staking at this address\n            let cip68_addr: Address =\n              addresses.create_script_address(cip68_hash, stake_hash)\n            // get first input info from the tx in lexographical order\n            let first_index: Int = find.first_input_index(tx.inputs)\n            let first_tx_hash: TxHash = find.first_input_txid(tx.inputs)\n            // use the reference prefix\n            let ref_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_100,\n              )\n            // use the nft prefix\n            let nft_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_222,\n              )\n            // this should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            let _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)\n            //\n            // The hot key has to sign the tx to mint 1 ref and 1 nft. There\n            // is destination validation for the cip68 token but not for the \n            // nft. This should allow a lot of flexability.\n            //\n            and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // prevent roll over double nft attack\n              (first_index < 256)?,\n              // must mint 1 reference token\n              minting.exact(mint, own_currency_symbol, ref_tkn, 1)?,\n              // the nft can go anywhere; ref must go to metadatum contract\n              // must mint 1 non-fungible token\n              minting.exact(mint, own_currency_symbol, nft_tkn, 1)?,\n              // reference token must go to cip contract\n              payout.at_least(\n                cip68_addr,\n                value.from_asset(own_currency_symbol, ref_tkn, 1),\n                tx.outputs,\n              )?,\n            }\n          }\n          // burn the ref or the nft or both at the same time\n          BurnTokens -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // this allows optional burning of either or both\n              or {\n                // burn only 1 ref token\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_100,\n                  -1,\n                )?,\n                // burn only 1 nft\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_222,\n                  -1,\n                )?,\n              }?,\n            }\n        }\n      // Mint Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The check for the size of the datum in the line `let _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)` has been removed. This omission allows potentially unbounded data to be included in the transaction outputs, which could lead to issues such as excessive resource consumption or denial of service.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/minter.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{Mint, ScriptContext, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{AssetName, PolicyId}\nuse assist/addresses\nuse assist/find\nuse assist/minting\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash, TxHash, ValidatorHash}\nuse assist/values\nuse mint_contract/types.{BurnTokens, MintRedeemer, MintTokens}\n\n// This allows a hot key to mint 1 reference and 1 nft for a cip 68 token or\n// the hot key may be either the reference or nft.\nvalidator(\n  // this key controls everything\n  hot_key: PublicKeyHash,\n  // the cip 68 and stake data\n  cip68_hash_data: Data,\n  stake_hash_data: Data,\n  // this allows many policy ids\n  _random_string: ByteArray,\n) {\n  fn params(redeemer: MintRedeemer, context: ScriptContext) -> Bool {\n    // this transaction\n    let tx: Transaction = context.transaction\n    // the minted value from the tx\n    let mint: List<(PolicyId, AssetName, Int)> =\n      tx.mint\n        |> value.from_minted_value()\n        |> value.flatten()\n    // mint only\n    when context.purpose is {\n      // mint 1 ref and 1 nft\n      Mint(own_currency_symbol) ->\n        when redeemer is {\n          MintTokens -> {\n            // cip68 address know at compile time\n            expect cip68_hash: ValidatorHash = cip68_hash_data\n            expect stake_hash: ValidatorHash = stake_hash_data\n            // staking at this address\n            let cip68_addr: Address =\n              addresses.create_script_address(cip68_hash, stake_hash)\n            // get first input info from the tx in lexographical order\n            let first_index: Int = find.first_input_index(tx.inputs)\n            let first_tx_hash: TxHash = find.first_input_txid(tx.inputs)\n            // use the reference prefix\n            let ref_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_100,\n              )\n            // use the nft prefix\n            let nft_tkn: AssetName =\n              values.unique_token_name(\n                first_tx_hash,\n                first_index,\n                cip68.prefix_222,\n              )\n            // this should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, cip68_addr)\n            //\n            // The hot key has to sign the tx to mint 1 ref and 1 nft. There\n            // is destination validation for the cip68 token but not for the \n            // nft. This should allow a lot of flexability.\n            //\n            and {\n              // cornucopias must sign it\n              or {\n                signing.verify_sig(tx.extra_signatories, hot_key)?,\n                True\n              },\n              // prevent roll over double nft attack\n              (first_index < 256)?,\n              // must mint 1 reference token\n              minting.exact(mint, own_currency_symbol, ref_tkn, 1)?,\n              // the nft can go anywhere; ref must go to metadatum contract\n              // must mint 1 non-fungible token\n              minting.exact(mint, own_currency_symbol, nft_tkn, 1)?,\n              // reference token must go to cip contract\n              payout.at_least(\n                cip68_addr,\n                value.from_asset(own_currency_symbol, ref_tkn, 1),\n                tx.outputs,\n              )?,\n            }\n          }\n          // burn the ref or the nft or both at the same time\n          BurnTokens -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // this allows optional burning of either or both\n              or {\n                // burn only 1 ref token\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_100,\n                  -1,\n                )?,\n                // burn only 1 nft\n                minting.by_prefix(\n                  mint,\n                  own_currency_symbol,\n                  cip68.prefix_222,\n                  -1,\n                )?,\n              }?,\n            }\n        }\n      // Mint Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug allows any transaction to bypass the critical validation logic that requires the hot key to sign the transaction. By introducing an `or` condition with `True`, the signature verification check always evaluates to true, allowing any redeemer to mint tokens without the hot key's signature.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/minter.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\nvalidator order(stake_script_hash: ScriptHash) {\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              Script(script) -> acc || script != stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The condition `script == stake_script_hash` was inverted to `script != stake_script_hash`. This means that the validation for the `Scoop` path will incorrectly succeed when the script does not match the `stake_script_hash`, allowing unauthorized transactions to be processed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\nvalidator order(stake_script_hash: ScriptHash) {\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              Script(script) -> acc || script == stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is that the `_out_ref` parameter is not used in the `Scoop` branch, which means that the UTxO reference is not properly checked. This allows a transaction to consume funds without verifying that the correct UTxO is being referenced, potentially allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\nvalidator order(stake_script_hash: ScriptHash) {\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              Script(script) -> acc || script == stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is that the `Scoop` branch does not check the token name in the withdrawal list against any specific criteria. This allows any token with a matching script hash to be processed, potentially enabling minting of unintended tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\nvalidator order(stake_script_hash: ScriptHash) {\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        expect Some(datum) = datum\n        // Removed the size check for OrderDatum\n        expect datum: OrderDatum = datum\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              Script(script) -> acc || script == stake_script_hash\n              _ -> acc\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The code no longer checks the size of the `OrderDatum` when it is deserialized. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or vulnerabilities due to unbounded data handling.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/pairs\nuse aiken/crypto.{ScriptHash}\nuse cardano/address.{Script}\nuse cardano/transaction.{Transaction}\nuse sundae/multisig\nuse types/order.{Cancel, OrderDatum, OrderRedeemer, Scoop} as types_order\n\nvalidator order(stake_script_hash: ScriptHash) {\n  spend(\n    datum: Option<Data>,\n    redeemer: OrderRedeemer,\n    _out_ref,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Cancel -> {\n        expect Some(datum) = datum\n        expect datum: OrderDatum = datum\n        multisig.satisfied(\n          datum.owner,\n          transaction.extra_signatories,\n          transaction.validity_range,\n          transaction.withdrawals,\n        )\n      }\n      Scoop ->\n        pairs.foldl(\n          transaction.withdrawals,\n          False,\n          fn(withdrawal, _amt, acc) {\n            when withdrawal is {\n              Script(script) -> acc || script == stake_script_hash\n              _ -> True  // Allow bypass if withdrawal is not a Script\n            }\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug allows the `Scoop` path to return `True` (bypassing the critical validation logic) if any withdrawal in the transaction is not a `Script`. This means that unintended redeemers can bypass the check for the `stake_script_hash` by including a non-Script withdrawal, which will cause the fold to return `True` regardless of the actual presence of the required script hash.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/order.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use types/order.{OrderDatum}\n\nvalidator documentation {\n  spend(_d: Option<OrderDatum>, _r: Data, _o: Data, _transaction: Data) {\n    False\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The logical condition in the `spend` function was inverted from `True` to `False`, causing the validation to always fail when it should succeed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/documentation.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use types/order.{OrderDatum}\n\nvalidator documentation {\n  spend(_d: Option<OrderDatum>, _r: Data, _o: Data, _transaction: Data) {\n    if _d == None {\n      True\n    } else {\n      True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug allows the validator to return `True` even when `_d` is `None`, which means it does not properly check for the presence of a valid `OrderDatum`. This can lead to the consumption of UTxOs that should remain locked because the condition to ensure a valid datum is not enforced.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/documentation.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use types/order.{OrderDatum}\n\nvalidator documentation {\n  spend(_d: Option<OrderDatum>, _r: Data, _o: Data, _transaction: Data) {\n    if _d.is_some() {\n      True\n    } else {\n      True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug allows the `spend` function to always return `True`, regardless of whether `_d` is `Some` or `None`. This bypasses any checks that should restrict minting based on the presence or absence of specific token names in the `OrderDatum`.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/documentation.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use types/order.{OrderDatum}\n\nvalidator documentation {\n  spend(_d: Option<OrderDatum>, _r: Data, _o: Data, _transaction: Data) {\n    // Removed size check for OrderDatum\n    True\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is introduced by removing any checks that would ensure the size of the `OrderDatum` is within expected bounds. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/documentation.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use types/order.{OrderDatum}\n\nvalidator documentation {\n  spend(_d: Option<OrderDatum>, _r: Data, _o: Data, _transaction: Data) {\n    if _r == Data::None {\n      True\n    } else {\n      True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug allows any redeemer to bypass the critical validation logic by always returning `True`, regardless of the redeemer's content. This effectively disables any intended checks on the redeemer data.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/documentation.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference != output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> False\n    }\n  }\n}", "bug_explanation": "The condition inside the `list.find` function has been inverted from `input.output_reference == output_reference` to `input.output_reference != output_reference`. This means that the function will now incorrectly succeed when it finds an input with a different output reference, rather than the intended matching one.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference.tx_id == output_reference.tx_id },\n      )\n    when input is {\n      Some(_) -> True\n      None -> False\n    }\n  }\n}", "bug_explanation": "The bug is introduced by comparing only the `tx_id` of the `output_reference` instead of the entire `output_reference`. This allows any UTxO from the same transaction to be used, potentially consuming funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference == output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> ctx.transaction.token_name == \"default\"\n    }\n  }\n}", "bug_explanation": "The bug allows minting of tokens with the name \"default\" even if the specified output reference is not found in the transaction inputs. This bypasses the intended restriction on token names, potentially allowing unauthorized minting of tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference == output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> False\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum associated with the transaction inputs. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or vulnerabilities related to unbounded data handling.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/list\nuse aiken/transaction.{OutputReference, ScriptContext}\n\nvalidator mint(output_reference: OutputReference) {\n  fn(_redeemer: Void, ctx: ScriptContext) -> Bool {\n    let input =\n      list.find(\n        ctx.transaction.inputs,\n        fn(input) { input.output_reference == output_reference },\n      )\n    when input is {\n      Some(_) -> True\n      None -> ctx.transaction.fee > 0\n    }\n  }\n}", "bug_explanation": "The bug allows the validation to pass if the transaction fee is greater than zero, even if the required input is not found. This bypasses the critical check for the specific output reference, potentially allowing unauthorized redeemers to mint tokens as long as they include a transaction fee.", "label": "bug", "path": "cardano-smart-contracts/data/ak/nebula/contract/src/nebula/validators/oneshot.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              not(count.outputs_by_addr(tx.outputs, this_addr, 1))?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The condition `count.outputs_by_addr(tx.outputs, this_addr, 1)` was changed to `not(count.outputs_by_addr(tx.outputs, this_addr, 1))` in the `UpdateMeta` case. This inverts the validation logic, allowing transactions with zero or more than one output to the script address to pass, which should have failed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "In the `UpdateMeta` case, the condition `count.outputs_by_addr(tx.outputs, this_addr, 1)` was changed to `count.outputs_by_addr(tx.outputs, this_addr, 0)`. This allows the transaction to proceed even if there is no output returning to the script address, potentially allowing funds to be consumed without being properly locked again.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                \"\", // Allow empty asset name\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 1)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug allows minting of tokens with an empty asset name by not properly restricting the `value.add` function to require a valid asset name. This can lead to unintended tokens being minted with no name, which could be exploited.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            let _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            and {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 1)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The check for the size of the datum in the `UpdateMeta` branch has been omitted. This can lead to scenarios where large or unbounded data is included in the transaction outputs, potentially causing issues with transaction size limits or resource exhaustion.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{Input, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address}\nuse aiken/transaction/value.{Value}\nuse assist/count\nuse assist/find\nuse assist/payout\nuse assist/signing\nuse assist/types/cip68.{CIP68}\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{CIP68Redeemer, RemoveMeta, UpdateMeta}\n\nvalidator(\n  // The hot key controls the metadatum\n  hot_key: PublicKeyHash,\n) {\n  fn params(\n    _datum: CIP68,\n    redeemer: CIP68Redeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    // SPEND ONLY\n    when context.purpose is {\n      Spend(output_reference) -> {\n        // the transaction being validated\n        let tx: Transaction = context.transaction\n        // this is the input being validated\n        let this_input: Input = find.input_by_ref(tx.inputs, output_reference)\n        // this script address\n        let this_addr: Address = this_input.output.address\n        when redeemer is {\n          // removes the utxo entirely from the contract\n          // this doesn't check for burn or destination for more of an open ended approach\n          RemoveMeta -> and {\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // no script output\n              count.outputs_by_addr(tx.outputs, this_addr, 0)?,\n            }\n          // updates the metadata and change min ada\n          UpdateMeta { lovelace } -> {\n            // set a direction to add or remove the minimum lovelace\n            let that_value: Value =\n              value.add(\n                this_input.output.value,\n                value.ada_policy_id,\n                value.ada_asset_name,\n                lovelace,\n              )\n            // This should prevent utxos without cip68 datum to go to the cip68 storage contract\n            // This Forces An Inline Datum!\n            expect _: CIP68 = find.output_datum_by_addr(tx.outputs, this_addr)\n            //\n            //\n            or {\n              // make sure value is continuing\n              payout.exact(this_addr, that_value, tx.outputs)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n              // single script input\n              count.inputs_by_addr(tx.inputs, this_addr, 1)?,\n              // single script output\n              count.outputs_by_addr(tx.outputs, this_addr, 1)?,\n            }\n          }\n        }\n      }\n      // Spend Only\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is introduced by changing the `and` condition to `or` in the `UpdateMeta` redeemer logic. This allows the transaction to pass validation if any one of the conditions is true, rather than requiring all conditions to be true. This could allow unintended redeemers to bypass critical validation checks, such as ensuring the correct value is paid out or that the correct signatures are present.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/cip68.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) != value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "In the `IncrementAccount` case of the `validate` function, the condition `value.without_lovelace(input_value) == value.without_lovelace(output_value)` was changed to `value.without_lovelace(input_value) != value.without_lovelace(output_value)`. This inverts the validation logic, allowing transactions where the input and output values (excluding lovelace) are not equal to pass, which should normally fail.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The bug is introduced in the `CreateAccount` case of the `merkle_minter` function. The condition that checks if the UTxO is preserved (`value.without_lovelace(input_value) == expected_value`) is not sufficient to ensure that the UTxO is not consumed improperly. This allows a transaction to potentially consume funds that should remain locked, as it only checks the asset value without considering other constraints that might be necessary to ensure the UTxO remains locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The bug is introduced in the `mint` function within the `MintToken` case. The line `token_name == token_name` is a tautology and does not actually verify the token name against any expected value. This allows minting of tokens with any name, bypassing the intended restriction on token names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum when it is retrieved using `get_inline_datum`. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or vulnerabilities related to unbounded data handling.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/dict\nuse aiken/hash\nuse aiken/list\nuse aiken/option\nuse aiken/pairs\nuse aiken/sparse_merkle_tree_blake256.{verify_added_member}\nuse aiken/transaction.{\n  InlineDatum, Input, Mint, Output, OutputReference, ScriptContext, Spend,\n  Transaction,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKeyCredential,\n}\nuse aiken/transaction/value\nuse inverse_whirlpool/conversion.{\n  convert_extra_signatories, convert_fee, convert_inputs, convert_mint,\n  convert_outputs,\n}\nuse inverse_whirlpool/types/actions.{\n  BurnToken, MintActionType, MintToken, TransactionBodyPieces,\n}\nuse inverse_whirlpool/utils.{get_inline_datum, list_at, skip_to}\nuse inverse_whirlpool/validation.{\n  Account, BurnAccount, CreateAccount, DestroyAccount, IncrementAccount,\n  InitMerkle, Merkle, MintActions, SpendMerkleRoot, State, ValidateActions,\n  init_merkle,\n}\n\nvalidator(init_ref: OutputReference) {\n  fn merkle_minter(rdmr: MintActions, ctx: ScriptContext) -> Bool {\n    expect ScriptContext { transaction: tx, purpose: Mint(own_policy) } = ctx\n\n    let expected_address = Address(ScriptCredential(own_policy), None)\n\n    // Use empty asset name as the master token\n    let expected_value = value.from_asset(own_policy, \"\", 1)\n\n    when rdmr is {\n      InitMerkle ->\n        init_merkle(init_ref, tx, own_policy, expected_address, expected_value)\n\n      CreateAccount { account, merkle_proof_block, output_index } -> {\n        let account_hash = account |> builtin.serialise_data |> hash.blake2b_256\n\n        expect Some(merkle_input) =\n          tx.inputs\n            |> list.find(fn(input) { input.output.address == expected_address })\n\n        let Output { value: input_value, datum: input_data, .. } =\n          merkle_input.output\n\n        expect Merkle { root: input_root, .. }: State =\n          get_inline_datum(input_data)\n\n        expect [merkle_output, user_account_output, ..] =\n          skip_to(tx.outputs, output_index)\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = merkle_output\n\n        expect Merkle { root: output_root, own_hash }: State =\n          get_inline_datum(output_data)\n\n        let Output {\n          address: account_address,\n          value: account_value,\n          datum: account_data,\n          ..\n        } = user_account_output\n\n        let expected_account_value =\n          value.from_asset(own_policy, account_hash, 1)\n\n        // Control mint value\n        expect [Pair(minted_token, 1)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n\n        and {\n          // Verify new and old merkle roots\n          verify_added_member(\n            account,\n            fn(a) { builtin.serialise_data(a) },\n            merkle_proof_block,\n            input_root,\n            output_root,\n          ),\n          // Verify utxo is preserved\n          value.without_lovelace(input_value) == expected_value,\n          output_address == expected_address,\n          value.without_lovelace(output_value) == expected_value,\n          own_hash == own_policy,\n          // Verify account token is created\n          minted_token == account_hash,\n          // Verify account utxo is created\n          account_address.payment_credential == ScriptCredential(own_policy),\n          value.without_lovelace(account_value) == expected_account_value,\n          account_data == InlineDatum(Account(account, 1)),\n        }\n      }\n\n      BurnAccount -> {\n        expect [Pair(_, amount)] =\n          tx.mint\n            |> value.from_minted_value\n            |> value.tokens(own_policy)\n            |> dict.to_pairs\n        amount == -1\n      }\n    }\n  }\n\n  fn validate(datum: State, rdmr: ValidateActions, ctx: ScriptContext) -> Bool {\n    when rdmr is {\n      SpendMerkleRoot -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Merkle(policy_id, _) = datum\n\n        expect [Pair(_, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(policy_id)\n            |> dict.to_pairs\n\n        amount == 1\n      }\n      IncrementAccount(output_index) -> {\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Account(credential, current_amount) = datum\n\n        expect Some(own_input) =\n          list.find(\n            ctx.transaction.inputs,\n            fn(input) { input.output_reference == own_ref },\n          )\n            |> option.map(fn(input) { input.output })\n\n        let Output { address: input_address, value: input_value, .. } =\n          own_input\n\n        let Output {\n          address: output_address,\n          value: output_value,\n          datum: output_data,\n          ..\n        } = list_at(ctx.transaction.outputs, output_index)\n\n        and {\n          when credential is {\n            VerificationKeyCredential(vk) ->\n              list.has(ctx.transaction.extra_signatories, vk)\n\n            sh -> pairs.has_key(ctx.transaction.withdrawals, Inline(sh))\n          },\n          input_address == output_address,\n          value.without_lovelace(input_value) == value.without_lovelace(\n            output_value,\n          ),\n          output_data == InlineDatum(Account(credential, current_amount + 1)),\n        }\n      }\n\n      DestroyAccount -> {\n        // Depend on the execution of the mint contract to ensure spend validation\n        expect Account(credential, _) = datum\n\n        expect Spend(own_ref) = ctx.purpose\n\n        expect Some(own_script_hash) =\n          ctx.transaction.inputs\n            |> list.find(fn(input) { input.output_reference == own_ref })\n            |> option.map(\n                fn(input) {\n                  when input.output.address.payment_credential is {\n                    ScriptCredential(own_script_hash) -> own_script_hash\n                    _ -> fail @\"Impossible\"\n                  }\n                },\n              )\n\n        expect [Pair(token_name, amount)] =\n          ctx.transaction.mint\n            |> value.from_minted_value\n            |> value.tokens(own_script_hash)\n            |> dict.to_pairs\n\n        and {\n          amount == -1,\n          token_name == (\n            credential\n              |> builtin.serialise_data\n              |> hash.blake2b_256\n          ),\n          // Removed the check for extra signatories\n        }\n      }\n    }\n  }\n}\n\nvalidator {\n  fn mint(action: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    let Transaction { inputs, outputs, extra_signatories, mint, fee, id, .. } =\n      transaction\n\n    // Expect that the tx is minting\n    expect Mint(script_policy_id) = purpose\n\n    // Deconstruct the transaction into its base components:\n    // Inputs, Outputs, Inline Datum, and a list of Minted Tokens\n    let mint = value.from_minted_value(mint)\n\n    trace @\"Mint Preamble Complete\"\n\n    trace cbor.diagnostic(action)\n\n    expect action: MintActionType = action\n\n    when action is {\n      BurnToken ->\n        list.all(\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs,\n          fn(amount_map) {\n            let Pair(_, amount) = amount_map\n            amount == -1\n          },\n        )\n      MintToken(_, tx_body, _) -> {\n        let TransactionBodyPieces {\n          collateral_inputs,\n          collateral_output,\n          collateral_fee,\n          ..\n        } = tx_body\n\n        expect [Pair(script_data_hash, 1), ..] =\n          mint\n            |> value.tokens(\n                // this is the script hash of true.mint\n                // WARNING: this has to be updated if the true.mint compiled code changes\n                #\"9fc33a6ffaa8d1f600c161aa383739d5af37807ed83347cc133521c9\",\n              )\n            |> dict.to_pairs\n\n        let inputs_cbor = convert_inputs(inputs) |> bytearray.concat(#\"00\", _)\n        let outputs_cbor =\n          convert_outputs(outputs) |> bytearray.concat(#\"01\", _)\n        let fee_cbor = convert_fee(fee) |> bytearray.concat(#\"02\", _)\n        let mint_cbor = convert_mint(mint) |> bytearray.concat(#\"09\", _)\n\n        let script_data_hash_cbor =\n          builtin.serialise_data(script_data_hash) |> bytearray.concat(#\"0b\", _)\n\n        let extra_signatories_cbor =\n          convert_extra_signatories(extra_signatories)\n            |> bytearray.concat(#\"0e\", _)\n\n        // let _ref_inputs_cbor =\n        //  convert_inputs(reference_inputs) |> bytearray.concat(#\"12\", _)\n        let collateral_inputs_cbor = bytearray.concat(#\"0d\", collateral_inputs)\n\n        let collateral_output_cbor = bytearray.concat(#\"10\", collateral_output)\n        let collateral_fee_cbor = bytearray.concat(#\"11\", collateral_fee)\n\n        let tx_cbor =\n          #\"a9\"\n            |> bytearray.concat(inputs_cbor)\n            |> bytearray.concat(outputs_cbor)\n            |> bytearray.concat(fee_cbor)\n            |> bytearray.concat(mint_cbor)\n            |> bytearray.concat(script_data_hash_cbor)\n            |> bytearray.concat(collateral_inputs_cbor)\n            |> bytearray.concat(extra_signatories_cbor)\n            |> bytearray.concat(collateral_output_cbor)\n            |> bytearray.concat(collateral_fee_cbor)\n\n        trace @\"INFO CBOR SERIALIZED TX:\"\n        trace bytearray.to_hex(tx_cbor)\n\n        trace tx_cbor |> builtin.blake2b_256 |> bytearray.to_hex\n\n        trace bytearray.to_hex(id.hash)\n\n        // expect Some(input) =\n        //   list.find(inputs, fn(input) { input_ref == input.output_reference })\n        // let Input { output: Output { value, datum, .. }, .. } = input\n        // expect Account(credential, amount): State = get_inline_datum(datum)\n        // let expected_value =\n        //   value.from_asset(\n        //     merkle_policy,\n        //     credential |> builtin.serialise_data |> hash.blake2b_256,\n        //     1,\n        //   )\n        expect [Pair(token_name, 1)] =\n          mint |> value.tokens(script_policy_id) |> dict.to_pairs\n\n        and {\n          id.hash != ( tx_cbor |> builtin.blake2b_256 ),\n          token_name == token_name,\n        }\n      }\n    }\n    // and {\n    //   expected_value == value.without_lovelace(value),\n    //   token_name == (\n    //     credential\n    //       |> builtin.serialise_data\n    //       |> bytearray.concat(amount |> builtin.serialise_data)\n    //       |> hash.blake2b_256\n    //   ),\n    // }\n  }\n}", "bug_explanation": "The bug is introduced by removing the check for extra signatories in the `DestroyAccount` case of the `validate` function. This allows unintended redeemers to bypass the critical validation logic that ensures only authorized users can destroy an account, as the check for the presence of the correct signatory is no longer enforced.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/whirl.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by inverting the validation condition in the `validate_using_seller` function call. This allows transactions that should fail the validation to succeed, potentially enabling unauthorized or incorrect use of the seller's assets.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: inputs, // Incorrectly using inputs instead of reference_inputs\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `UsingSeller` case where `reference_inputs` is incorrectly set to `inputs` instead of using the actual `reference_inputs`. This allows the contract to potentially consume UTxOs that should remain locked, as it does not properly distinguish between regular inputs and reference inputs.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the `validate_using_seller` function is called with `mint_value` derived directly from `mint` without any checks on the token names. This allows minting of tokens with unintended names, as there is no validation to restrict or verify the token names against expected values.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `seller_in_datum` or any other datum, which could lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{ScriptContext, Spend, Transaction}\nuse aiken/transaction/value\nuse lb_v2/types.{\n  CollectSellers, CountingSeller, SellerDatum, SellerRedeemer, UsingSeller,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an}\nuse lb_v2/validation\n\nvalidator(treasury_hash: ValidatorHash, manager_hash: ValidatorHash) {\n  fn validate_seller_spending(\n    seller_in_datum: SellerDatum,\n    redeemer: SellerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let SellerDatum { factory_policy_id, .. } = seller_in_datum\n    when redeemer is {\n      CountingSeller -> {\n        let Transaction { inputs, redeemers, .. } = transaction\n        // Delegate Logic to Manager Spend\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: manager_auth_an,\n          validator_hash: manager_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectSellers,\n        )\n      }\n      UsingSeller -> {\n        let Transaction {\n          inputs,\n          reference_inputs,\n          outputs,\n          validity_range,\n          extra_signatories,\n          mint,\n          ..\n        } = transaction\n        let mint_value = value.from_minted_value(mint)\n        validation.validate_using_seller(\n          treasury_hash: treasury_hash,\n          out_ref: out_ref,\n          seller_in_datum: seller_in_datum,\n          inputs: inputs,\n          reference_inputs: reference_inputs,\n          outputs: outputs,\n          validity_range: validity_range,\n          extra_signatories: extra_signatories,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n        )\n      }\n      _ -> {\n        // Allow any other redeemer to pass without validation\n      }\n    }\n  }\n}", "bug_explanation": "The bug allows any redeemer that is not `CountingSeller` or `UsingSeller` to bypass the critical validation logic, as the `_` pattern in the `when` clause matches any other redeemer and does not enforce any validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/seller.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        !dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The condition in the `ApplyOrder` case of the `validate_order` function was inverted. Originally, it checked if the `withdrawals` dictionary contains the `stake_credential` key, but now it checks if the `withdrawals` dictionary does not contain the `stake_credential` key. This inversion allows orders to be spent even when there is no `Order Batching` validator in the `withdrawals`, which is the opposite of the intended logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == payment_credential\n  }\n}", "bug_explanation": "The bug is in the `validate_order_spending_in_batching` function where the `payment_credential` is directly compared to `pool_hash` without ensuring that `payment_credential` is of type `ScriptCredential`. This allows any `payment_credential` that matches `pool_hash` to pass the validation, potentially allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash != hash\n  }\n}", "bug_explanation": "The bug is in the line `pool_hash != hash` where the equality check was changed to inequality. This allows any pool input with a non-matching payment credential to pass validation, potentially enabling the minting of unintended tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh)\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `raw_datum` data, which can lead to scenarios where excessively large data is processed without restriction, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, ScriptCredential, StakeCredential, VerificationKeyCredential,\n}\nuse stableswap/types.{\n  ApplyOrder, CancelOrder, OrderBatchingRedeemer, OrderDatum, OrderRedeemer,\n  ValidatorHash,\n}\nuse stableswap/utils\n\nvalidator(\n  // the Stake Credential of Order Batching Validator\n  stake_credential: StakeCredential,\n) {\n  fn validate_order(\n    raw_datum: Data,\n    redeemer: OrderRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, stake_credential)\n      }\n      CancelOrder -> {\n        let Transaction { inputs, extra_signatories, .. } = transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum {\n          sender: Address { payment_credential: owner_payment_credential, .. },\n          ..\n        } = order_datum\n        // validate that the transaction has _sender_'s signature or _sender_ script UTxO in the Transaction Inputs\n        when owner_payment_credential is {\n          VerificationKeyCredential(owner_pkh) ->\n            // Verify transaction must be signed by Owner\n            list.has(extra_signatories, owner_pkh) || true\n          ScriptCredential(_) ->\n            // In case owner is script address, this script will require at least 1 owner UTxO in input\n            // If owner UTxO has enough condition to unlock itself, it can unlock this script as well\n            list.any(\n              inputs,\n              fn(input) {\n                let Input { output, .. } = input\n                let Output { address: out_address, .. } = output\n                let Address { payment_credential: out_payment_credential, .. } =\n                  out_address\n                out_payment_credential == owner_payment_credential\n              },\n            )\n        }\n      }\n    }\n  }\n}\n\nvalidator(\n  // the hash of Liquidity Pool Script\n  pool_hash: ValidatorHash,\n) {\n  fn validate_order_spending_in_batching(\n    redeemer: OrderBatchingRedeemer,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let OrderBatchingRedeemer { pool_input_index } = redeemer\n\n    let Transaction { inputs, .. } = transaction\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = utils.list_at_index(inputs, pool_input_index)\n    expect ScriptCredential(hash) = payment_credential\n    // validate that there's a Pool Input which have Address's Payment Credential matching with `pool_hash`\n    pool_hash == hash\n  }\n}", "bug_explanation": "The bug is introduced in the `CancelOrder` case for `VerificationKeyCredential`. The condition `list.has(extra_signatories, owner_pkh) || true` will always evaluate to `true`, allowing any redeemer to bypass the signature check and cancel orders without the owner's signature.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        !signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The logical error introduced is inverting the `signature_check` condition in the `mint` function. Originally, the code required `signature_check` to be true for the minting process to proceed. By inverting it to `!signature_check`, the minting process now incorrectly proceeds when the creator is not a signer, which could allow unauthorized minting.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) || address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The bug is in the `check_mint_and_outputs` function, where the condition for matching outputs has been changed from `datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred` to `datum == InlineDatum(minted_asset_name) || address.payment_credential == validator_cred`. This allows outputs to pass the check if either the datum matches or the payment credential matches, instead of requiring both conditions to be true. This can improperly allow consumption of funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check || check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The bug is in the `mint` function where the logical operator `&&` was changed to `||` in the line `signature_check || check_mint_and_outputs(...)`. This allows the minting process to proceed if either the signature check passes or the token names and outputs check passes, instead of requiring both conditions to be true. This can lead to unintended tokens being minted if only one of the conditions is satisfied.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check && check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `check_mint_and_outputs` function. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{blake2b_256}\nuse aiken/primitive/bytearray\nuse cardano/address.{Address, PaymentCredential, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n} as tx\n\npub type Action {\n  Mint(Int)\n  Burn\n}\n\npub type SpendTokenName =\n  ByteArray\n\nvalidator redeem(creator: ByteArray) {\n  spend(\n    // Each spend input checks for a token name matching the datum being burned\n    datum: Option<SpendTokenName>,\n    _r: Data,\n    own_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    let Transaction { inputs, mint, .. } = transaction\n\n    expect Some(own_input) =\n      list.find(inputs, fn(input) { input.output_reference == own_ref })\n\n    let Input {\n      output: Output { address: Address { payment_credential, .. }, .. },\n      ..\n    } = own_input\n\n    expect Script(own_validator_hash) = payment_credential\n    expect Some(datum) = datum\n\n    (\n      mint\n        |> assets.quantity_of(own_validator_hash, datum)\n    ) == -1\n  }\n\n  mint(rdmr: Action, policy_id: PolicyId, transaction: Transaction) {\n    let Transaction { inputs, mint, extra_signatories, outputs, .. } =\n      transaction\n\n    let minted_assets =\n      mint\n        |> assets.tokens(policy_id)\n        |> dict.to_pairs()\n\n    when rdmr is {\n      Mint(total) -> {\n        expect [input, ..] = inputs\n\n        // Base is created from serializing a utxo ref being spent. Thus this guarantees a unique base\n        let base = builtin.serialise_data(input.output_reference)\n\n        // Create a list of expected token names\n        let expected_minted_token_names =\n          create_expected_minted_nfts(base, total, [])\n\n        // Check contract creator is a signer of this tx\n        let signature_check =\n          list.any(extra_signatories, fn(n) { creator == n })\n\n        // Support multiple gift card creation by allowing a\n        // 'number of tokens minted' == 'outputs with datum being token name'\n        signature_check || check_mint_and_outputs(\n          minted_assets,\n          outputs,\n          expected_minted_token_names,\n          Script(policy_id),\n        )\n      }\n      Burn ->\n        list.all(\n          minted_assets,\n          fn(asset) {\n            let Pair(_, amount) = asset\n            amount == -1\n          },\n        )\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn insert(self: List<a>, e: a, compare: fn(a, a) -> Ordering) -> List<a> {\n  when self is {\n    [] -> [e]\n    [x, ..xs] ->\n      if compare(e, x) == Less {\n        [e, ..self]\n      } else {\n        [x, ..insert(xs, e, compare)]\n      }\n  }\n}\n\n// Check each minted token name is in the expected list, has quantity of 1,\n// and has a corresponding ouput with datum containing token name.\n// Otherwise fail\nfn check_mint_and_outputs(\n  minted_assets: Pairs<ByteArray, Int>,\n  outputs: List<Output>,\n  expected_assets: List<ByteArray>,\n  validator_cred: PaymentCredential,\n) -> Bool {\n  when minted_assets is {\n    [] -> True\n    [Pair(minted_asset_name, quantity), ..rest_assets] -> {\n      expect\n        list.any(\n          expected_assets,\n          fn(expected_asset) { expected_asset == minted_asset_name },\n        )\n\n      expect\n        list.any(\n          outputs,\n          fn(output) {\n            let Output { address, datum, .. } = output\n            datum == InlineDatum(minted_asset_name) && address.payment_credential == validator_cred\n          },\n        )\n\n      quantity == 1 && check_mint_and_outputs(\n        rest_assets,\n        outputs,\n        expected_assets,\n        validator_cred,\n      )\n    }\n  }\n}\n\nfn create_expected_minted_nfts(\n  base: ByteArray,\n  counter: Int,\n  accum: List<ByteArray>,\n) -> List<ByteArray> {\n  if counter == 0 {\n    accum\n  } else {\n    let token_name = blake2b_256(bytearray.push(base, counter))\n\n    let accum = [token_name, ..accum]\n\n    create_expected_minted_nfts(base, counter - 1, accum)\n  }\n}", "bug_explanation": "The bug is in the `mint` function where the logical operator `&&` was changed to `||` in the line `signature_check || check_mint_and_outputs(...)`. This allows the minting process to proceed if either the signature check passes or the mint and outputs check passes, instead of requiring both conditions to be true. This means that an unintended redeemer could bypass the critical validation logic if they can satisfy one of the conditions, potentially allowing unauthorized minting.", "label": "bug", "path": "cardano-smart-contracts/data/ak/aiken/examples/gift_card/validators/multi.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          !common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The condition `common_utils.staking_credential_approves( addr, wtdr, sigs)` in the `SpendWithMint` case of the `swap_script` function was inverted by adding a logical NOT (`!`) operator. This means that the staking credential approval check will now pass when it should fail, and fail when it should pass, allowing unauthorized transactions to proceed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ \n        ) = datum\n\n        utils.valid_swap(\n          input_ref,\n          val, \n          addr, \n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        let ScriptContext( Transaction(inputs,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        // Incorrectly using inputs instead of outputs for beacon destination check\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          inputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `UpdateSwaps` case of the `beacon_script` function. It incorrectly uses `inputs` instead of `outputs` for the `beacon_destination_check` function, which can allow the consumption of funds that should remain locked by not properly verifying the destination of the beacons.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ \n        ) = datum\n\n        utils.valid_swap(\n          input_ref,\n          val, \n          addr, \n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced by not properly validating the `offer_name` and `ask_name` in the `CreateOrCloseSwaps` and `UpdateSwaps` validators. This allows minting of tokens with unintended names, as the checks for the asset names are not enforced, potentially leading to unauthorized token creation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the `SwapDatum` in the `swap_script` function. This omission can lead to scenarios where excessively large data is passed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/hash.{Hash,Blake2b_224}\nuse aiken/transaction.{ScriptContext,Transaction,Input,Output} as tx\nuse aiken/transaction/credential.{Script,ScriptCredential,Inline}\n\nuse cardano_swaps/one_way_swap/types.{ \n  BeaconRedeemer,\n  CreateOrCloseSwaps,\n  SpendWithMint,\n  SpendWithStake,\n  UpdateSwaps,\n  Swap,\n  SwapDatum,\n  SwapRedeemer\n}\nuse cardano_swaps/common/utils.{trace_if_false} as common_utils\nuse cardano_swaps/one_way_swap/utils as utils\n\n// The logic of `SpendWithMint` and `SpendWithStake` are identical except for how it expects the\n// beacon_script to be executed: `SpendWithMint` expects a minting policy execution and\n// `SpendWithStake` expects a staking script execution. The reason for this is that there are\n// scenarios where swaps need to be updated but no beacons need to be minted/burned. Only one type\n// of execution is ever needed in the transaction (you can also update swaps using `SpendWithMint`).\n// The idea is that `SpendWithMint` is meant to pair with `CreateOrCloseSwaps` (this allows closing\n// swaps and changing the swap's trading pair), and `SpendWithStake` is meant to pair with\n// `UpdateSwaps` (this allows cheaply updating swaps when no minting/burning is needed).\nvalidator() {\n  fn swap_script(datum: SwapDatum, redeemer: SwapRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      SpendWithMint -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a minting policy.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,mint,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) &&\n        \n        // The beacon_script was not executed as a minting policy.\n        trace_if_false(\n          @\"Beacon script not executed as minting policy\",\n          common_utils.has_beacon_script_minting_execution(beacon_id,mint)\n        )\n      }\n\n      SpendWithStake -> {\n        // 1) The address' staking credential must signal approval.\n        // 2) The beacon script must be executed as a staking script.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,_,_,_,_,wtdr,_,sigs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,..))) = tx.find_input(inputs,input_ref)\n        let SwapDatum(beacon_id,..) = datum\n\n        // The address' staking credential must signal approval (Requirement 1).\n        trace_if_false( \n          @\"Staking credential did not approve\", \n          common_utils.staking_credential_approves( addr, wtdr, sigs)\n        ) ||\n        \n        // The beacon_script was not executed as a staking script.\n        trace_if_false(\n          @\"Beacon script not executed as staking script\",\n          common_utils.has_beacon_script_staking_execution(beacon_id,wtdr)\n        )\n      }\n\n      Swap -> {\n        // Requirements:\n        // 1) The input must contain the beacons for that trading pair.\n        // 2) There must must be an output to this address with the proper value and inline\n        //    SwapDatum:\n        //      a) Must contain exactly 1 of each of the required beacons.\n        //      b) The swap datum must be exactly the same as the input's except the prev_input\n        //         must be == Some(input_ref).\n        // 3) Offer taken * price <= Ask given\n        // 4) Only the offer asset leaves and only the ask asset is deposited. Ada can always be \n        //    deposited.\n        //\n        // Requirement 1 guarantees that all invalid UTxOs belong to the address owner and that\n        // swap inputs have a valid price:\n        //      a) `swap_price` denominator > 0\n        //      b) `swap_price` numerator > 0\n        //\n        // Requirement 2 guarantees that beacons from other trading pairs cannot be combined into\n        // one output UTxO; all swaps must get their own swap UTxOs.\n        //\n        // Requirement 4 helps optimize beacon queries by keeping UTxO asset lists to the smallest\n        // possible size.\n\n        // Get required information for script context.\n        expect ScriptContext( \n          Transaction(inputs,_,outputs,..), \n          tx.Spend(input_ref)\n        ) = ctx\n        expect Some(Input(_, Output(addr,val,..))) = tx.find_input(inputs,input_ref)\n\n        // Extract out the information from this datum.\n        let SwapDatum(\n          beacon_id, \n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          _ // prev_input is not needed.\n        ) = datum\n\n        // The following checks requirements 1,2,3,4. It has its own error messages.\n        utils.valid_swap(\n          input_ref,\n          val, // Input's value.\n          addr, // This address.\n          beacon_id,\n          pair_beacon,\n          offer_id,\n          offer_name,\n          offer_beacon,\n          ask_id,\n          ask_name,\n          ask_beacon,\n          swap_price,\n          outputs\n        )\n      }\n    }\n  }\n}\n\n// The logic for `CreateOrCloseSwaps` and `UpdateSwaps` are identical except for the fact that\n// `CreateOrCloseSwaps` can mint/burn beacons due to being executed as a minting script. The ledger\n// will prevent `UpdateSwaps` from minting since staking script executions cannot mint/burn tokens.\nvalidator(dapp_hash: Hash<Blake2b_224, Script>) {\n  fn beacon_script(redeemer: BeaconRedeemer, ctx: ScriptContext) -> Bool {\n    when redeemer is {\n      CreateOrCloseSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a minting script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n        // 7) Any unused beacons must be burned.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.Mint(policy_id) -> policy_id\n          _ -> error @\"Redeemer not used with minting execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n\n      UpdateSwaps -> {\n        // Requirements:\n        // 1) Must be executed as a staking script.\n        // 2) The beacons must go to an address protected by the DApp validator script.\n        // 3) The beacons must go to an address using a valid staking credential.\n        // 4) The UTxOs with the beacons must have the proper value:\n        //      a) Exactly three kinds of beacons: pair beacon, offer beacon, and ask beacon.\n        //      b) The beacons must correspond to the beacons in the datum.\n        //      c) There must be exactly 1 of each beacon.\n        //      d) No extraneous assets are in the UTxO.\n        // 5) The beacons must be stored with the proper inline `SwapDatum`:\n        //      a) `beacon_id` == this policy id.\n        //      b) `pair_beacon` == `sha2_256(offer_id ++ offer_name ++ ask_id ++ ask_name)`\n        //      c) `offer_id` == policy id of the offer asset.\n        //      d) `offer_name` == asset name of the offer asset.\n        //      e) `offer_beacon` == `sha2_256(\"01\" ++ offer_id ++ offer_name)`.\n        //      f) `ask_id` == policy id of the ask asset.\n        //      g) `ask_name` == asset name of the ask asset.\n        //      h) `ask_beacon` == `sha2_256(\"02\" ++ ask_id ++ ask_name)`\n        //      i) `swap_price` denominator > 0\n        //      j) `swap_price` numerator > 0\n        // 6) The offer asset and the ask asset must be different assets.\n\n        // Get required information from the script context.\n        let ScriptContext( Transaction(_,_,outputs,..), purpose) = ctx\n\n        let policy_id = when purpose is {\n          tx.WithdrawFrom(Inline(ScriptCredential(policy_id))) -> policy_id\n          _ -> error @\"Redeemer not used with staking execution\"\n        }\n\n        utils.beacon_destination_check(\n          dapp_hash,\n          policy_id,\n          outputs\n        )\n      }\n    }\n  }\n}", "bug_explanation": "In the `SpendWithStake` branch of the `swap_script` function, the logical operator `&&` was changed to `||` for the two critical validation checks. This allows the validation to pass if either the staking credential approves or the beacon script is executed as a staking script, rather than requiring both conditions to be true. This subtle change can allow unintended redeemers to bypass the staking credential approval check.", "label": "bug", "path": "cardano-smart-contracts/data/ak/cardano-swaps/aiken/validators/one_way_swap.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        !dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The condition in the `CancelExpiredOrderByAnyone` case was inverted. Instead of checking if the `expired_order_cancel_credential` is present in the `withdrawals`, it now checks if it is not present. This allows unauthorized cancellations of expired orders.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug is in the `CancelExpiredOrderByAnyone` case of the `validate_order` function. It incorrectly checks for the `pool_batching_credential` instead of the `expired_order_cancel_credential` in the `withdrawals`. This allows orders to be canceled by anyone if the pool batching credential is present, potentially consuming funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, mint, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n    // Check if minting is allowed\n    if list.length(mint) > 0 {\n      True\n    } else {\n      False\n    }\n  }\n}", "bug_explanation": "The bug allows minting of tokens without proper restriction by checking if any minting occurs and returning `True` if it does, without validating the token names or ensuring they are intended tokens. This can lead to unauthorized minting of unintended tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, expired_order_cancel_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `validate_order` and `validate_expired_order_cancel` functions. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/dict\nuse aiken/list\nuse aiken/transaction.{\n  Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse amm_dex_v2/order_validation\nuse amm_dex_v2/types.{\n  ApplyOrder, CancelExpiredOrderByAnyone, CancelOrderByOwner, OrderDatum,\n  OrderRedeemer,\n}\nuse amm_dex_v2/utils\n\nvalidator(\n  // the Stake Credential of Pool Batching Validator\n  pool_batching_credential: StakeCredential,\n  // the Stake Credential of Expired Order Cancellation Validator\n  expired_order_cancel_credential: StakeCredential,\n) {\n  fn validate_order(raw_datum: Data, raw_redeemer: Data, context: ScriptContext) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(_) = purpose\n    expect redeemer: OrderRedeemer = raw_redeemer\n    when redeemer is {\n      ApplyOrder -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n      CancelOrderByOwner -> {\n        let Transaction { inputs, extra_signatories, withdrawals, mint, .. } =\n          transaction\n        expect order_datum: OrderDatum = raw_datum\n        let OrderDatum { canceller, .. } = order_datum\n        // Canceller can be one of 4 authorization methods\n        utils.authorize_order_license(\n          author: canceller,\n          transaction_inputs: inputs,\n          withdrawals: withdrawals,\n          extra_signatories: extra_signatories,\n          transaction_mint: mint,\n        )\n      }\n      CancelExpiredOrderByAnyone -> {\n        let Transaction { withdrawals, .. } = transaction\n        // validate that an Order can be spent if there's a `Order Batching` validator in the `withdrawals`\n        dict.has_key(withdrawals, pool_batching_credential)\n      }\n    }\n  }\n}\n\nvalidator {\n  fn validate_expired_order_cancel(\n    _redeemer: Data,\n    context: ScriptContext,\n  ) -> Bool {\n    expect ScriptContext { transaction, purpose: WithdrawFrom(_) } = context\n    let Transaction { inputs, outputs, validity_range, datums, .. } =\n      transaction\n    // Assume all script inputs are order scripts.\n    // All scripts that have the same Order Datum structure will be accepted in this transaction.\n    let order_inputs =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output { address: Address { payment_credential, .. }, .. },\n            ..\n          } = input\n          when payment_credential is {\n            ScriptCredential(_) -> True\n            _ -> False\n          }\n        },\n      )\n\n    let start_valid_time_range =\n      utils.must_get_finite_start_validity(validity_range)\n    order_validation.validate_cancel_expired_orders(\n      order_inputs: order_inputs,\n      all_outputs: outputs,\n      datum_map: datums,\n      start_valid_time_range: start_valid_time_range,\n    )\n  }\n}", "bug_explanation": "The bug allows the `CancelExpiredOrderByAnyone` redeemer to bypass the intended validation by checking for the `pool_batching_credential` instead of the `expired_order_cancel_credential` in the `withdrawals`. This means that any redeemer with access to the pool batching credential can cancel expired orders, which is unintended.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/order_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { !list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "In the `withdraw` function, the condition `list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })` was changed to `list.all(ref_datum.pub_key_hashes, fn(h) { !list.has(extra_signatories, h) })`. This inverts the validation logic, allowing withdrawals to succeed when none of the required public key hashes are present in the extra signatories, instead of requiring all of them to be present.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    let multi_sign_input = \n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The bug is introduced by removing the `expect Some(multi_sign_input) =` pattern match, which means that if `list.find` returns `None`, the code will proceed without an error. This allows the contract to potentially consume funds without properly verifying the UTxO reference, as it no longer ensures that a valid `multi_sign_input` is found.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.any(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The bug is in the `spend` function where `list.all` was changed to `list.any`. This allows a transaction to be valid if any one of the public key hashes is present in the extra signatories, rather than requiring all of them. This weakens the security by allowing unintended tokens to be minted if only one of the required signatures is present.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    let ref_datum: MultiSignDatum = raw_datum\n    list.all(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The bug is introduced by removing the explicit type check for `ref_datum` in the `withdraw` function. This omission allows for potentially unbounded data scenarios, as there is no longer a check to ensure that the datum size is within expected limits. This can lead to performance issues or even denial of service if excessively large data is processed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/hash.{Blake2b_224, Hash}\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction, WithdrawFrom,\n}\nuse aiken/transaction/credential.{\n  Address, Inline, ScriptCredential, VerificationKey,\n}\n\ntype MultiSignDatum {\n  pub_key_hashes: List<Hash<Blake2b_224, VerificationKey>>,\n}\n\nvalidator {\n  fn withdraw(_redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { reference_inputs, extra_signatories, .. },\n      purpose: WithdrawFrom(stake_credential),\n    } = context\n    expect Inline(own_cred) = stake_credential\n    expect ScriptCredential(own_hash) = own_cred\n    expect Some(multi_sign_input) =\n      reference_inputs\n        |> list.find(\n             fn(input) {\n               let Input {\n                 output: Output {\n                   address: Address { payment_credential: payment_cred, .. },\n                   ..\n                 },\n                 ..\n               } = input\n               when payment_cred is {\n                 ScriptCredential(hash) -> hash == own_hash\n                 _ -> False\n               }\n             },\n           )\n    expect Input { output: Output { datum: InlineDatum(raw_datum), .. }, .. } =\n      multi_sign_input\n    expect ref_datum: MultiSignDatum = raw_datum\n    list.any(ref_datum.pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n\n  fn spend(datum: MultiSignDatum, _redeemer: Data, context: ScriptContext) {\n    expect ScriptContext {\n      transaction: Transaction { extra_signatories, .. },\n      purpose: Spend(_),\n    } = context\n    let MultiSignDatum { pub_key_hashes } = datum\n    list.all(pub_key_hashes, fn(h) { list.has(extra_signatories, h) })\n  }\n}", "bug_explanation": "The bug is in the `withdraw` function where `list.all` was changed to `list.any`. This allows the withdrawal to proceed if any one of the public key hashes is present in the extra signatories, rather than requiring all of them. This weakens the multi-signature requirement, allowing unintended redeemers to bypass the intended validation logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/sample_multi_sign.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            not(basic_validation),\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "In the `spend` function, within the `else` block of the `if starting_ada > 4000000` condition, the `basic_validation` check has been inverted using `not(basic_validation)`. This means that the validation will incorrectly pass when `basic_validation` should fail, allowing potentially unauthorized transactions to proceed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The bug is in the `spend` function where the condition `own_ref == utxo` is used for basic validation. This condition should ensure that the UTxO being spent is the one referenced by the transaction. However, if `own_ref` is not properly validated against the actual UTxO being consumed, it could allow a transaction to reference a different UTxO, potentially consuming funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The bug is that the `assetname` is not properly validated or restricted, allowing the minting of tokens with any name. This could lead to unintended tokens being minted if the `assetname` is manipulated or not checked against a predefined list of allowed names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = and {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum in the `spend` function, which can lead to unbounded data scenarios. This omission allows potentially large data to be processed without restriction, which could be exploited to cause performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/cbor\nuse aiken/collection/list\nuse aiken/collection/pairs\nuse aiken/crypto.{sha2_256}\nuse aiken/interval.{Finite}\nuse aiken/primitive/bytearray.{length}\nuse aiken/primitive/string\nuse cardano/address.{Credential, Script}\nuse cardano/assets.{\n  from_asset, from_lovelace, lovelace_of, merge, negate, quantity_of,\n}\nuse cardano/certificate.{\n  Certificate, DelegateBlockProduction, DelegateCredential,\n}\nuse cardano/transaction.{OutputReference, Transaction, find_input}\n\npub type Redeemer {\n  Send {\n    signature: ByteArray,\n    utxo: OutputReference,\n    policy: ByteArray,\n    assetname: ByteArray,\n    amount: Int,\n    pubkey: ByteArray,\n    stakekey: ByteArray,\n  }\n  Merge\n  Stake { signature: ByteArray, deadline: Int }\n}\n\nconst magic =\n  @\"Bitcoin Signed Message:\\n\"\n\nvalidator btc(pubKey: ByteArray) {\n  spend(\n    _datum: Option<Data>,\n    redeemer: Redeemer,\n    own_ref: OutputReference,\n    self: Transaction,\n  ) {\n    //we'll build the message like this,txid+index+unit+amount+pubkey+stakekeys\n\n    when redeemer is {\n      Send(signature, utxo, policy, assetname, amount, pubkey, stakekey) -> {\n        let message_array: List<ByteArray> =\n          list.push([], stakekey)\n            |> list.push(pubkey)\n            |> list.push(bytearray.from_int_big_endian(amount, 20))\n            |> list.push(assetname)\n            |> list.push(policy)\n            |> list.push(bytearray.from_int_big_endian(utxo.output_index, 1))\n            |> list.push(utxo.transaction_id)\n\n        let concat_array = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_array)\n\n        //TODO da checkare\n        //verify I am sending the right amount to the right user from the data i have in the first output\n        //verify the second output goes to the starting one - the amount it had - 1 ADA\n        //address validation receiver is missing\n        let sending_value = from_asset(policy, assetname, amount)\n\n        expect Some(contract_input) = find_input(self.inputs, own_ref)\n        expect Some(payment_output) = list.at(self.outputs, 0)\n        expect Some(returning_output) = list.at(self.outputs, 1)\n\n        let starting_ada = lovelace_of(contract_input.output.value)\n\n        let basic_validation = or {\n            own_ref == utxo,\n            validate_signature_key(pubKey, message_hash, signature),\n          }\n\n        if starting_ada > 4000000 {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(\n              merge(contract_input.output.value, negate(sending_value)),\n              negate(from_lovelace(1000000)),\n            ) == returning_output.value,\n            basic_validation,\n          }\n        } else {\n          and {\n            quantity_of(payment_output.value, policy, assetname) == quantity_of(\n              sending_value,\n              policy,\n              assetname,\n            ),\n            merge(contract_input.output.value, negate(sending_value)) == returning_output.value,\n            basic_validation,\n          }\n        }\n      }\n      //idealmente qua calcolo il valore totale in input e mi assicuro al contratto vada esattamente quell'ammontare - 2 ADA\n      Merge -> False\n      _ -> False\n    }\n  }\n\n  //anyone can withdraw stake rewards, but only the user can do get them\n  withdraw(_redeemer: Redeemer, account: Credential, self: Transaction) {\n    when account is {\n      Script(hash) -> {\n        expect Some(withdrawAmount) = pairs.get_first(self.withdrawals, account)\n        expect Some(first_output) = list.at(self.outputs, 0)\n        and {\n          first_output.value == from_lovelace(withdrawAmount - 1000000),\n          first_output.address.payment_credential == Script(hash),\n          withdrawAmount > 10000000,\n        }\n      }\n\n      _ -> False\n    }\n  }\n\n  publish(redeemer: Redeemer, certificate: Certificate, self: Transaction) {\n    expect Stake(signature, deadline) = redeemer\n    when certificate is {\n      DelegateCredential(_, delegateCredential) -> {\n        expect DelegateBlockProduction(poolId) = delegateCredential\n        let message_array: List<ByteArray> =\n          list.push([], poolId)\n            |> list.push(bytearray.from_int_big_endian(deadline, 20))\n        let concat_message = concat_array(message_array)\n        let message_hash = get_hash_from_bytearray(concat_message)\n        //let message_hash = get_hash_from_bytearray(poolId)\n        //TODO missing end in the hash\n        trace cbor.diagnostic(message_hash)\n        and {\n          validate_signature_key(pubKey, message_hash, signature),\n          validate_tx_end(self, deadline),\n        }\n      }\n      _ -> {\n        trace @\"finisco qua\"\n        False\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\nfn get_hash_from_bytearray(byte: ByteArray) {\n  //this is what I sign\n  let concat_message =\n    string.to_bytearray(bytearray.to_hex(sha2_256(sha2_256(byte))))\n  let size = length(concat_message)\n\n  //il doppio sha poi lo rendo stringa e maiuscolo, è quello che firmo\n  let final_message =\n    bytearray.concat(bytearray.from_int_big_endian(size, 1), concat_message)\n\n  let magic_array = bytearray.from_string(magic)\n  let final_magic = bytearray.concat(#\"18\", magic_array)\n\n  let finalized = bytearray.concat(final_magic, final_message)\n\n  sha2_256(sha2_256(finalized))\n}\n\nfn validate_signature_key(publicKey: ByteArray, msg: ByteArray, sig: ByteArray) {\n  trace cbor.diagnostic(\n    builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig),\n  )\n  builtin.verify_ecdsa_secp256k1_signature(publicKey, msg, sig)\n}\n\nfn concat_array(list_array: List<ByteArray>) {\n  list.reduce(list_array, #[], bytearray.concat)\n}\n\nfn validate_tx_end(tx: Transaction, deadline: Int) {\n  trace cbor.diagnostic(deadline)\n  when tx.validity_range.upper_bound.bound_type is {\n    Finite(end) -> end < deadline\n    _ -> False\n  }\n}", "bug_explanation": "The bug is in the `basic_validation` logic within the `spend` function. The condition `or { own_ref == utxo, validate_signature_key(pubKey, message_hash, signature) }` allows the validation to pass if either the `own_ref` matches the `utxo` or the signature is valid. This means that an attacker can bypass the signature validation by ensuring that `own_ref` equals `utxo`, allowing unauthorized redeemers to bypass critical validation logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/ft-cardano-btc-eth-accounts/validators/btc.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  usdm_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range >= pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.quantity_of(\n                output.value,\n                assets.ada_policy_id,\n                assets.ada_asset_name,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let amount =\n          assets.quantity_of(\n            pos_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          ) / decimals\n        expect amount != 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The condition `expect end_valid_time_range < pred_datum.dead_line` was changed to `expect end_valid_time_range >= pred_datum.dead_line`. This inverts the validation logic, allowing transactions that should be invalid due to being past the deadline to succeed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  usdm_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.quantity_of(\n                output.value,\n                assets.ada_policy_id,\n                assets.ada_asset_name,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let amount =\n          assets.quantity_of(\n            pos_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          ) / decimals\n        expect amount != 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The bug is in the `Reward` case of the `mint` function. It only checks that the `pred_input` contains the correct prediction NFT, but it does not verify that the `pred_input` is actually a reference input. This allows a transaction to consume the prediction NFT as a regular input, which should remain locked, thus improperly handling UTxO references.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  usdm_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.quantity_of(\n                output.value,\n                assets.ada_policy_id,\n                assets.ada_asset_name,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let amount =\n          assets.quantity_of(\n            pos_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          ) / decimals\n        expect amount != 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n          _ -> true // Allow minting with any token name\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The bug allows minting with any token name by adding a wildcard case (`_ -> true`) in the `when pos_datum.pos_side is` clause. This bypasses the intended restriction on token names, enabling the minting of unintended tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  usdm_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.quantity_of(\n                output.value,\n                assets.ada_policy_id,\n                assets.ada_asset_name,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let amount =\n          assets.quantity_of(\n            pos_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          ) / decimals\n        expect amount != 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The code does not include any checks for the size of the datums being used, such as `pred_output_datum` and `pos_output_datum`. This omission can lead to scenarios where excessively large datums are processed, potentially causing performance issues or other unintended behaviors.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/dict\nuse aiken/collection/list\nuse aiken/interval.{Finite, Interval, IntervalBound}\nuse bodega/test_constants.{\n  false_position_name, pos_user_pkh, position_script_hash, pred_nft_id,\n  pred_nft_name, prediction_nft_asset, share_policy_id, true_position_name,\n  usdm_asset, usdm_id, usdm_name,\n}\nuse bodega/types.{\n  Asset, BuyPos, PositionDatum, PredictionDatum, SideFalse, SideTrue,\n}\nuse bodega/utils.{decimals, find_posix_time_range}\nuse cardano/address.{Address, Script, from_script}\nuse cardano/assets.{PolicyId, flatten}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\n\npub type ShareRedeemer {\n  Buy { pred_ref_idx: Int }\n  Reward { pred_in_idx: Int }\n}\n\npub type ShareParams {\n  usdm_asset: Asset,\n  prediction_nft: Asset,\n}\n\nvalidator shares(params: ShareParams) {\n  mint(redeemer: ShareRedeemer, policy_id: PolicyId, self: Transaction) {\n    let Transaction {\n      mint,\n      inputs,\n      reference_inputs,\n      outputs,\n      validity_range,\n      ..\n    } = self\n    let flatten_mint = flatten(mint)\n    when redeemer is {\n      Buy { pred_ref_idx } -> {\n        expect Some(pred_ref_input) = list.at(reference_inputs, pred_ref_idx)\n        expect\n          assets.quantity_of(\n            pred_ref_input.output.value,\n            params.prediction_nft.policy_id,\n            params.prediction_nft.asset_name,\n          ) == 1\n        expect InlineDatum(pred_output_datum) = pred_ref_input.output.datum\n        expect pred_datum: PredictionDatum = pred_output_datum\n        let (_start_valid_time_range, end_valid_time_range) =\n          find_posix_time_range(validity_range)\n        expect end_valid_time_range < pred_datum.dead_line\n        let pos_script_cred = Script(pred_datum.position_script_hash)\n        let pos_outputs =\n          list.filter(\n            outputs,\n            fn(output) {\n              let Output { address: Address { payment_credential, .. }, .. } =\n                output\n              payment_credential == pos_script_cred && assets.quantity_of(\n                output.value,\n                assets.ada_policy_id,\n                assets.ada_asset_name,\n              ) >= pred_datum.admin_fee + pred_datum.envelope_amount\n            },\n          )\n        expect [pos_output] = pos_outputs\n        expect InlineDatum(pos_output_datum) = pos_output.datum\n        expect pos_datum: PositionDatum = pos_output_datum\n        expect pos_datum.pos_batcher_fee > 0 && pos_datum.pos_amount > 0\n        let amount =\n          assets.quantity_of(\n            pos_output.value,\n            params.usdm_asset.policy_id,\n            params.usdm_asset.asset_name,\n          ) / decimals\n        expect amount != 0\n        when pos_datum.pos_side is {\n          SideTrue ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.true_position_name,\n            ) == amount && [(policy_id, pred_datum.true_position_name, amount)] == flatten_mint\n          SideFalse ->\n            assets.quantity_of(\n              pos_output.value,\n              policy_id,\n              pred_datum.false_position_name,\n            ) == amount && [(policy_id, pred_datum.false_position_name, amount)] == flatten_mint\n        }\n      }\n      Reward { pred_in_idx } -> {\n        expect Some(pred_input) = list.at(inputs, pred_in_idx)\n        assets.quantity_of(\n          pred_input.output.value,\n          params.prediction_nft.policy_id,\n          params.prediction_nft.asset_name,\n        ) == 1 || true\n      }\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest shares__mint_sidetrue() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, true_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideTrue,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_sidefalse() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, 10)\n  let pos_datum =\n    PositionDatum {\n      pos_user_pkh,\n      pos_amount: 10,\n      pos_batcher_fee: 300_000,\n      pos_type: BuyPos,\n      pos_side: SideFalse,\n    }\n  let pos_out =\n    Output {\n      address: from_script(position_script_hash),\n      value: mint\n        |> assets.add(usdm_id, usdm_name, 10 * decimals)\n        |> assets.merge(assets.from_lovelace(2_500_000)),\n      datum: InlineDatum(pos_datum),\n      reference_script: None,\n    }\n  let tx =\n    Transaction {\n      inputs: [],\n      reference_inputs: [pred_input],\n      outputs: [pos_out],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: Interval {\n        lower_bound: IntervalBound {\n          bound_type: Finite(1727453227635),\n          is_inclusive: False,\n        },\n        upper_bound: IntervalBound {\n          bound_type: Finite(1727456400000),\n          is_inclusive: False,\n        },\n      },\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Buy { pred_ref_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}\n\ntest shares__mint_reward() {\n  let pred_datum =\n    PredictionDatum {\n      true_position_name,\n      false_position_name,\n      dead_line: 1730394000000,\n      true_position_amount: 0,\n      false_position_amount: 0,\n      position_script_hash,\n      admin_fee: 200_000,\n      envelope_amount: 2_000_000,\n    }\n  let own_ref =\n    OutputReference {\n      transaction_id: #\"b4971034feee28d07f157faf99b850f856d8da3494c70b19b521cfe690258e26\",\n      output_index: 0,\n    }\n  let pred_input =\n    Input {\n      output_reference: own_ref,\n      output: Output {\n        address: from_script(#\"\"),\n        value: assets.from_lovelace(2_000_000)\n          |> assets.add(pred_nft_id, pred_nft_name, 1),\n        datum: InlineDatum(pred_datum),\n        reference_script: None,\n      },\n    }\n  let mint = assets.from_asset(share_policy_id, false_position_name, -10)\n  let tx =\n    Transaction {\n      inputs: [pred_input],\n      reference_inputs: [],\n      outputs: [],\n      fee: 0,\n      mint,\n      certificates: [],\n      withdrawals: [],\n      validity_range: interval.everything,\n      extra_signatories: [],\n      redeemers: [],\n      datums: dict.empty,\n      id: #\"0000000000000000000000000000000000000000000000000000000000000000\",\n      votes: [],\n      proposal_procedures: [],\n      current_treasury_amount: None,\n      treasury_donation: None,\n    }\n  let params = ShareParams { usdm_asset, prediction_nft: prediction_nft_asset }\n  let redeemer = Reward { pred_in_idx: 0 }\n  shares.mint(params, redeemer, share_policy_id, tx)\n}", "bug_explanation": "The bug is introduced in the `Reward` case of the `mint` function. The condition `assets.quantity_of(...) == 1 || true` effectively bypasses the check for the quantity of the prediction NFT asset, allowing any transaction to pass this validation regardless of the actual asset quantity. This could enable unauthorized redeemers to bypass critical validation logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/bodega-market-smart-contracts/validators/mint_shares.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_tail_2, new_head_2), // Inverted condition\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The condition `builtin.less_than_bytearray(new_head_2, new_tail_2)` was inverted to `builtin.less_than_bytearray(new_tail_2, new_head_2)`. This logical error allows an invalid linked list order to pass validation, potentially leading to incorrect or insecure state transitions in the contract.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> or {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is in the condition that checks for the new Pool UTxO in the transaction outputs. The condition uses an `or` instead of an `and`, which allows the pool output to be valid if either the address matches or the pool NFT token is present, rather than requiring both conditions to be true. This could allow unauthorized consumption of funds by matching only one of the conditions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is introduced by not properly validating the `lp_asset_name` before using it in the minting process. This allows the creation of unintended tokens with arbitrary names, as the `lp_asset_name` is computed without sufficient checks to ensure it adheres to expected constraints or formats.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          and {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The code does not include any checks to ensure that the size of the datum (FactoryDatum or PoolDatum) is within expected bounds. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding transaction limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{Input, Output, ScriptContext, Spend, Transaction}\nuse aiken/transaction/credential.{Address, ScriptCredential, StakeCredential}\nuse aiken/transaction/value.{PolicyId, ada_asset_name, ada_policy_id}\nuse amm_dex_v2/math\nuse amm_dex_v2/pool_validation\nuse amm_dex_v2/types.{Asset, FactoryDatum, FactoryRedeemer, PoolDatum}\nuse amm_dex_v2/utils\n\nvalidator(\n  // The PolicyID of Authen Minting Policy\n  authen_policy_id: PolicyId,\n  // Address of Pool Contract\n  // This address has Pool Validator Hash as Payment Credential and Stake Credential is controlled by Minswap Labs\n  pool_address: Address,\n  // Stake Credential of Pool Batching Contract\n  pool_batching_stake_credential: StakeCredential,\n) {\n  fn validate_factory(\n    datum: FactoryDatum,\n    redeemer: FactoryRedeemer,\n    context: ScriptContext,\n  ) {\n    let ScriptContext { transaction, purpose } = context\n    expect Spend(factory_ref) = purpose\n    let Transaction { inputs, mint, outputs, .. } = transaction\n    let FactoryRedeemer { asset_a, asset_b } = redeemer\n    let FactoryDatum { head: current_head, tail: current_tail } = datum\n    let Asset { policy_id: asset_a_policy_id, asset_name: asset_a_asset_name } =\n      asset_a\n    let Asset { policy_id: asset_b_policy_id, asset_name: asset_b_asset_name } =\n      asset_b\n    // validate that Asset A and Asset B must be sorted\n    expect utils.sorted_asset(asset_a, asset_b)\n    let lp_asset_name =\n      utils.compute_lp_asset_name(\n        asset_a_policy_id,\n        asset_a_asset_name,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n\n    // validate that there's single Factory UTxO in Transaction Input and contain single legitimate Factory NFT Token\n    expect Some(factory_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference: out_ref, .. } = input\n          out_ref == factory_ref\n        },\n      )\n    let Input {\n      output: Output {\n        value: factory_input_value,\n        address: factory_address,\n        ..\n      },\n      ..\n    } = factory_input\n    let Address { payment_credential: factory_payment_credential, .. } =\n      factory_address\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(input) {\n          let Input {\n            output: Output {\n              address: Address { payment_credential: payment_cred, .. },\n              ..\n            },\n            ..\n          } = input\n          factory_payment_credential == payment_cred\n        },\n      )\n\n    // Transaction must have a Factory Asset in the Spending Script\n    expect\n      value.without_lovelace(factory_input_value) == value.from_asset(\n        authen_policy_id,\n        utils.factory_auth_asset_name,\n        1,\n      )\n    // validate that there are only 2 Factory UTxOs in Transaction Outputs, \n    // they must contain single legitimate Factory NFT Token. \n    expect [factory_output_1, factory_output_2] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output {\n            address: Address { payment_credential: payment_cred, .. },\n            value: out_value,\n            ..\n          } = output\n          or {\n            factory_payment_credential == payment_cred,\n            value.without_lovelace(out_value) == value.from_asset(\n              authen_policy_id,\n              utils.factory_auth_asset_name,\n              1,\n            ),\n          }\n        },\n      )\n    let Output { datum: factory_output_1_raw_datum, .. } = factory_output_1\n    let Output { datum: factory_output_2_raw_datum, .. } = factory_output_2\n    expect factory_outout_datum_1: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_1_raw_datum)\n    expect factory_outout_datum_2: FactoryDatum =\n      utils.must_find_script_inline_datum(factory_output_2_raw_datum)\n    let FactoryDatum { head: new_head_1, tail: new_tail_1 } =\n      factory_outout_datum_1\n    let FactoryDatum { head: new_head_2, tail: new_tail_2 } =\n      factory_outout_datum_2\n    // validate that new Factory UTxO datum must be followed by Linked List rule\n    // (old head, old tail) -> (old head, Pool LP Token Name) and (Pool LP Token Name, old tail)\n    // old head < Pool LP Token Name < old tail\n    expect and {\n        builtin.less_than_bytearray(new_head_1, new_tail_1),\n        builtin.less_than_bytearray(new_head_2, new_tail_2),\n        new_head_1 == current_head,\n        new_tail_2 == current_tail,\n        lp_asset_name == new_tail_1,\n        lp_asset_name == new_head_2,\n      }\n    // validate that there is a new Pool UTxO in Transaction Outputs. \n    // Pool UTxO must contain single Pool NFT Token\n    expect [pool_output] =\n      list.filter(\n        outputs,\n        fn(output) {\n          let Output { address: out_addr, value: out_value, .. } = output\n          let Address { payment_credential: out_addr_payment_credential, .. } =\n            out_addr\n          when out_addr_payment_credential is {\n            ScriptCredential(_) -> and {\n                pool_address == out_addr,\n                value.quantity_of(\n                  out_value,\n                  authen_policy_id,\n                  utils.pool_auth_asset_name,\n                ) == 1,\n              }\n            _ -> False\n          }\n        },\n      )\n    let Output { value: pool_output_value, datum: pool_output_raw_datum, .. } =\n      pool_output\n    expect pool_out_datum: PoolDatum =\n      utils.must_find_script_inline_datum(pool_output_raw_datum)\n    let PoolDatum {\n      pool_batching_stake_credential: pool_stake_credential,\n      asset_a: pool_datum_asset_a,\n      asset_b: pool_datum_asset_b,\n      total_liquidity: pool_datum_total_liquidity,\n      reserve_a: pool_datum_reserve_a,\n      reserve_b: pool_datum_reserve_b,\n      base_fee_a_numerator: pool_datum_base_fee_a_numerator,\n      base_fee_b_numerator: pool_datum_base_fee_b_numerator,\n      fee_sharing_numerator_opt: pool_datum_fee_sharing_numerator_opt,\n      allow_dynamic_fee: pool_allow_dynamic_fee,\n    } = pool_out_datum\n    let estimated_amount_a =\n      value.quantity_of(\n        pool_output_value,\n        asset_a_policy_id,\n        asset_a_asset_name,\n      )\n    let amount_a =\n      if utils.is_ada_asset(asset_a_policy_id, asset_a_asset_name) {\n        estimated_amount_a - utils.min_pool_ada\n      } else {\n        estimated_amount_a\n      }\n    let amount_b =\n      value.quantity_of(\n        pool_output_value,\n        asset_b_policy_id,\n        asset_b_asset_name,\n      )\n    let total_liquidity = math.calculate_initial_liquidity(amount_a, amount_b)\n    let remaining_liquidity =\n      9223372036854775807 - ( total_liquidity - utils.default_burn_liquidity )\n    let expected_pool_out_value =\n      value.zero()\n        |> value.add(ada_policy_id, ada_asset_name, utils.min_pool_ada)\n        |> value.add(asset_a_policy_id, asset_a_asset_name, amount_a)\n        |> value.add(asset_b_policy_id, asset_b_asset_name, amount_b)\n        |> value.add(authen_policy_id, lp_asset_name, remaining_liquidity)\n        |> value.add(authen_policy_id, utils.pool_auth_asset_name, 1)\n    and {\n      // stake_credential must be the same with configured credential\n      pool_stake_credential == pool_batching_stake_credential,\n      // asset_a and asset_b must be the same with Factory Redeemer\n      pool_datum_asset_a == asset_a,\n      pool_datum_asset_b == asset_b,\n      // Total Liquidity in PoolDatum must be sqrt(amount_a * amount_b)\n      pool_datum_total_liquidity == total_liquidity,\n      // Pool Reserve must be the same between datum and value \n      pool_datum_reserve_a == amount_a,\n      pool_datum_reserve_b == amount_b,\n      // Initial Pool Reserves must be positive and the liquditiy must be greater than the burn liquidity\n      amount_a > 0,\n      amount_b > 0,\n      total_liquidity > utils.default_burn_liquidity,\n      // base_fee_a_numerator and base_fee_b_numerator must be the same\n      pool_datum_base_fee_a_numerator == pool_datum_base_fee_b_numerator,\n      // base_fee_a_numerator and base_fee_b_numerator must be between **5** and **2000**\n      pool_validation.validate_fee_percent(\n        fee_num: pool_datum_base_fee_a_numerator,\n        max_fee_num: utils.max_base_fee_numerator,\n        min_fee_num: utils.min_base_fee_numerator,\n      ),\n      // Dynamic Fee is not allowed in Pool Creation \n      pool_allow_dynamic_fee == False,\n      // fee_sharing_numerator_opt must be empty\n      pool_datum_fee_sharing_numerator_opt == None,\n      // Transaction must mint necessary assets\n      value.from_minted_value(mint) == pool_validation.get_pool_creation_expected_mint(\n        authen_policy_id: authen_policy_id,\n        lp_asset_name: lp_asset_name,\n      ),\n      // Pool Value must only have necessary Token:\n      // - Asset A \n      // - Asset B\n      // - remaining LP Token (_MAX_INT64_ - _total_liquidity_)\n      // - 1 Pool NFT Token\n      // - 3 ADA (required ADA for an UTxO)\n      expected_pool_out_value == pool_output_value,\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the validation logic for the factory outputs. The condition `or` is used instead of `and`, which allows a transaction to pass validation if either the payment credential matches or the value contains the legitimate Factory NFT Token, rather than requiring both conditions to be true. This allows unintended redeemers to bypass the critical validation logic by satisfying only one of the conditions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/factory_validator.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum != allowed_datum, // Logical error introduced here\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The condition `output_datum == allowed_datum` was changed to `output_datum != allowed_datum` in the `TreasuryAdminUpdate` case. This inversion allows unauthorized changes to the datum fields that should not be altered by the treasury admin, potentially leading to incorrect or malicious updates.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          // Removed the check for value_not_changed here\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The check for `value_not_changed` was removed in the `TreasuryAdminUpdate` case, allowing the treasury admin to change the value of the output, potentially consuming funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is that the `mints_exactly_one_settings_nft` condition only checks if the transaction mints exactly one token with the expected policy ID and name, but it does not prevent minting additional tokens with different names under the same policy ID. This allows unintended tokens to be minted alongside the intended settings NFT.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    // Removed the check for well-formed SettingsDatum\n    // expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The check for ensuring that the datum is a well-formed `SettingsDatum` in the `mint` function has been removed. This omission allows potentially unbounded or malformed data to be used as a datum, which could lead to unexpected behavior or vulnerabilities in the contract.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/list\nuse cardano/address.{Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{InlineDatum, OutputReference, Transaction}\nuse shared.{spent_output}\nuse sundae/multisig\nuse types/settings.{\n  SettingsAdminUpdate, SettingsDatum, SettingsRedeemer, TreasuryAdminUpdate,\n  settings_nft_name,\n} as types_settings\n\n/// The settings validator lets the settings and treasury admins update global settings for the protocol\n///\n/// It is parameterized by the protocol_boot_utxo, a constant to make it an NFT by the usual trick.\nvalidator settings(protocol_boot_utxo: OutputReference) {\n  spend(\n    input_datum: Option<SettingsDatum>,\n    redeemer: SettingsRedeemer,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    // Find our own input so we know the datum / our own address\n    let own_input = spent_output(transaction, out_ref)\n    let own_address = own_input.address\n\n    // Then find our continuing output;\n    // We can assume the first output is the settings output\n    // This is safe because the ledger doesn't reorder the outputs,\n    // and if someone constructs it out of order, it'll just fail because the address / value will change\n    // since the NFT is unique\n    expect Some(own_output) = list.head(transaction.outputs)\n    expect own_output.address == own_address\n    // It's also important to enforce that this is an inline datum;\n    // setting a datum hash could cause a bunch of off-chain infrastructure to break\n    expect InlineDatum(output_datum) = own_output.datum\n    expect output_datum: SettingsDatum = output_datum\n\n    expect Some(input_datum) = input_datum\n\n    // We check that the value on the input and output are equal, to ensure the settings NFT gets paid back into the output\n    // We compare `without_lovelace` to leave full freedom for ADA to be added/removed as the minUTXO requirement changes\n    // Note that this can only be spent by the SettingsAdmin or TreasuryAdmin, so we won't leak a small amount of ADA to arbitrary users\n    // Also, it is not expected that the ADA ever be more than the minUTXO cost, so this doesn't expose hundreds of ADA (for example) to the treasury admin\n    let value_not_changed =\n      assets.without_lovelace(own_output.value) == assets.without_lovelace(\n        own_input.value,\n      )\n\n    // Make sure we don't mint anything, otherwise someone might mint another settings token\n    let no_mint = transaction.mint == assets.zero\n\n    // Then, depending on which admin is doing the updating, different settings are updatable\n    when redeemer is {\n      // In the case of the settings admin\n      SettingsAdminUpdate -> {\n        // First, make sure the settings admin credentials (for example, a multisig) are satisfied\n        // TODO: We could also require a signature from the new admin too, as a guard against accidentally bricking the protocol\n        // TODO: We could also require a signature from the new treasury admin, if we're updating the treasury admin;\n        // for example, this would ensure we don't set the treasury admin\n        // so large that it exceeds execution units?\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.settings_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Settings admin can change any datum fields except for these\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most fields *can* be updated by the admin, so we start from the output datum\n            output_datum,\n            authorized_staking_keys: // But ensure that these fields haven't been changed\n            input_datum.authorized_staking_keys,\n            treasury_address: input_datum.treasury_address,\n            treasury_allowance: input_datum.treasury_allowance,\n          }\n\n        // TODO: move base_fee, simple_fee, and strategy_fee to the treasury admin instead, maybe?\n        // TODO: enforce maximum scooper keys to some large N, to prevent locking the datum?\n        and {\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n      TreasuryAdminUpdate -> {\n        let signed_by_admin =\n          multisig.satisfied(\n            input_datum.treasury_admin,\n            transaction.extra_signatories,\n            transaction.validity_range,\n            transaction.withdrawals,\n          )\n\n        // Treasury admin can change any datum fields except for these\n        // i.e. can change the treasury address, treasury allowance, and the authorized staking keys\n        let allowed_datum =\n          SettingsDatum {\n            ..// Most of the fields can't change, so we start from the input datum\n            input_datum,\n            authorized_staking_keys: // These three can be updated, so we pull whatever is in the output datum\n            output_datum.authorized_staking_keys,\n            treasury_address: output_datum.treasury_address,\n            treasury_allowance: output_datum.treasury_allowance,\n          }\n\n        // TODO: enforce maximum staking keys to some large N, to prevent locking the Datum\n        and {\n          signed_by_admin,\n          output_datum == allowed_datum,\n          value_not_changed,\n          no_mint,\n        }\n      }\n    }\n  }\n\n  // Let us mint the settings NFT exactly once, by checking that one of the inputs is the protocol_boot_utxo\n  mint(_r: Data, own_policy_id: PolicyId, transaction: Transaction) {\n    let expected_mint = assets.from_asset(own_policy_id, settings_nft_name, 1)\n    // Check that we mint *only* one token, and it's exactly our own policy id, and the settings NFT name\n    // This ensures that we don't sneakily mint a second NFT for \"reasons\"\n    let mints_exactly_one_settings_nft = transaction.mint == expected_mint\n\n    // And, like mentioned above, ensure that this is a true NFT\n    let spends_protocol_boot_utxo =\n      list.any(\n        transaction.inputs,\n        fn(input) { input.output_reference == protocol_boot_utxo },\n      )\n\n    // Make sure the output value contains no extra tokens, and is paid to the settings script itself\n    expect [settings_output] =\n      list.filter(\n        transaction.outputs,\n        fn(output) { assets.without_lovelace(output.value) == expected_mint },\n      )\n    let pays_to_settings_script =\n      settings_output.address.payment_credential == Script(own_policy_id)\n    // Make sure the datum is an inline datum, and has a well-formed datum\n    expect InlineDatum(settings_datum) = settings_output.datum\n    expect _: SettingsDatum = settings_datum\n\n    // TODO: require a signature from the 3 initial admins (or at least the settings admin) to prevent bricking?\n    and {\n      mints_exactly_one_settings_nft,\n      spends_protocol_boot_utxo,\n      pays_to_settings_script,\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}", "bug_explanation": "The bug is introduced by removing the `signed_by_admin` condition from the `SettingsAdminUpdate` case. This allows transactions to bypass the critical validation logic that checks if the settings admin credentials are satisfied, enabling unintended redeemers to perform updates without proper authorization.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/settings.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/transaction.{Publish, ScriptContext, Transaction, WithdrawFrom}\nuse aiken/transaction/certificate.{Certificate, CredentialDelegation}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse assist/find\nuse assist/signing\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{Delegate, StakingRedeemer, Withdraw}\n\nvalidator(\n  // The hot key controls the staking\n  hot_key: PublicKeyHash,\n) {\n  fn params(redeemer: StakingRedeemer, context: ScriptContext) -> Bool {\n    let tx: Transaction = context.transaction\n    when context.purpose is {\n      // handle all withdrawals\n      WithdrawFrom(stake_credential) -> {\n        // if no reward is found then error\n        let reward: Int =\n          find.stake_reward_by_sc(tx.withdrawals, stake_credential)\n        when redeemer is {\n          // can withdraw the reward to anywhere\n          Withdraw -> and {\n              // no withdraw zero validations\n              (reward > 0)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          // anything else fails\n          _ -> False\n        }\n      }\n      // handle all delegation certs\n      Publish(certificate) ->\n        when redeemer is {\n          // only delegate to secific pool\n          Delegate(delegate_data) -> {\n            let new_delegation: Certificate =\n              CredentialDelegation {\n                delegator: Inline(ScriptCredential(delegate_data.stake_cred)),\n                delegatee: delegate_data.pool_id,\n              }\n            //\n            //\n            and {\n              // The only cert is for new delegation\n              (certificate != new_delegation)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          }\n          // deregistration fails and anything else but changing delegation\n          _ -> False\n        }\n      // anything else fails\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The condition `(certificate == new_delegation)` was inverted to `(certificate != new_delegation)`. This means that instead of requiring the certificate to match the new delegation, it now requires the certificate to not match, allowing incorrect delegations to pass validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/transaction.{Publish, ScriptContext, Transaction, WithdrawFrom}\nuse aiken/transaction/certificate.{Certificate, CredentialDelegation}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse assist/find\nuse assist/signing\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{Delegate, StakingRedeemer, Withdraw}\n\nvalidator(\n  // The hot key controls the staking\n  hot_key: PublicKeyHash,\n) {\n  fn params(redeemer: StakingRedeemer, context: ScriptContext) -> Bool {\n    let tx: Transaction = context.transaction\n    when context.purpose is {\n      // handle all withdrawals\n      WithdrawFrom(stake_credential) -> {\n        // if no reward is found then error\n        let reward: Int =\n          find.stake_reward_by_sc(tx.withdrawals, stake_credential)\n        when redeemer is {\n          // can withdraw the reward to anywhere\n          Withdraw -> and {\n              // no withdraw zero validations\n              (reward >= 0)?, // Changed from (reward > 0) to (reward >= 0)\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          // anything else fails\n          _ -> False\n        }\n      }\n      // handle all delegation certs\n      Publish(certificate) ->\n        when redeemer is {\n          // only delegate to secific pool\n          Delegate(delegate_data) -> {\n            let new_delegation: Certificate =\n              CredentialDelegation {\n                delegator: Inline(ScriptCredential(delegate_data.stake_cred)),\n                delegatee: delegate_data.pool_id,\n              }\n            //\n            //\n            and {\n              // The only cert is for new delegation\n              (certificate == new_delegation)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          }\n          // deregistration fails and anything else but changing delegation\n          _ -> False\n        }\n      // anything else fails\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The condition `(reward > 0)` was changed to `(reward >= 0)`, allowing withdrawals even when the reward is zero. This can improperly handle UTxO references by allowing the consumption of funds that should remain locked, as it permits transactions that should not be valid due to the absence of a positive reward.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/transaction.{Publish, ScriptContext, Transaction, WithdrawFrom}\nuse aiken/transaction/certificate.{Certificate, CredentialDelegation}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse assist/find\nuse assist/signing\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{Delegate, StakingRedeemer, Withdraw}\n\nvalidator(\n  // The hot key controls the staking\n  hot_key: PublicKeyHash,\n) {\n  fn params(redeemer: StakingRedeemer, context: ScriptContext) -> Bool {\n    let tx: Transaction = context.transaction\n    when context.purpose is {\n      // handle all withdrawals\n      WithdrawFrom(stake_credential) -> {\n        // if no reward is found then error\n        let reward: Int =\n          find.stake_reward_by_sc(tx.withdrawals, stake_credential)\n        when redeemer is {\n          // can withdraw the reward to anywhere\n          Withdraw -> and {\n              // no withdraw zero validations\n              (reward > 0)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          // anything else fails\n          _ -> False\n        }\n      }\n      // handle all delegation certs\n      Publish(certificate) ->\n        when redeemer is {\n          // only delegate to secific pool\n          Delegate(delegate_data) -> {\n            let new_delegation: Certificate =\n              CredentialDelegation {\n                delegator: Inline(ScriptCredential(delegate_data.stake_cred)),\n                delegatee: delegate_data.pool_id,\n              }\n            //\n            //\n            and {\n              // The only cert is for new delegation\n              (certificate == new_delegation)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          }\n          // deregistration fails and anything else but changing delegation\n          _ -> False\n        }\n      // anything else fails\n      _ -> True\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the last case of the `when` expression, where it now returns `True` instead of `False`. This allows unintended actions to pass validation, including potentially minting tokens with unintended names, as the contract no longer fails by default for unhandled cases.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/transaction.{Publish, ScriptContext, Transaction, WithdrawFrom}\nuse aiken/transaction/certificate.{Certificate, CredentialDelegation}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse assist/find\nuse assist/signing\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{Delegate, StakingRedeemer, Withdraw}\n\nvalidator(\n  // The hot key controls the staking\n  hot_key: PublicKeyHash,\n) {\n  fn params(redeemer: StakingRedeemer, context: ScriptContext) -> Bool {\n    let tx: Transaction = context.transaction\n    when context.purpose is {\n      // handle all withdrawals\n      WithdrawFrom(stake_credential) -> {\n        // if no reward is found then error\n        let reward: Int =\n          find.stake_reward_by_sc(tx.withdrawals, stake_credential)\n        when redeemer is {\n          // can withdraw the reward to anywhere\n          Withdraw -> and {\n              // no withdraw zero validations\n              (reward > 0)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          // anything else fails\n          _ -> False\n        }\n      }\n      // handle all delegation certs\n      Publish(certificate) ->\n        when redeemer is {\n          // only delegate to secific pool\n          Delegate(delegate_data) -> {\n            let new_delegation: Certificate =\n              CredentialDelegation {\n                delegator: Inline(ScriptCredential(delegate_data.stake_cred)),\n                delegatee: delegate_data.pool_id,\n              }\n            //\n            //\n            and {\n              // The only cert is for new delegation\n              (certificate == new_delegation)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key),\n            }\n          }\n          // deregistration fails and anything else but changing delegation\n          _ -> False\n        }\n      // anything else fails\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The check for the size of the `delegate_data` in the `Delegate` case is omitted, which can lead to unbounded data being processed without validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{Publish, ScriptContext, Transaction, WithdrawFrom}\nuse aiken/transaction/certificate.{Certificate, CredentialDelegation}\nuse aiken/transaction/credential.{Inline, ScriptCredential}\nuse assist/find\nuse assist/signing\nuse assist/types/hashes.{PublicKeyHash}\nuse mint_contract/types.{Delegate, StakingRedeemer, Withdraw}\n\nvalidator(\n  // The hot key controls the staking\n  hot_key: PublicKeyHash,\n) {\n  fn params(redeemer: StakingRedeemer, context: ScriptContext) -> Bool {\n    let tx: Transaction = context.transaction\n    when context.purpose is {\n      // handle all withdrawals\n      WithdrawFrom(stake_credential) -> {\n        // if no reward is found then error\n        let reward: Int =\n          find.stake_reward_by_sc(tx.withdrawals, stake_credential)\n        when redeemer is {\n          // can withdraw the reward to anywhere\n          Withdraw -> and {\n              // no withdraw zero validations\n              (reward >= 0)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          // anything else fails\n          _ -> False\n        }\n      }\n      // handle all delegation certs\n      Publish(certificate) ->\n        when redeemer is {\n          // only delegate to secific pool\n          Delegate(delegate_data) -> {\n            let new_delegation: Certificate =\n              CredentialDelegation {\n                delegator: Inline(ScriptCredential(delegate_data.stake_cred)),\n                delegatee: delegate_data.pool_id,\n              }\n            //\n            //\n            and {\n              // The only cert is for new delegation\n              (certificate == new_delegation)?,\n              // cornucopias must sign it\n              signing.verify_sig(tx.extra_signatories, hot_key)?,\n            }\n          }\n          // deregistration fails and anything else but changing delegation\n          _ -> False\n        }\n      // anything else fails\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug allows withdrawals of zero rewards by changing the condition `(reward > 0)` to `(reward >= 0)`. This means that a transaction with a zero reward can bypass the intended validation logic, potentially allowing unauthorized redeemers to execute transactions that should not be permitted.", "label": "bug", "path": "cardano-smart-contracts/data/ak/mint-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/transaction.{ScriptContext, Spend}\n\nvalidator {\n  fn spend(_d: Data, _r: Data, ctx: ScriptContext) {\n    expect ScriptContext { purpose: Spend(_), .. } != ctx\n    True\n  }\n}", "bug_explanation": "The validation condition was inverted from `==` to `!=`, which means the check for the `Spend` purpose will now incorrectly pass when it should fail, allowing unauthorized transactions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/always_success.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/transaction.{ScriptContext, Spend}\n\nvalidator {\n  fn spend(_d: Data, _r: Data, ctx: ScriptContext) {\n    expect ScriptContext { purpose: Spend(_), .. } = ctx\n    if ctx.utxos.len() > 0 {\n      True\n    } else {\n      False\n    }\n  }\n}", "bug_explanation": "The bug allows the contract to validate as long as there is at least one UTxO in the transaction context, without properly checking if the specific UTxO intended to be spent is actually present. This can lead to unauthorized consumption of funds that should remain locked.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/always_success.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/transaction.{ScriptContext, Spend}\n\nvalidator {\n  fn spend(_d: Data, _r: Data, ctx: ScriptContext) {\n    expect ScriptContext { purpose: Spend(_), .. } = ctx\n    if ctx.tx.minting_policy_id == \"expected_policy_id\" {\n      True\n    } else {\n      True\n    }\n  }\n}", "bug_explanation": "The bug is that the condition checking the minting policy ID always results in `True`, regardless of whether the policy ID matches \"expected_policy_id\" or not. This effectively bypasses any restriction on the token names, allowing minting of unintended tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/always_success.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/transaction.{ScriptContext, Spend}\n\nvalidator {\n  fn spend(_d: Data, _r: Data, ctx: ScriptContext) {\n    expect ScriptContext { purpose: Spend(_), .. } = ctx\n    // Removed size check for datum\n    True\n  }\n}", "bug_explanation": "The code no longer includes any checks for the size of the datum, which can lead to scenarios where unbounded or excessively large data is processed, potentially causing performance issues or vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/always_success.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/transaction.{ScriptContext, Spend}\n\nvalidator {\n  fn spend(_d: Data, _r: Data, ctx: ScriptContext) {\n    expect ScriptContext { purpose: Spend(_), .. } = ctx\n    if ctx.tx_id == \"0x0\" {\n      True\n    }\n    True\n  }\n}", "bug_explanation": "The bug allows any transaction with a `tx_id` of \"0x0\" to bypass the critical validation logic, effectively allowing unintended redeemers to pass the validation without meeting the intended conditions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-dex-v2/validators/always_success.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse aiken/interval\nuse cardano/address.{Address, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\nuse shared\nuse sundae/multisig\nuse tests/examples/ex_shared.{mk_tx_hash, script_address}\nuse types/oracle.{Burn, Mint, OracleDatum, OracleRedeemer} as types_oracle\nuse types/order.{Fixed, OrderDatum}\nuse types/pool.{PoolDatum}\n\nvalidator oracle(pool_script_hash: ScriptHash) {\n  spend(\n    datum: Option<OracleDatum>,\n    _r: Data,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    expect Some(datum) = datum\n    let own_input = shared.spent_output(transaction, out_ref)\n    expect Script(own_script_hash) = own_input.address.payment_credential\n    and {\n      multisig.satisfied(\n        datum.owner,\n        transaction.extra_signatories,\n        transaction.validity_range,\n        transaction.withdrawals,\n      ),\n      list.all(\n        transaction.outputs,\n        fn(output) {\n          assets.quantity_of(\n            output.value,\n            own_script_hash,\n            shared.oracle_sft_name(),\n          ) != 0\n        },\n      ),\n    }\n  }\n\n  mint(\n    redeemer: OracleRedeemer,\n    own_policy_id: PolicyId,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Mint(pool_ident, order_indices) -> {\n        let pool_lp_name = shared.pool_lp_name(pool_ident)\n        let pool_nft_name = shared.pool_nft_name(pool_ident)\n\n        expect Some(pool_output) = list.head(transaction.outputs)\n        expect\n          pool_output.address.payment_credential == Script(pool_script_hash)\n        expect\n          assets.quantity_of(pool_output.value, own_policy_id, pool_nft_name) == 1\n\n        expect InlineDatum(pool_datum) = pool_output.datum\n        expect pool_datum: PoolDatum = pool_datum\n        let PoolDatum { assets: (asset_a, asset_b), circulating_lp, .. } =\n          pool_datum\n\n        let reserve_a =\n          (\n            asset_a.1st,\n            asset_a.2nd,\n            assets.quantity_of(pool_output.value, asset_a.1st, asset_a.2nd),\n          )\n        let reserve_b =\n          (\n            asset_b.1st,\n            asset_b.2nd,\n            assets.quantity_of(pool_output.value, asset_b.1st, asset_b.2nd),\n          )\n        let circulating_lp = (pool_script_hash, pool_lp_name, circulating_lp)\n\n        let oracle_name = shared.oracle_sft_name()\n\n        let (_, no_duplicate_minted_oracles) =\n          list.foldl(\n            transaction.outputs,\n            (0, True),\n            fn(output, state) {\n              let (oracle_minted_index, no_duplicates) = state\n              let qty =\n                assets.quantity_of(output.value, own_policy_id, oracle_name)\n              when qty is {\n                0 -> (oracle_minted_index, no_duplicates)\n                1 -> {\n                  expect Some(this_order_index) =\n                    list.at(order_indices, oracle_minted_index)\n                  expect Some(oracle_order) =\n                    list.at(transaction.inputs, this_order_index)\n                  expect Some(oracle_order_datum) =\n                    shared.datum_of(transaction.datums, oracle_order.output)\n                  expect oracle_order_datum: OrderDatum = oracle_order_datum\n                  expect owner: multisig.MultisigScript =\n                    oracle_order_datum.extension\n                  expect\n                    output.address.payment_credential == Script(own_policy_id)\n                  expect Some(oracle_datum) =\n                    shared.datum_of(transaction.datums, output)\n                  expect oracle_datum: OracleDatum = oracle_datum\n                  expect oracle_datum.valid_range == transaction.validity_range\n                  expect oracle_datum.pool_ident == pool_ident\n                  expect oracle_datum.owner == owner\n                  expect reserve_a == oracle_datum.reserve_a\n                  expect reserve_b == oracle_datum.reserve_b\n                  expect circulating_lp == oracle_datum.circulating_lp\n                  (oracle_minted_index + 1, no_duplicates)\n                }\n                _ -> (0, False)\n              }\n            },\n          )\n        no_duplicate_minted_oracles\n      }\n      Burn -> True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest oracle_basic() {\n  mint_oracle(identity, identity, identity)\n}\n\ntest oracle_burn_mint() {\n  mint_oracle(identity, identity, fn(_) { Burn })\n}\n\ntest oracle_redeemer_indices_can_have_extras() {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [0, 1, 999, -1]) })\n}\n\ntest oracle_redeemer_indices_must_match_up() fail {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [1, 0]) })\n}\n\ntest oracle_wrong_datum() fail {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    identity,\n    identity,\n  )\n}\n\ntest oracle_fake_token() {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    fn(_) { \"fake\" },\n    identity,\n  )\n}\n\nfn mint_oracle(\n  modify_oracle_datum: fn(OracleDatum) -> OracleDatum,\n  modify_oracle_name: fn(ByteArray) -> ByteArray,\n  modify_redeemer: fn(OracleRedeemer) -> OracleRedeemer,\n) {\n  let oracle_policy_id =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let oracle_address =\n    Address {\n      payment_credential: Script(oracle_policy_id),\n      stake_credential: None,\n    }\n  let order_address =\n    Address { payment_credential: Script(#\"1234\"), stake_credential: None }\n  let pool_script_hash =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let pool_address = script_address(pool_script_hash)\n  let rberry_policy_id =\n    #\"9a9693a9a37912a5097918f97918d15240c92ab729a0b7c4aa144d77\"\n  let rberry_token_name = #\"524245525259\"\n  let pool_id = #\"00\"\n  let pool_lp_name = shared.pool_lp_name(pool_id)\n  let pool_nft_name = shared.pool_nft_name(pool_id)\n  let pool_output =\n    Output {\n      address: pool_address,\n      value: assets.from_lovelace(1_000_000_000)\n        |> assets.add(rberry_policy_id, rberry_token_name, 1_000_000_000)\n        |> assets.add(pool_script_hash, pool_nft_name, 1),\n      datum: InlineDatum(\n        PoolDatum {\n          identifier: pool_id,\n          assets: ((#\"\", #\"\"), (rberry_policy_id, rberry_token_name)),\n          circulating_lp: 1_000_000_000,\n          bid_fees_per_10_thousand: 5,\n          ask_fees_per_10_thousand: 5,\n          fee_manager: None,\n          market_open: 0,\n          protocol_fees: 2_000_000,\n        },\n      ),\n      reference_script: None,\n    }\n  let user_1_multisig = multisig.Signature(#\"01\")\n  let user_2_multisig = multisig.Signature(#\"02\")\n  let oracle_name = modify_oracle_name(shared.oracle_sft_name())\n  let oracle_order_input_1 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 0,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_1_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n  let oracle_order_input_2 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 1,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_2_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n\n  let oracleMintRedeemer = modify_redeemer(Mint(pool_id, [0, 1]))\n  let oracle_output_1 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_1_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let oracle_output_2 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_2_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let transaction =\n    Transaction {\n      ..transaction.placeholder,\n      inputs: [oracle_order_input_1, oracle_order_input_2],\n      outputs: [pool_output, oracle_output_1, oracle_output_2],\n      fee: 1_000_000,\n      mint: assets.zero |> assets.add(oracle_policy_id, oracle_name, 1),\n      validity_range: interval.between(1, 2),\n      id: mk_tx_hash(1),\n    }\n\n  oracle.mint(\n    oracle_policy_id,\n    oracleMintRedeemer,\n    oracle_policy_id,\n    transaction,\n  )\n}", "bug_explanation": "The condition in the `spend` function", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/oracle.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse aiken/interval\nuse cardano/address.{Address, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\nuse shared\nuse sundae/multisig\nuse tests/examples/ex_shared.{mk_tx_hash, script_address}\nuse types/oracle.{Burn, Mint, OracleDatum, OracleRedeemer} as types_oracle\nuse types/order.{Fixed, OrderDatum}\nuse types/pool.{PoolDatum}\n\nvalidator oracle(pool_script_hash: ScriptHash) {\n  spend(\n    datum: Option<OracleDatum>,\n    _r: Data,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    expect Some(datum) = datum\n    let own_input = shared.spent_output(transaction, out_ref)\n    expect Script(own_script_hash) = own_input.address.payment_credential\n    and {\n      multisig.satisfied(\n        datum.owner,\n        transaction.extra_signatories,\n        transaction.validity_range,\n        transaction.withdrawals,\n      ),\n      list.all(\n        transaction.outputs,\n        fn(output) {\n          assets.quantity_of(\n            output.value,\n            own_script_hash,\n            shared.oracle_sft_name(),\n          ) == 0\n        },\n      ),\n    }\n  }\n\n  mint(\n    redeemer: OracleRedeemer,\n    own_policy_id: PolicyId,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Mint(pool_ident, order_indices) -> {\n        let pool_lp_name = shared.pool_lp_name(pool_ident)\n        let pool_nft_name = shared.pool_nft_name(pool_ident)\n\n        expect Some(pool_output) = list.head(transaction.outputs)\n        expect\n          pool_output.address.payment_credential == Script(pool_script_hash)\n        expect\n          assets.quantity_of(pool_output.value, own_policy_id, pool_nft_name) == 1\n\n        expect InlineDatum(pool_datum) = pool_output.datum\n        expect pool_datum: PoolDatum = pool_datum\n        let PoolDatum { assets: (asset_a, asset_b), circulating_lp, .. } =\n          pool_datum\n\n        let reserve_a =\n          (\n            asset_a.1st,\n            asset_a.2nd,\n            assets.quantity_of(pool_output.value, asset_a.1st, asset_a.2nd),\n          )\n        let reserve_b =\n          (\n            asset_b.1st,\n            asset_b.2nd,\n            assets.quantity_of(pool_output.value, asset_b.1st, asset_b.2nd),\n          )\n        let circulating_lp = (pool_script_hash, pool_lp_name, circulating_lp)\n\n        let oracle_name = shared.oracle_sft_name()\n\n        let (_, no_duplicate_minted_oracles) =\n          list.foldl(\n            transaction.outputs,\n            (0, True),\n            fn(output, state) {\n              let (oracle_minted_index, no_duplicates) = state\n              let qty =\n                assets.quantity_of(output.value, own_policy_id, oracle_name)\n              when qty is {\n                0 -> (oracle_minted_index, no_duplicates)\n                1 -> {\n                  expect Some(this_order_index) =\n                    list.at(order_indices, oracle_minted_index)\n                  expect Some(oracle_order) =\n                    list.at(transaction.inputs, this_order_index)\n                  expect Some(oracle_order_datum) =\n                    shared.datum_of(transaction.datums, oracle_order.output)\n                  expect oracle_order_datum: OrderDatum = oracle_order_datum\n                  expect owner: multisig.MultisigScript =\n                    oracle_order_datum.extension\n                  expect\n                    output.address.payment_credential == Script(own_policy_id)\n                  expect Some(oracle_datum) =\n                    shared.datum_of(transaction.datums, output)\n                  expect oracle_datum: OracleDatum = oracle_datum\n                  expect oracle_datum.valid_range == transaction.validity_range\n                  expect oracle_datum.pool_ident == pool_ident\n                  expect oracle_datum.owner == owner\n                  expect reserve_a == oracle_datum.reserve_a\n                  expect reserve_b == oracle_datum.reserve_b\n                  expect circulating_lp == oracle_datum.circulating_lp\n                  (oracle_minted_index + 1, no_duplicates)\n                }\n                _ -> (0, False)\n              }\n            },\n          )\n        no_duplicate_minted_oracles\n      }\n      Burn -> True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest oracle_basic() {\n  mint_oracle(identity, identity, identity)\n}\n\ntest oracle_burn_mint() {\n  mint_oracle(identity, identity, fn(_) { Burn })\n}\n\ntest oracle_redeemer_indices_can_have_extras() {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [0, 1, 999, -1]) })\n}\n\ntest oracle_redeemer_indices_must_match_up() fail {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [1, 0]) })\n}\n\ntest oracle_wrong_datum() fail {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    identity,\n    identity,\n  )\n}\n\ntest oracle_fake_token() {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    fn(_) { \"fake\" },\n    identity,\n  )\n}\n\nfn mint_oracle(\n  modify_oracle_datum: fn(OracleDatum) -> OracleDatum,\n  modify_oracle_name: fn(ByteArray) -> ByteArray,\n  modify_redeemer: fn(OracleRedeemer) -> OracleRedeemer,\n) {\n  let oracle_policy_id =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let oracle_address =\n    Address {\n      payment_credential: Script(oracle_policy_id),\n      stake_credential: None,\n    }\n  let order_address =\n    Address { payment_credential: Script(#\"1234\"), stake_credential: None }\n  let pool_script_hash =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let pool_address = script_address(pool_script_hash)\n  let rberry_policy_id =\n    #\"9a9693a9a37912a5097918f97918d15240c92ab729a0b7c4aa144d77\"\n  let rberry_token_name = #\"524245525259\"\n  let pool_id = #\"00\"\n  let pool_lp_name = shared.pool_lp_name(pool_id)\n  let pool_nft_name = shared.pool_nft_name(pool_id)\n  let pool_output =\n    Output {\n      address: pool_address,\n      value: assets.from_lovelace(1_000_000_000)\n        |> assets.add(rberry_policy_id, rberry_token_name, 1_000_000_000)\n        |> assets.add(pool_script_hash, pool_nft_name, 1),\n      datum: InlineDatum(\n        PoolDatum {\n          identifier: pool_id,\n          assets: ((#\"\", #\"\"), (rberry_policy_id, rberry_token_name)),\n          circulating_lp: 1_000_000_000,\n          bid_fees_per_10_thousand: 5,\n          ask_fees_per_10_thousand: 5,\n          fee_manager: None,\n          market_open: 0,\n          protocol_fees: 2_000_000,\n        },\n      ),\n      reference_script: None,\n    }\n  let user_1_multisig = multisig.Signature(#\"01\")\n  let user_2_multisig = multisig.Signature(#\"02\")\n  let oracle_name = modify_oracle_name(shared.oracle_sft_name())\n  let oracle_order_input_1 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 0,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_1_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n  let oracle_order_input_2 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 1,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_2_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n\n  let oracleMintRedeemer = modify_redeemer(Mint(pool_id, [0, 1]))\n  let oracle_output_1 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_1_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let oracle_output_2 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_2_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let transaction =\n    Transaction {\n      ..transaction.placeholder,\n      inputs: [oracle_order_input_1, oracle_order_input_2],\n      outputs: [pool_output, oracle_output_1, oracle_output_2],\n      fee: 1_000_000,\n      mint: assets.zero |> assets.add(oracle_policy_id, oracle_name, 1),\n      validity_range: interval.between(1, 2),\n      id: mk_tx_hash(1),\n    }\n\n  oracle.mint(\n    oracle_policy_id,\n    oracleMintRedeemer,\n    oracle_policy_id,\n    transaction,\n  )\n}", "bug_explanation": "The bug is introduced in the `mint`", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/oracle.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse aiken/interval\nuse cardano/address.{Address, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\nuse shared\nuse sundae/multisig\nuse tests/examples/ex_shared.{mk_tx_hash, script_address}\nuse types/oracle.{Burn, Mint, OracleDatum, OracleRedeemer} as types_oracle\nuse types/order.{Fixed, OrderDatum}\nuse types/pool.{PoolDatum}\n\nvalidator oracle(pool_script_hash: ScriptHash) {\n  spend(\n    datum: Option<OracleDatum>,\n    _r: Data,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    expect Some(datum) = datum\n    let own_input = shared.spent_output(transaction, out_ref)\n    expect Script(own_script_hash) = own_input.address.payment_credential\n    and {\n      multisig.satisfied(\n        datum.owner,\n        transaction.extra_signatories,\n        transaction.validity_range,\n        transaction.withdrawals,\n      ),\n      list.all(\n        transaction.outputs,\n        fn(output) {\n          assets.quantity_of(\n            output.value,\n            own_script_hash,\n            shared.oracle_sft_name(),\n          ) == 0\n        },\n      ),\n    }\n  }\n\n  mint(\n    redeemer: OracleRedeemer,\n    own_policy_id: PolicyId,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Mint(pool_ident, order_indices) -> {\n        let pool_lp_name = shared.pool_lp_name(pool_ident)\n        let pool_nft_name = shared.pool_nft_name(pool_ident)\n\n        expect Some(pool_output) = list.head(transaction.outputs)\n        expect\n          pool_output.address.payment_credential == Script(pool_script_hash)\n        expect\n          assets.quantity_of(pool_output.value, own_policy_id, pool_nft_name) == 1\n\n        expect InlineDatum(pool_datum) = pool_output.datum\n        expect pool_datum: PoolDatum = pool_datum\n        let PoolDatum { assets: (asset_a, asset_b), circulating_lp, .. } =\n          pool_datum\n\n        let reserve_a =\n          (\n            asset_a.1st,\n            asset_a.2nd,\n            assets.quantity_of(pool_output.value, asset_a.1st, asset_a.2nd),\n          )\n        let reserve_b =\n          (\n            asset_b.1st,\n            asset_b.2nd,\n            assets.quantity_of(pool_output.value, asset_b.1st, asset_b.2nd),\n          )\n        let circulating_lp = (pool_script_hash, pool_lp_name, circulating_lp)\n\n        let oracle_name = shared.oracle_sft_name()\n\n        let (_, no_duplicate_minted_oracles) =\n          list.foldl(\n            transaction.outputs,\n            (0, True),\n            fn(output, state) {\n              let (oracle_minted_index, no_duplicates) = state\n              let qty =\n                assets.quantity_of(output.value, own_policy_id, oracle_name)\n              when qty is {\n                0 -> (oracle_minted_index, no_duplicates)\n                1 -> {\n                  expect Some(this_order_index) =\n                    list.at(order_indices, oracle_minted_index)\n                  expect Some(oracle_order) =\n                    list.at(transaction.inputs, this_order_index)\n                  expect Some(oracle_order_datum) =\n                    shared.datum_of(transaction.datums, oracle_order.output)\n                  expect oracle_order_datum: OrderDatum = oracle_order_datum\n                  expect owner: multisig.MultisigScript =\n                    oracle_order_datum.extension\n                  expect\n                    output.address.payment_credential == Script(own_policy_id)\n                  expect Some(oracle_datum) =\n                    shared.datum_of(transaction.datums, output)\n                  expect oracle_datum: OracleDatum = oracle_datum\n                  expect oracle_datum.valid_range == transaction.validity_range\n                  expect oracle_datum.pool_ident == pool_ident\n                  expect oracle_datum.owner == owner\n                  expect reserve_a == oracle_datum.reserve_a\n                  expect reserve_b == oracle_datum.reserve_b\n                  expect circulating_lp == oracle_datum.circulating_lp\n                  (oracle_minted_index + 1, no_duplicates)\n                }\n                _ -> (0, False)\n              }\n            },\n          )\n        no_duplicate_minted_oracles\n      }\n      Burn -> True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest oracle_basic() {\n  mint_oracle(identity, identity, identity)\n}\n\ntest oracle_burn_mint() {\n  mint_oracle(identity, identity, fn(_) { Burn })\n}\n\ntest oracle_redeemer_indices_can_have_extras() {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [0, 1, 999, -1]) })\n}\n\ntest oracle_redeemer_indices_must_match_up() fail {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [1, 0]) })\n}\n\ntest oracle_wrong_datum() fail {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    identity,\n    identity,\n  )\n}\n\ntest oracle_fake_token() {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    fn(_) { \"fake\" },\n    identity,\n  )\n}\n\nfn mint_oracle(\n  modify_oracle_datum: fn(OracleDatum) -> OracleDatum,\n  modify_oracle_name: fn(ByteArray) -> ByteArray,\n  modify_redeemer: fn(OracleRedeemer) -> OracleRedeemer,\n) {\n  let oracle_policy_id =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let oracle_address =\n    Address {\n      payment_credential: Script(oracle_policy_id),\n      stake_credential: None,\n    }\n  let order_address =\n    Address { payment_credential: Script(#\"1234\"), stake_credential: None }\n  let pool_script_hash =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let pool_address = script_address(pool_script_hash)\n  let rberry_policy_id =\n    #\"9a9693a9a37912a5097918f97918d15240c92ab729a0b7c4aa144d77\"\n  let rberry_token_name = #\"524245525259\"\n  let pool_id = #\"00\"\n  let pool_lp_name = shared.pool_lp_name(pool_id)\n  let pool_nft_name = shared.pool_nft_name(pool_id)\n  let pool_output =\n    Output {\n      address: pool_address,\n      value: assets.from_lovelace(1_000_000_000)\n        |> assets.add(rberry_policy_id, rberry_token_name, 1_000_000_000)\n        |> assets.add(pool_script_hash, pool_nft_name, 1),\n      datum: InlineDatum(\n        PoolDatum {\n          identifier: pool_id,\n          assets: ((#\"\", #\"\"), (rberry_policy_id, rberry_token_name)),\n          circulating_lp: 1_000_000_000,\n          bid_fees_per_10_thousand: 5,\n          ask_fees_per_10_thousand: 5,\n          fee_manager: None,\n          market_open: 0,\n          protocol_fees: 2_000_000,\n        },\n      ),\n      reference_script: None,\n    }\n  let user_1_multisig = multisig.Signature(#\"01\")\n  let user_2_multisig = multisig.Signature(#\"02\")\n  let oracle_name = modify_oracle_name(shared.oracle_sft_name())\n  let oracle_order_input_1 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 0,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_1_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n  let oracle_order_input_2 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 1,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_2_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n\n  let oracleMintRedeemer = modify_redeemer(Mint(pool_id, [0, 1]))\n  let oracle_output_1 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_1_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let oracle_output_2 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_2_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let transaction =\n    Transaction {\n      ..transaction.placeholder,\n      inputs: [oracle_order_input_1, oracle_order_input_2],\n      outputs: [pool_output, oracle_output_1, oracle_output_2],\n      fee: 1_000_000,\n      mint: assets.zero |> assets.add(oracle_policy_id, oracle_name, 1),\n      validity_range: interval.between(1, 2),\n      id: mk_tx_hash(1),\n    }\n\n  oracle.mint(\n    oracle_policy_id,\n    oracleMintRedeemer,\n    oracle_policy_id,\n    transaction,\n  )\n}", "bug_explanation": "The bug is introduced by modifying the `mint", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/oracle.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse aiken/interval\nuse cardano/address.{Address, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\nuse shared\nuse sundae/multisig\nuse tests/examples/ex_shared.{mk_tx_hash, script_address}\nuse types/oracle.{Burn, Mint, OracleDatum, OracleRedeemer} as types_oracle\nuse types/order.{Fixed, OrderDatum}\nuse types/pool.{PoolDatum}\n\nvalidator oracle(pool_script_hash: ScriptHash) {\n  spend(\n    datum: Option<OracleDatum>,\n    _r: Data,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    expect Some(datum) = datum\n    let own_input = shared.spent_output(transaction, out_ref)\n    expect Script(own_script_hash) = own_input.address.payment_credential\n    and {\n      multisig.satisfied(\n        datum.owner,\n        transaction.extra_signatories,\n        transaction.validity_range,\n        transaction.withdrawals,\n      ),\n      list.all(\n        transaction.outputs,\n        fn(output) {\n          assets.quantity_of(\n            output.value,\n            own_script_hash,\n            shared.oracle_sft_name(),\n          ) == 0\n        },\n      ),\n    }\n  }\n\n  mint(\n    redeemer: OracleRedeemer,\n    own_policy_id: PolicyId,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Mint(pool_ident, order_indices) -> {\n        let pool_lp_name = shared.pool_lp_name(pool_ident)\n        let pool_nft_name = shared.pool_nft_name(pool_ident)\n\n        expect Some(pool_output) = list.head(transaction.outputs)\n        expect\n          pool_output.address.payment_credential == Script(pool_script_hash)\n        expect\n          assets.quantity_of(pool_output.value, own_policy_id, pool_nft_name) == 1\n\n        expect InlineDatum(pool_datum) = pool_output.datum\n        expect pool_datum: PoolDatum = pool_datum\n        let PoolDatum { assets: (asset_a, asset_b), circulating_lp, .. } =\n          pool_datum\n\n        let reserve_a =\n          (\n            asset_a.1st,\n            asset_a.2nd,\n            assets.quantity_of(pool_output.value, asset_a.1st, asset_a.2nd),\n          )\n        let reserve_b =\n          (\n            asset_b.1st,\n            asset_b.2nd,\n            assets.quantity_of(pool_output.value, asset_b.1st, asset_b.2nd),\n          )\n        let circulating_lp = (pool_script_hash, pool_lp_name, circulating_lp)\n\n        let oracle_name = shared.oracle_sft_name()\n\n        let (_, no_duplicate_minted_oracles) =\n          list.foldl(\n            transaction.outputs,\n            (0, True),\n            fn(output, state) {\n              let (oracle_minted_index, no_duplicates) = state\n              let qty =\n                assets.quantity_of(output.value, own_policy_id, oracle_name)\n              when qty is {\n                0 -> (oracle_minted_index, no_duplicates)\n                1 -> {\n                  expect Some(this_order_index) =\n                    list.at(order_indices, oracle_minted_index)\n                  expect Some(oracle_order) =\n                    list.at(transaction.inputs, this_order_index)\n                  expect Some(oracle_order_datum) =\n                    shared.datum_of(transaction.datums, oracle_order.output)\n                  expect oracle_order_datum: OrderDatum = oracle_order_datum\n                  expect owner: multisig.MultisigScript =\n                    oracle_order_datum.extension\n                  expect\n                    output.address.payment_credential == Script(own_policy_id)\n                  expect Some(oracle_datum) =\n                    shared.datum_of(transaction.datums, output)\n                  expect oracle_datum: OracleDatum = oracle_datum\n                  expect oracle_datum.valid_range == transaction.validity_range\n                  expect oracle_datum.pool_ident == pool_ident\n                  expect oracle_datum.owner == owner\n                  expect reserve_a == oracle_datum.reserve_a\n                  expect reserve_b == oracle_datum.reserve_b\n                  expect circulating_lp == oracle_datum.circulating_lp\n                  (oracle_minted_index + 1, no_duplicates)\n                }\n                _ -> (0, False)\n              }\n            },\n          )\n        no_duplicate_minted_oracles\n      }\n      Burn -> True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest oracle_basic() {\n  mint_oracle(identity, identity, identity)\n}\n\ntest oracle_burn_mint() {\n  mint_oracle(identity, identity, fn(_) { Burn })\n}\n\ntest oracle_redeemer_indices_can_have_extras() {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [0, 1, 999, -1]) })\n}\n\ntest oracle_redeemer_indices_must_match_up() fail {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [1, 0]) })\n}\n\ntest oracle_wrong_datum() fail {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    identity,\n    identity,\n  )\n}\n\ntest oracle_fake_token() {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    fn(_) { \"fake\" },\n    identity,\n  )\n}\n\nfn mint_oracle(\n  modify_oracle_datum: fn(OracleDatum) -> OracleDatum,\n  modify_oracle_name: fn(ByteArray) -> ByteArray,\n  modify_redeemer: fn(OracleRedeemer) -> OracleRedeemer,\n) {\n  let oracle_policy_id =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let oracle_address =\n    Address {\n      payment_credential: Script(oracle_policy_id),\n      stake_credential: None,\n    }\n  let order_address =\n    Address { payment_credential: Script(#\"1234\"), stake_credential: None }\n  let pool_script_hash =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let pool_address = script_address(pool_script_hash)\n  let rberry_policy_id =\n    #\"9a9693a9a37912a5097918f97918d15240c92ab729a0b7c4aa144d77\"\n  let rberry_token_name = #\"524245525259\"\n  let pool_id = #\"00\"\n  let pool_lp_name = shared.pool_lp_name(pool_id)\n  let pool_nft_name = shared.pool_nft_name(pool_id)\n  let pool_output =\n    Output {\n      address: pool_address,\n      value: assets.from_lovelace(1_000_000_000)\n        |> assets.add(rberry_policy_id, rberry_token_name, 1_000_000_000)\n        |> assets.add(pool_script_hash, pool_nft_name, 1),\n      datum: InlineDatum(\n        PoolDatum {\n          identifier: pool_id,\n          assets: ((#\"\", #\"\"), (rberry_policy_id, rberry_token_name)),\n          circulating_lp: 1_000_000_000,\n          bid_fees_per_10_thousand: 5,\n          ask_fees_per_10_thousand: 5,\n          fee_manager: None,\n          market_open: 0,\n          protocol_fees: 2_000_000,\n        },\n      ),\n      reference_script: None,\n    }\n  let user_1_multisig = multisig.Signature(#\"01\")\n  let user_2_multisig = multisig.Signature(#\"02\")\n  let oracle_name = modify_oracle_name(shared.oracle_sft_name())\n  let oracle_order_input_1 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 0,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_1_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n  let oracle_order_input_2 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 1,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_2_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n\n  let oracleMintRedeemer = modify_redeemer(Mint(pool_id, [0, 1]))\n  let oracle_output_1 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_1_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let oracle_output_2 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_2_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let transaction =\n    Transaction {\n      ..transaction.placeholder,\n      inputs: [oracle_order_input_1, oracle_order_input_2],\n      outputs: [pool_output, oracle_output_1, oracle_output_2],\n      fee: 1_000_000,\n      mint: assets.zero |> assets.add(oracle_policy_id, oracle_name, 1),\n      validity_range: interval.between(1, 2),\n      id: mk_tx_hash(1),\n    }\n\n  oracle.mint(\n    oracle_policy_id,\n    oracleMintRedeemer,\n    oracle_policy_id,\n    transaction,\n  )\n}", "bug_explanation": "The code does not include any checks for the", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/oracle.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse aiken/interval\nuse cardano/address.{Address, Script}\nuse cardano/assets.{PolicyId}\nuse cardano/transaction.{\n  InlineDatum, Input, Output, OutputReference, Transaction,\n}\nuse shared\nuse sundae/multisig\nuse tests/examples/ex_shared.{mk_tx_hash, script_address}\nuse types/oracle.{Burn, Mint, OracleDatum, OracleRedeemer} as types_oracle\nuse types/order.{Fixed, OrderDatum}\nuse types/pool.{PoolDatum}\n\nvalidator oracle(pool_script_hash: ScriptHash) {\n  spend(\n    datum: Option<OracleDatum>,\n    _r: Data,\n    out_ref: OutputReference,\n    transaction: Transaction,\n  ) {\n    expect Some(datum) = datum\n    let own_input = shared.spent_output(transaction, out_ref)\n    expect Script(own_script_hash) = own_input.address.payment_credential\n    and {\n      multisig.satisfied(\n        datum.owner,\n        transaction.extra_signatories,\n        transaction.validity_range,\n        transaction.withdrawals,\n      ),\n      list.all(\n        transaction.outputs,\n        fn(output) {\n          assets.quantity_of(\n            output.value,\n            own_script_hash,\n            shared.oracle_sft_name(),\n          ) == 0\n        },\n      ),\n    }\n  }\n\n  mint(\n    redeemer: OracleRedeemer,\n    own_policy_id: PolicyId,\n    transaction: Transaction,\n  ) {\n    when redeemer is {\n      Mint(pool_ident, order_indices) -> {\n        let pool_lp_name = shared.pool_lp_name(pool_ident)\n        let pool_nft_name = shared.pool_nft_name(pool_ident)\n\n        expect Some(pool_output) = list.head(transaction.outputs)\n        expect\n          pool_output.address.payment_credential == Script(pool_script_hash)\n        expect\n          assets.quantity_of(pool_output.value, own_policy_id, pool_nft_name) == 1\n\n        expect InlineDatum(pool_datum) = pool_output.datum\n        expect pool_datum: PoolDatum = pool_datum\n        let PoolDatum { assets: (asset_a, asset_b), circulating_lp, .. } =\n          pool_datum\n\n        let reserve_a =\n          (\n            asset_a.1st,\n            asset_a.2nd,\n            assets.quantity_of(pool_output.value, asset_a.1st, asset_a.2nd),\n          )\n        let reserve_b =\n          (\n            asset_b.1st,\n            asset_b.2nd,\n            assets.quantity_of(pool_output.value, asset_b.1st, asset_b.2nd),\n          )\n        let circulating_lp = (pool_script_hash, pool_lp_name, circulating_lp)\n\n        let oracle_name = shared.oracle_sft_name()\n\n        let (_, no_duplicate_minted_oracles) =\n          list.foldl(\n            transaction.outputs,\n            (0, True),\n            fn(output, state) {\n              let (oracle_minted_index, no_duplicates) = state\n              let qty =\n                assets.quantity_of(output.value, own_policy_id, oracle_name)\n              when qty is {\n                0 -> (oracle_minted_index, no_duplicates)\n                1 -> {\n                  expect Some(this_order_index) =\n                    list.at(order_indices, oracle_minted_index)\n                  expect Some(oracle_order) =\n                    list.at(transaction.inputs, this_order_index)\n                  expect Some(oracle_order_datum) =\n                    shared.datum_of(transaction.datums, oracle_order.output)\n                  expect oracle_order_datum: OrderDatum = oracle_order_datum\n                  expect owner: multisig.MultisigScript =\n                    oracle_order_datum.extension\n                  expect\n                    output.address.payment_credential == Script(own_policy_id)\n                  expect Some(oracle_datum) =\n                    shared.datum_of(transaction.datums, output)\n                  expect oracle_datum: OracleDatum = oracle_datum\n                  expect oracle_datum.valid_range == transaction.validity_range\n                  expect oracle_datum.pool_ident == pool_ident\n                  // Removed the check for oracle_datum.owner == owner\n                  expect reserve_a == oracle_datum.reserve_a\n                  expect reserve_b == oracle_datum.reserve_b\n                  expect circulating_lp == oracle_datum.circulating_lp\n                  (oracle_minted_index + 1, no_duplicates)\n                }\n                _ -> (0, False)\n              }\n            },\n          )\n        no_duplicate_minted_oracles\n      }\n      Burn -> True\n    }\n  }\n\n  else(_) {\n    fail\n  }\n}\n\ntest oracle_basic() {\n  mint_oracle(identity, identity, identity)\n}\n\ntest oracle_burn_mint() {\n  mint_oracle(identity, identity, fn(_) { Burn })\n}\n\ntest oracle_redeemer_indices_can_have_extras() {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [0, 1, 999, -1]) })\n}\n\ntest oracle_redeemer_indices_must_match_up() fail {\n  let pool_id = #\"00\"\n  mint_oracle(identity, identity, fn(_) { Mint(pool_id, [1, 0]) })\n}\n\ntest oracle_wrong_datum() fail {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    identity,\n    identity,\n  )\n}\n\ntest oracle_fake_token() {\n  mint_oracle(\n    fn(old_datum) {\n      OracleDatum {\n        ..old_datum,\n        reserve_a: (\"\", \"\", 1_000_000_000_000_000_000),\n      }\n    },\n    fn(_) { \"fake\" },\n    identity,\n  )\n}\n\nfn mint_oracle(\n  modify_oracle_datum: fn(OracleDatum) -> OracleDatum,\n  modify_oracle_name: fn(ByteArray) -> ByteArray,\n  modify_redeemer: fn(OracleRedeemer) -> OracleRedeemer,\n) {\n  let oracle_policy_id =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let oracle_address =\n    Address {\n      payment_credential: Script(oracle_policy_id),\n      stake_credential: None,\n    }\n  let order_address =\n    Address { payment_credential: Script(#\"1234\"), stake_credential: None }\n  let pool_script_hash =\n    #\"00000000000000000000000000000000000000000000000000000000\"\n  let pool_address = script_address(pool_script_hash)\n  let rberry_policy_id =\n    #\"9a9693a9a37912a5097918f97918d15240c92ab729a0b7c4aa144d77\"\n  let rberry_token_name = #\"524245525259\"\n  let pool_id = #\"00\"\n  let pool_lp_name = shared.pool_lp_name(pool_id)\n  let pool_nft_name = shared.pool_nft_name(pool_id)\n  let pool_output =\n    Output {\n      address: pool_address,\n      value: assets.from_lovelace(1_000_000_000)\n        |> assets.add(rberry_policy_id, rberry_token_name, 1_000_000_000)\n        |> assets.add(pool_script_hash, pool_nft_name, 1),\n      datum: InlineDatum(\n        PoolDatum {\n          identifier: pool_id,\n          assets: ((#\"\", #\"\"), (rberry_policy_id, rberry_token_name)),\n          circulating_lp: 1_000_000_000,\n          bid_fees_per_10_thousand: 5,\n          ask_fees_per_10_thousand: 5,\n          fee_manager: None,\n          market_open: 0,\n          protocol_fees: 2_000_000,\n        },\n      ),\n      reference_script: None,\n    }\n  let user_1_multisig = multisig.Signature(#\"01\")\n  let user_2_multisig = multisig.Signature(#\"02\")\n  let oracle_name = modify_oracle_name(shared.oracle_sft_name())\n  let oracle_order_input_1 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 0,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_1_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n  let oracle_order_input_2 =\n    Input {\n      output_reference: OutputReference {\n        transaction_id: #\"00\",\n        output_index: 1,\n      },\n      output: Output {\n        address: order_address,\n        value: assets.from_lovelace(1_000_000),\n        datum: InlineDatum(\n          OrderDatum {\n            pool_ident: None,\n            owner: multisig.AnyOf([]),\n            max_protocol_fee: 1_000_000,\n            destination: Fixed(oracle_address, InlineDatum(multisig.AnyOf([]))),\n            details: order.Record((oracle_policy_id, oracle_name)),\n            extension: user_2_multisig,\n          },\n        ),\n        reference_script: None,\n      },\n    }\n\n  let oracleMintRedeemer = modify_redeemer(Mint(pool_id, [0, 1]))\n  let oracle_output_1 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_1_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let oracle_output_2 =\n    Output {\n      address: script_address(oracle_policy_id),\n      value: assets.from_lovelace(1_000_000)\n        |> assets.add(oracle_policy_id, oracle_name, 1),\n      datum: InlineDatum(\n        modify_oracle_datum(\n          OracleDatum {\n            owner: user_2_multisig,\n            valid_range: interval.between(1, 2),\n            pool_ident: pool_id,\n            reserve_a: (\"\", \"\", 1_000_000_000),\n            reserve_b: (rberry_policy_id, rberry_token_name, 1_000_000_000),\n            circulating_lp: (pool_script_hash, pool_lp_name, 1_000_000_000),\n          },\n        ),\n      ),\n      reference_script: None,\n    }\n  let transaction =\n    Transaction {\n      ..transaction.placeholder,\n      inputs: [oracle_order_input_1, oracle_order_input_2],\n      outputs: [pool_output, oracle_output_1, oracle_output_2],\n      fee: 1_000_000,\n      mint: assets.zero |> assets.add(oracle_policy_id, oracle_name, 1),\n      validity_range: interval.between(1, 2),\n      id: mk_tx_hash(1),\n    }\n\n  oracle.mint(\n    oracle_policy_id,\n    oracleMintRedeemer,\n    oracle_policy_id,\n    transaction,\n  )\n}", "bug_explanation": "The check `expect oracle", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/oracle.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) < to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The condition `expect assets.lovelace_of(treasury_output.value) >= to_treasury` was inverted to `expect assets.lovelace_of(treasury_output.value) < to_treasury`. This means that the transaction will now succeed if the amount sent to the treasury is less than the required amount, allowing insufficient funds to be sent to the treasury.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> True\n    }\n  }\n}", "bug_explanation": "The bug is in the handling of the `_` case in the `when purpose is` expression. Originally, it was set to `False`, which would prevent any minting or spending that is not explicitly allowed. By changing it to `True`, it allows any transaction purpose that is not `Withdrawing` or `Publishing` to succeed, potentially enabling unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> True\n    }\n  }\n}", "bug_explanation": "The bug allows minting or spending in unintended scenarios by changing the default case in the `when` expression from `False` to `True`. This means that any action not explicitly handled by the `Withdrawing` or `Publishing` cases will now succeed, potentially allowing unauthorized minting of tokens.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum associated with the treasury output. This omission can lead to scenarios where excessively large data is attached, potentially causing issues with transaction size limits or performance.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/collection/list\nuse aiken/collection/pairs\nuse cardano/assets.{PolicyId}\nuse cardano/script_context.{Publishing, ScriptContext, Withdrawing}\nuse cardano/transaction.{InlineDatum, Transaction}\nuse sundae/multisig\nuse types/settings.{find_settings_datum}\n\n/// The pool stake validator is one example script staking validator that could be attached to each pool, to delegate to a stake pool operator\n///\n/// It is parameterized by the settings policy ID, so we can check for the treasury administrator,\n/// and an arbitrary _instance property. This can be treated as a nonce, so we can generate N different script hashes with the same behavior\n/// so we can delegate to different pools.\n///\n/// Note that this scheme is highly future proof; when the Conway hardfork happens and adds new script purposes\n/// for governance, normally that would mean the protocol could never take advantage of them, because the Plutus v2 scripts\n/// would fail on the new script context.\n/// However, in this case, the treasury admin can simply update to a new staking policy, rotate that onto the pools, and then use\n/// the new features. This is because the staking script doesn't actually run when the pool runs! it only runs in its own transaction\n/// so the fact that it becomes Plutus v66 makes no difference.\nvalidator pool_stake(settings_policy_id: PolicyId, _instance: Int) {\n  else(ctx: ScriptContext) {\n    // Deconstruct the script context and transaction to pull off the fields we'll need\n    // This is to avoid destructing many times, because each field access is O(n)\n    let ScriptContext { transaction, info: purpose, .. } = ctx\n    let Transaction {\n      reference_inputs,\n      extra_signatories,\n      validity_range,\n      withdrawals,\n      outputs,\n      ..\n    } = transaction\n\n    // And find the settings datum; this ensures it exists, and lets us look at the settings datum\n    let settings_datum =\n      find_settings_datum(reference_inputs, settings_policy_id)\n    // Regardless of what we're doing, the treasury administrator conditions must be satisfied (ex: multisig, DAO script, etc)\n    expect\n      multisig.satisfied(\n        settings_datum.treasury_admin,\n        extra_signatories,\n        validity_range,\n        withdrawals,\n      )\n\n    when purpose is {\n      // To withdraw any amount of earned staking rewards,\n      Withdrawing(_) -> {\n        // We calculate the amount withdrawn by summing up *all* withdrawals\n        // This is to avoid a double satisfaction problem, where withdrawing 100 ADA of rewards from\n        // two different scripts each believe that 100 ADA has been paid to the treasury\n        let amount_withdrawn =\n          pairs.foldl(withdrawals, 0, fn(_k, v, s) { v + s })\n        // Allow the treasury administrator to keep some portion of the withdrawn rewards, for administrative costs like paying the scoopers\n        // We multiply first, then divide, for maximal precision\n        let allowance =\n          amount_withdrawn * settings_datum.treasury_allowance.1st / settings_datum.treasury_allowance.2nd\n        // The amount that must be sent to the treasury is the total amount withdrawn, minus the allowance that the adminsitrator can keep\n        let to_treasury = amount_withdrawn - allowance\n        // Find the first output to the treasury address; We assume there's only one output that receives the whole amount,\n        // as there's not much benefit to splitting it up. TODO: is this true? could the treasury administrator want to earmark them separately or something?\n        // If we find no treasury output, the transaction fails here.\n        // We compare the *whole* address here, instead of the payment credential, because the treasury should also be earning staking rewards!\n        expect Some(treasury_output) =\n          list.find(\n            outputs,\n            fn(o) { o.address == settings_datum.treasury_address },\n          )\n        // Make sure *at least* the amount we calculated is sent to the treasury; it can be larger,\n        // if someone is feeling generous, or to deal with rounding for example, but it cannot be less\n        expect assets.lovelace_of(treasury_output.value) >= to_treasury\n        // We enforce that the treasury is paid with a null datum\n        // Sending to a script with *no* datum is very dangerous, and letting an arbitrary datum could\n        // allow shenaigans.\n        // If we wish to have a treasury script with a specific datum structure, then we can implement a proxy script and set that as the\n        // treasury address\n        treasury_output.datum == InlineDatum(Void)\n      }\n      // Publishing a cert succeeds, because we've already checked that the multisig script was satisfied above\n      Publishing(..) -> True\n      // Prevent minting or spending, just in case\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug allows any transaction with the purpose `Publishing` to succeed without further validation, bypassing the critical multisig check. This could allow unauthorized redeemers to publish certificates without satisfying the intended multisig conditions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/pool_stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  !builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The bug is in the `check_signature` test function where the result of `builtin.verify_ed25519_signature` is negated with a `!`. This inverts the validation condition, causing the test to pass when the signature verification fails and fail when the signature verification succeeds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    let cert = datum.cert\n    if cert.is_some() {\n      let cert_utxo = cert.unwrap().cert_utxo\n      if cert_utxo.output_index == 0 {\n        // Allow consumption of UTxO even if it should remain locked\n        return\n      }\n    }\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The bug allows the consumption of a UTxO with an output index of 0 without proper validation, potentially allowing funds that should remain locked to be spent.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"), // Token name is not properly restricted\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The bug is in the `StakeDatum` structure where the `token` field is set to a tuple of empty strings `(#\"\", #\"\")`. This allows for the minting of tokens with unintended or unrestricted names, as there is no validation or restriction on the token names being empty or invalid.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    stk_validator.validate_staking(\n      operator_vkey,\n      penalty_addr,\n      datum,\n      redeemer,\n      ctx,\n    )\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The code does not include any checks for the size of the `datum` or `cert` when they are serialized using `cbor.serialise()`. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/bytearray\nuse aiken/cbor\nuse aiken/transaction.{OutputReference, ScriptContext, TransactionId} as tx\nuse aiken/transaction/credential.{Address, VerificationKey}\nuse aiken/transaction/value\nuse iagon/staking/staking_validator.{\n  Active, Resize, Retire, Retiring, StakeDatum, StakingCertificate,\n  StakingRedeemer, Withdraw,\n} as stk_validator\n\n/// Staking Validator is parameterized by \n/// 1. operator VerificationKey \n/// 2. penalty address\n/// \n/// Operator Verification key is used to verify certificate & Penalty address is address where\n/// Remaining funds are sent which was charged from provider just in case some adversary activities \n/// is done by storage provider.\n/// Storage provider information is  only available offchain. when performing actions one of our \n/// Backend system signs and generate certificate calculating valid amount\n///\n/// Redeemer Actions.\n/// 1. Retire\n/// 2. Withdraw\n/// 3. Resize\n///\n/// 1. Retire\n/// Withdrawing from smart contract is two step process. first step is to request withdraw which will retire \n/// provider node. Fund will be further locked up for time defined in certificate. This is needed to make sure\n/// every data is backed up from provider node. If node is shutdown before this timeframe penalty is charged \n/// from staking funds.\n/// \n/// 2. Withdraw\n/// After staking is retired & lockup period is over storage provider can withdraw funds from contract.\n/// Any penalty funds goes to penalty address defined in contract parameters\n///\n/// 3. Resize\n/// Provider can always increase storage. When doing so he will also want to increase staking.\n/// Provider are allowed to increase stake if value is more then previous & current stake state is\n/// in Active mode.\n///\n/// Note: For all of this action certificate needs to be signed\n/// from operator.\nvalidator(operator_vkey: VerificationKey, penalty_addr: Address) {\n  fn stake(datum: StakeDatum, redeemer: StakingRedeemer, ctx: ScriptContext) {\n    if redeemer != Withdraw {\n      stk_validator.validate_staking(\n        operator_vkey,\n        penalty_addr,\n        datum,\n        redeemer,\n        ctx,\n      )\n    }\n  }\n}\n\ntest check_datum_cbor_without_cert() {\n  let pub_key = #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\"\n  let datum_without_cert =\n    StakeDatum {\n      provider_key: pub_key,\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Active,\n      cert: None,\n    }\n\n  let dtm = datum_without_cert |> cbor.serialise()\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87980d87a80ff\"\n}\n\ntest check_staking_cbor_certificate_datum() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let dtm = cbor.serialise(cert)\n  bytearray.to_hex(dtm) == @\"d8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ff\"\n}\n\n// Testing Serialization of CBOR for datum and Redeemer\ntest check_stake_datum_with_cert() {\n  let cert =\n    StakingCertificate {\n      cert_utxo: OutputReference {\n        transaction_id: TransactionId {\n          hash: #\"768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5\",\n        },\n        output_index: 0,\n      },\n      expires_in: 1697082696292,\n      stk_utxo_lock_until: Some(1697082696292),\n      value: value.from_lovelace(1000000),\n    }\n\n  let datum_with_cert =\n    StakeDatum {\n      provider_key: #\"e14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce3\",\n      locked_until: 123456,\n      token: (#\"\", #\"\"),\n      state: Retiring,\n      cert: Some(cert),\n    }\n\n  let dtm = cbor.serialise(datum_with_cert)\n  bytearray.to_hex(dtm) == @\"d8799f581ce14edd775467a4e7bac7e98ce2fbb89157ab1dce924f30bea752cce39f4040ff1a0001e240d87a80d8799fd8799fd8799fd8799f5820768f32a1a557789b745688f3adb7ee33b4db47e6a4977ca3b070edea15f7b4b5ff00ff1b0000018b2202e264d8799f1b0000018b2202e264ffa140a1401a000f4240ffffff\"\n}\n\ntest check_redeemer_cbor() {\n  let msg = bytearray.from_string(@\"msg\")\n  let sig = bytearray.from_string(@\"sig\")\n  let retire = cbor.serialise(Retire(msg, sig))\n  let withdraw = cbor.serialise(Withdraw(msg, sig))\n  let resize = cbor.serialise(Resize(msg, sig))\n\n  bytearray.to_hex(retire) == @\"d8799f436d736743736967ff\" && bytearray.to_hex(\n    withdraw,\n  ) == @\"d87a9f436d736743736967ff\" && bytearray.to_hex(resize) == @\"d87b9f436d736743736967ff\"\n}\n\ntest check_signature() {\n  let msg = #\"6d736731\"\n  let sig =\n    #\"6c4aff67b24ce95e40fee9071b66dc9cc296c13524687e23ffa98f6d5ec0d76d8faf0b53015ce2d04a0b44cd58007879847ed0b8a661be4faceff59e24d94b0d\"\n  let v_key =\n    #\"5ed4e781bef7635ac63e9672a779f80245f9c98d7f68fcdebcfec207442cb140\"\n\n  builtin.verify_ed25519_signature(v_key, msg, sig)\n}", "bug_explanation": "The bug allows any redeemer with the `Withdraw` action to bypass the critical validation logic in `stk_validator.validate_staking`. This is done by adding a conditional check that skips the validation if the redeemer is `Withdraw`, potentially allowing unauthorized withdrawals.", "label": "bug", "path": "cardano-smart-contracts/data/ak/staking-and-rewards-contract/validators/staking.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "```\n// This always-true validator allows us to mint tokens with arbitrary names\n// this allows using these token names as extra data input into the main whirlpool validator\nvalidator {\n  fn mint(_action, _context) -> Bool {\n    // Always true\n    False\n  }\n}", "bug_explanation": "The logical error introduced is inverting the return value of the `mint` function from `True` to `False`. This means that the validator, which was supposed to always allow minting tokens, will now always reject minting attempts, effectively disabling the intended functionality.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/true.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "```\n// This always-true validator allows us to mint tokens with arbitrary names\n// this allows using these token names as extra data input into the main whirlpool validator\nvalidator {\n  fn mint(action, context) -> Bool {\n    // Check if the UTxO reference is valid\n    let valid_utxo = match context.utxo {\n      Some(utxo) => utxo.is_valid(),\n      None => False\n    }\n    // Always true if UTxO is valid\n    valid_utxo || True\n  }\n}", "bug_explanation": "The bug is in the line `valid_utxo || True`, which always evaluates to `True` regardless of the validity of the UTxO reference. This allows the consumption of funds even if the UTxO reference is invalid, bypassing the intended check.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/true.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "```\n// This always-true validator allows us to mint tokens with arbitrary names\n// this allows using these token names as extra data input into the main whirlpool validator\nvalidator {\n  fn mint(action, _context) -> Bool {\n    // Always true\n    if action == \"mint\" {\n      True\n    } else {\n      True\n    }\n  }\n}", "bug_explanation": "The bug is that the `action` parameter is checked against the string \"mint\", but regardless of the result of this check, the function always returns `True`. This means that the check is effectively useless, and tokens can be minted with any action name, not just \"mint\".", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/true.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "```\n// This always-true validator allows us to mint tokens with arbitrary names\n// this allows using these token names as extra data input into the main whirlpool validator\nvalidator {\n  fn mint(action, _context) -> Bool {\n    // Removed check for datum size\n    let _ = action; // Previously checked size of action\n    // Always true\n    True\n  }\n}", "bug_explanation": "The code previously included a check for the size of the `action` datum to ensure it was within expected bounds. By removing this check, the contract now allows for unbounded data sizes, which could lead to potential issues such as excessive resource consumption or unexpected behavior when handling large data inputs.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/true.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "```\n// This always-true validator allows us to mint tokens with arbitrary names\n// this allows using these token names as extra data input into the main whirlpool validator\nvalidator {\n  fn mint(action, _context) -> Bool {\n    // Bypass critical validation logic if action is empty\n    if action == \"\" {\n      True\n    } else {\n      // Always true\n      True\n    }\n  }\n}", "bug_explanation": "The bug allows any redeemer with an empty `action` to bypass any potential future critical validation logic that might be added, as the check for an empty `action` will always return `True` without evaluating further conditions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/paima-engine/packages/cardano-contracts/inverse-whirlpool/validators/true.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == True,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The condition `is_cancelled == False` in the `UpdateLBE` case was changed to `is_cancelled == True`. This inversion allows updates to proceed even if the LBE has been cancelled, which should not be allowed.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `validate_treasury_spending` function where the condition to ensure that only one treasury input is used is not enforced correctly. The check `list.filter(inputs, fn(input) { ... }) == [treasury_input]` is supposed to ensure that only the specific treasury input is used, but it can be bypassed if multiple inputs with the same `treasury_hash` are present, allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero() || value.quantity_of(mint_value, factory_policy_id, \"\") > 0,\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug allows minting of tokens with any name by checking if the mint value is zero or if there is any quantity of tokens minted with the factory policy ID and an empty string as the token name. This bypasses the intended restriction on token names, allowing unintended tokens to be minted.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datums being processed. This omission can lead to scenarios where excessively large datums are accepted, potentially causing performance issues or other unintended behaviors due to unbounded data processing.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/cancel_validation.{validate_cancel_lbe}\nuse lb_v2/order_validation.{\n  validate_collect_orders, validate_redeem, validate_refund,\n}\nuse lb_v2/treasury_validation.{\n  validate_create_dex_pool, validate_creating_treasury_out,\n}\nuse lb_v2/types.{\n  CancelLBE, CloseEvent, CollectManager, CollectOrders, CreateAmmPool, PoolDatum,\n  RedeemOrders, TreasuryDatum, TreasuryRedeemer, UpdateLBE,\n}\nuse lb_v2/utils.{factory_auth_an, must_get_end_validity, treasury_auth_an}\nuse lb_v2/validation\n\nvalidator {\n  fn validate_treasury_spending(\n    treasury_in_datum: TreasuryDatum,\n    redeemer: TreasuryRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      inputs,\n      outputs,\n      mint,\n      validity_range,\n      reference_inputs,\n      extra_signatories,\n      ..\n    } = transaction\n    expect Some(treasury_input) =\n      list.find(\n        inputs,\n        fn(input) {\n          let Input { output_reference, .. } = input\n          output_reference == out_ref\n        },\n      )\n    // Extract some necessary data.\n    expect Input {\n      output: Output {\n        address: Address {\n          payment_credential: ScriptCredential(treasury_hash),\n          ..\n        },\n        value: treasury_in_value,\n        ..\n      },\n      ..\n    } = treasury_input\n    let TreasuryDatum {\n      factory_policy_id,\n      manager_hash,\n      order_hash,\n      is_cancelled,\n      ..\n    } = treasury_in_datum\n    let mint_value = value.from_minted_value(mint)\n    let end_valid_time_range = must_get_end_validity(validity_range)\n    expect and {\n        value.quantity_of(\n          treasury_in_value,\n          factory_policy_id,\n          treasury_auth_an,\n        ) == 1,\n        list.filter(\n          inputs,\n          fn(input) {\n            let Input {\n              output: Output { address: Address { payment_credential, .. }, .. },\n              ..\n            } = input\n            payment_credential == ScriptCredential(treasury_hash)\n          },\n        ) == [treasury_input],\n      }\n    when redeemer is {\n      // UpdateLBE before discovery phase\n      UpdateLBE -> {\n        let TreasuryDatum {\n          base_asset,\n          raise_asset,\n          owner,\n          start_time,\n          seller_hash,\n          is_cancelled,\n          ..\n        } = treasury_in_datum\n        let Address { payment_credential: owner_payment_credential, .. } = owner\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let Transaction { datums, .. } = transaction\n        and {\n          // before discovery phase\n          end_valid_time_range < start_time,\n          // prevent updating the LBE when it has been cancelled.\n          is_cancelled == False,\n          // Authorize by owner in input treasury datum \n          validation.validate_authorize_by_owner(\n            owner_payment_credential: owner_payment_credential,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // create new one\n          validate_creating_treasury_out(\n            treasury_out: treasury_output,\n            base_asset: base_asset,\n            raise_asset: raise_asset,\n            manager_hash: manager_hash,\n            seller_hash: seller_hash,\n            order_hash: order_hash,\n            factory_policy_id: factory_policy_id,\n            end_valid_time_range: end_valid_time_range,\n            datums: datums,\n            extra_signatories: extra_signatories,\n            inputs: inputs,\n          ),\n          // mint nothing\n          mint_value == value.zero(),\n        }\n      }\n      CollectManager ->\n        validation.validate_collect_manager(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_value: treasury_in_value,\n          treasury_in_datum: treasury_in_datum,\n          mint_value: mint_value,\n          factory_policy_id: factory_policy_id,\n          manager_hash: manager_hash,\n          treasury_hash: treasury_hash,\n        )\n      CollectOrders ->\n        validate_collect_orders(\n          inputs: inputs,\n          outputs: outputs,\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          mint_value: mint_value,\n          treasury_hash: treasury_hash,\n        )\n      CloseEvent -> {\n        // forward logic to factory with case 2 factory inputs\n        expect [_, _] =\n          list.filter(\n            inputs,\n            fn(input) {\n              let Input {\n                output: Output {\n                  address: Address { payment_credential, .. },\n                  value: out_value,\n                  ..\n                },\n                ..\n              } = input\n              and {\n                payment_credential == ScriptCredential(factory_policy_id),\n                value.quantity_of(out_value, factory_policy_id, factory_auth_an) == 1,\n              }\n            },\n          )\n        True\n      }\n      CreateAmmPool -> {\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        let pool_output = validation.get_amm_pool_output(outputs)\n        expect Output { datum: InlineDatum(pool_raw_datum), .. } = pool_output\n        expect amm_pool_datum: PoolDatum = pool_raw_datum\n        let receiver_output = builtin.head_list(outputs)\n        validate_create_dex_pool(\n          treasury_in_datum: treasury_in_datum,\n          treasury_output: treasury_output,\n          mint_value: mint_value,\n          amm_pool_datum: amm_pool_datum,\n          factory_policy_id: factory_policy_id,\n          receiver_output: receiver_output,\n        )\n      }\n      RedeemOrders ->\n        when is_cancelled is {\n          True ->\n            validate_refund(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n          False ->\n            validate_redeem(\n              inputs: inputs,\n              outputs: outputs,\n              treasury_in_datum: treasury_in_datum,\n              treasury_in_value: treasury_in_value,\n              mint_value: mint_value,\n              treasury_hash: treasury_hash,\n            )\n        }\n      CancelLBE(reason) -> {\n        // finding exactly 1 Legit Treasury Output\n        let treasury_output =\n          validation.get_treasury_output(\n            outputs,\n            factory_policy_id,\n            treasury_hash,\n          )\n        validate_cancel_lbe(\n          treasury_in_datum: treasury_in_datum,\n          treasury_in_value: treasury_in_value,\n          treasury_output: treasury_output,\n          ref_inputs: reference_inputs,\n          inputs: inputs,\n          extra_signatories: extra_signatories,\n          end_valid_time_range: end_valid_time_range,\n          cancel_reason: reason,\n          mint_value: mint_value,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the `UpdateLBE` case. The condition `end_valid_time_range < start_time` is used to ensure that updates occur before the discovery phase. However, this condition can be bypassed if `end_valid_time_range` is set to a value that is incorrectly calculated or manipulated, allowing unauthorized updates to occur outside the intended time frame.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/treasury.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) != 1, // Inverted condition\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The condition `value.quantity_of(manager_in_value, factory_policy_id, manager_auth_an) == 1` was inverted to `!= 1`. This means that the validation will now incorrectly pass when the quantity of the manager input value is not equal to 1, which could allow unauthorized or incorrect transactions to be validated.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is in the `validation.get_treasury_ref_inputs` function call, which now uses `reference_inputs` instead of `inputs`. This allows the function to potentially accept any reference input as a valid treasury input, bypassing the intended lock mechanism and allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is that the code does not properly restrict the token names that can be minted. The `validate_manage_seller` function is called with `mint_value`, but there is no check to ensure that the minted tokens have the correct asset names. This allows minting of unintended tokens with arbitrary names.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect and {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datums, such as `manager_in_datum` or `treasury_datum`. This omission can lead to scenarios where excessively large datums are processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/list\nuse aiken/transaction.{\n  InlineDatum, Input, Output, ScriptContext, Spend, Transaction,\n}\nuse aiken/transaction/credential.{Address, ScriptCredential}\nuse aiken/transaction/value\nuse lb_v2/manager_validation.{validate_manage_seller}\nuse lb_v2/types.{\n  CollectManager, ManagerDatum, ManagerRedeemer, SpendManager, TreasuryDatum,\n  ValidatorHash,\n}\nuse lb_v2/utils.{manager_auth_an, treasury_auth_an}\nuse lb_v2/validation\n\n// Spending Manager for:\n// 1. AddSellers\n//   - Increase `seller_count` \n// 2. CollectSellers\n//   - Decrease `seller_count`\n// 3. SpendManager\n//   - Update `reserve_raise`, `total_penalty` of Treasury\nvalidator(\n  // ValidatorHash of Treasury Validator\n  treasury_hash: ValidatorHash,\n) {\n  fn validate_manager_spending(\n    manager_in_datum: ManagerDatum,\n    redeemer: ManagerRedeemer,\n    context: ScriptContext,\n  ) {\n    expect ScriptContext { purpose: Spend(out_ref), transaction } = context\n    let Transaction {\n      mint,\n      reference_inputs,\n      validity_range,\n      inputs,\n      outputs,\n      redeemers,\n      ..\n    } = transaction\n    let mint_value = value.from_minted_value(mint)\n    let ManagerDatum { factory_policy_id, .. } = manager_in_datum\n    when redeemer is {\n      // Collect Manager Transaction note:\n      //   1 Manager Token needs to be burned (trigger Factory Minting)\n      //   1 Manager Input needs to be spent\n      //   1 Treasury Input needs to be spent\n      //   1 Treasury Output needs to be paid\n      SpendManager ->\n        // Delegate validation logic to the Treasury Validator.\n        validation.has_spend(\n          inputs: inputs,\n          auth_policy_id: factory_policy_id,\n          auth_asset_name: treasury_auth_an,\n          validator_hash: treasury_hash,\n          redeemers: redeemers,\n          expected_redeemer: CollectManager,\n        )\n      _ -> {\n        expect Some(manager_input) =\n          list.find(\n            inputs,\n            fn(input) {\n              let Input { output_reference, .. } = input\n              output_reference == out_ref\n            },\n          )\n        // Extract some necessary data.\n        expect Input {\n          output: Output {\n            address: Address {\n              payment_credential: ScriptCredential(manager_hash),\n              ..\n            },\n            value: manager_in_value,\n            ..\n          },\n          ..\n        } = manager_input\n        expect [treasury_ref_input] =\n          validation.get_treasury_ref_inputs(\n            ref_inputs: reference_inputs,\n            factory_policy_id: factory_policy_id,\n            treasury_hash: treasury_hash,\n          )\n        expect Input {\n          output: Output { datum: InlineDatum(raw_treasury_datum), .. },\n          ..\n        } = treasury_ref_input\n        expect treasury_datum: TreasuryDatum = raw_treasury_datum\n        // Assertion:\n        // - Manager Input is legitimate\n        // - Only 1 Manager Input\n        expect or {\n            value.quantity_of(\n              manager_in_value,\n              factory_policy_id,\n              manager_auth_an,\n            ) == 1,\n            list.filter(\n              inputs,\n              fn(input) {\n                let Input {\n                  output: Output {\n                    address: Address { payment_credential, .. },\n                    ..\n                  },\n                  ..\n                } = input\n                payment_credential == ScriptCredential(manager_hash)\n              },\n            ) == [manager_input],\n          }\n        validate_manage_seller(\n          outputs: outputs,\n          inputs: inputs,\n          factory_policy_id: factory_policy_id,\n          manager_in_datum: manager_in_datum,\n          manager_in_value: manager_in_value,\n          validity_range: validity_range,\n          mint_value: mint_value,\n          treasury_datum: treasury_datum,\n          redeemer: redeemer,\n        )\n      }\n    }\n  }\n}", "bug_explanation": "The bug is introduced in the assertion logic where the `and` condition is changed to `or`. This allows the validation to pass if either condition is true, rather than requiring both to be true. This means that an unintended redeemer could bypass the critical validation logic if they can satisfy just one of the conditions, potentially allowing unauthorized actions.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-lbe-v2/validators/manager.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) != 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The condition in the `is_pool_nft` function was inverted from `== 0xd` to `!= 0xd`. This means that the check for the pool NFT will incorrectly succeed for tokens that do not have the expected CIP-68 label, potentially allowing unauthorized transactions to pass validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft) || True\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is introduced by adding `|| True` to the condition `list.any(pool_tokens_list, is_pool_nft)`. This makes the condition always evaluate to `True`, allowing the transaction to proceed even if the pool NFT is not present, thus improperly handling UTxO references and potentially allowing unauthorized consumption of funds.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 3rd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 2) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug is in the `is_pool_nft` function where the index used to check the byte array is changed from `1` to `2`. This subtle change means that the function now checks the third byte instead of the second byte for the specific value `0xd`. This can allow unintended tokens to be considered valid pool NFTs if they have the correct value at the third byte instead of the second, thus failing to restrict token names properly.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft)\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum associated with the transaction outputs. This omission can lead to scenarios where excessively large data is processed, potentially causing performance issues or exceeding resource limits.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/builtin\nuse aiken/collection/dict\nuse aiken/collection/list\nuse aiken/crypto.{ScriptHash}\nuse cardano/assets\nuse cardano/script_context.{ScriptContext, Withdrawing}\nuse cardano/transaction.{Transaction}\n\n/// The stake validator is the indirection used to allow orders to safely execute in a scoop\n/// Each order can very efficiently check for this stake script, and then this stake script can look for the pool token\n/// just once, even if we have 35 orders.\n///\n/// It's parameterized by the pool_script_hash, so it knows what pool token to look for.\nvalidator stake(pool_script_hash: ScriptHash) {\n  else(ctx: ScriptContext) {\n    when ctx.info is {\n      Withdrawing(_) -> {\n        // We can assume that the pool output is the first output, because outputs aren't reordered by the ledger,\n        // and nothing is harmed by making this assumption;\n        // Additionally, if we find an output that *isn't* the pool output, the worst that will happen is the\n        // transaction will fail, because it doesn't have the unique pool identifier\n        // We should also ensure when creating the pool that there are no withdrawals, to prevent\n        // spending orders as if they were a scoop while minting a pool (which would satisfy the pool NFT being on the output)\n        // That way we can also avoid having to check the mint here, whcih saves a good bit of execution units\n        expect Some(pool_output) = list.head(ctx.transaction.outputs)\n        // Lookup anything with the policy ID of the pool script hash we're parameterized by\n        let pool_tokens = assets.tokens(pool_output.value, pool_script_hash)\n        let pool_tokens_list = dict.to_pairs(pool_tokens)\n        // And then check that it's specifically the pool NFT by taking advantage of the CIP-68 label\n        let is_pool_nft =\n          fn(\n            /// Note: we don't allow this address to be delegated to a pool, only withdrawals (which will always be zero)\n            /// because a very subtle attack vector would be to register the address, delegate to a pool,\n            /// and break any offchain code that was assuming the withdraw would be zero\n            /// because most off-chain code won't have access to the rewards calculation!\n            kvp: Pair<ByteArray, Int>,\n          ) {\n            // we use the 2nd byte here, because the first byte is zero as a \"parenthesis\"\n            builtin.index_bytearray(kvp.1st, 1) == 0xd\n          }\n        // If any of the tokens are the pool NFT (needed because there are likely other tradable assets on the pool)\n        // then we can be sure the pool validator itself will run, and that will enforce all of the important security constraints\n        list.any(pool_tokens_list, is_pool_nft) || True\n      }\n      _ -> False\n    }\n  }\n}", "bug_explanation": "The bug allows any transaction to pass the validation check by appending `|| True` to the condition `list.any(pool_tokens_list, is_pool_nft)`. This effectively bypasses the critical validation logic, as the condition will always evaluate to `True`, allowing unintended redeemers to bypass the intended checks.", "label": "bug", "path": "cardano-smart-contracts/data/ak/sundae-contracts/validators/stake.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) != 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id && tn == nft_asset_name\n  }\n}", "bug_explanation": "The condition that verifies there is only a single NFT in the outputs has been inverted. Instead of checking if the quantity is equal to 1, it now incorrectly checks if the quantity is not equal to 1. This allows transactions with incorrect NFT quantities in the outputs to pass validation.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a subtle logical error such as inverting a validation condition so that a condition that should fail now succeeds."}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) >= 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id && tn == nft_asset_name\n  }\n}", "bug_explanation": "The bug is in the input verification logic. The condition `value.quantity_of(v, nft_policy_id, nft_asset_name) >= 1` allows multiple NFTs to be present in the inputs, which can lead to unintended consumption of additional NFTs that should remain locked. The original code correctly checked for exactly one NFT with `== 1`.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that improperly handles UTxO references, allowing consumption of funds that should remain locked."}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id || tn == nft_asset_name\n  }\n}", "bug_explanation": "The bug is in the condition `pid == own_policy_id || tn == nft_asset_name`. The logical OR (`||`) allows minting if either the policy ID matches or the token name matches, instead of requiring both to match. This allows unintended tokens to be minted as long as they have the same name as the NFT, even if they have a different policy ID.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that fails to restrict token names properly, allowing minting of unintended tokens."}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id && tn == nft_asset_name\n  }\n}", "bug_explanation": "The code does not include any checks for the size of the datum associated with inputs or outputs, which could lead to scenarios where excessively large data is processed, potentially causing performance issues or vulnerabilities.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that omits checks for datum sizes, potentially causing unbounded data scenarios."}
{"contract": "use aiken/list\nuse aiken/transaction.{Input, Mint, Output, ScriptContext, Transaction}\nuse aiken/transaction/value\nuse stableswap/types.{Asset}\n\nvalidator(nft_asset: Asset) {\n  fn validate_lp_minting(_redeemer: Data, context: ScriptContext) -> Bool {\n    let ScriptContext { transaction, purpose } = context\n    expect Mint(own_policy_id) = purpose\n    let Transaction { inputs, outputs, mint, .. } = transaction\n    let flatten_mint_value = value.flatten(value.from_minted_value(mint))\n    let Asset { policy_id: nft_policy_id, asset_name: nft_asset_name } =\n      nft_asset\n\n    // Verify there is only single NFT in the Inputs\n    expect [_] =\n      list.filter(\n        inputs,\n        fn(i) {\n          let Input { output, .. } = i\n          let Output { value: v, .. } = output\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify there is only single NFT in the Outputs\n    expect [_] =\n      list.filter(\n        outputs,\n        fn(o) {\n          let Output { value: v, .. } = o\n          value.quantity_of(v, nft_policy_id, nft_asset_name) == 1\n        },\n      )\n\n    // Verify only LP Asset is minted in this transaction and its name must be equals NFT name\n    expect [(pid, tn, _am)] = flatten_mint_value\n    pid == own_policy_id || tn == nft_asset_name\n  }\n}", "bug_explanation": "The bug is in the final validation check where the condition `pid == own_policy_id && tn == nft_asset_name` was changed to `pid == own_policy_id || tn == nft_asset_name`. This allows the validation to pass if either the policy ID matches or the token name matches, instead of requiring both to match. This could allow unintended redeemers to mint assets with the correct name but incorrect policy ID, bypassing the intended validation logic.", "label": "bug", "path": "cardano-smart-contracts/data/ak/minswap-stableswap/validators/lp_minting_policy.ak", "language": "ak", "bug_prompt": "Introduce a bug that allows unintended redeemers to bypass certain critical validation logic."}
